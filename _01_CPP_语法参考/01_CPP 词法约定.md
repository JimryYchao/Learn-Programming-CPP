# CPP：词法约定

---
## 单独翻译

程序的文本保存在本文档中称为源文件的单元中。一个源文件连同所有的头文件和通过预处理指令 `#include` 包含的源文件，减去任何条件包含预处理指令跳过的源行，被称为预处理翻译单元。

一个 C++ 程序不需要全部同时翻译。以前翻译过的翻译单元和实例化单元可以单独保存或保存在库中。程序的独立翻译单元通过 (例如) 调用其标识符具有外部或模块链接的函数、操作其标识符具有外部或模块链接的对象或操作数据文件进行通信。翻译单元可以单独翻译，然后再链接以产生可执行程序。

---
## 翻译阶段

翻译语法规则的优先顺序由以下几个阶段指定：
1. 实现应支持 UTF-8 代码单元序列 (UTF-8 文件) 的输入文件。它还可以支持一组由实现定义的其他类型的输入文件，如果是这样，那么输入文件的类型将以一种由实现定义的方式确定，这种方式包括一种将输入文件指定为 UTF-8 文件的方法，与它们的内容无关。换句话说，仅仅识别 **U+FEFF BYTE ORDER MARK** 是不够的。<br>
如果一个输入文件被确定为 UTF-8 文件，那么它应该是一个格式良好的 UTF-8 代码单元序列，并对其进行解码以产生一个 Unicode 标量值序列。然后，通过将每个 Unicode 标量值映射到相应的翻译字符集元素，形成翻译字符集元素序列。在结果序列中，由 U+000D 回车后跟 U+000A 换行组成的输入序列中的每对字符，以及每个 U+000D 回车后面没有紧跟着 U+000A 换行的字符，都被单个换行字符替换。对于实现支持的任何其他类型的输入文件，字符以实现定义的方式映射到翻译字符集元素序列，将行尾指示符表示为新行字符。
<br>

2. 如果第一个翻译字符是 **U+FEFF BYTE ORDER MARK**，则删除。每个反斜杠字符 (`\`) 后面紧跟着零个或多个空白字符的序列 (而不是 new-line 后面跟着一个 new-line 字符的序列) 将被删除，拼接物理源行形成逻辑源行。只有任何物理源行上的最后一个反斜杠才有资格成为这种拼接的一部分。行拼接可以形成通用字符名。非空且 (拼接后) 不以换行字符结束的源文件将被处理，就像在文件中附加了一个额外的换行字符一样。
<br>

3. 源文件被分解为预处理标记（5.4）和空白字符序列（包括注释）。源文件不应以部分预处理标记或部分注释结束。每个注释被替换为一个空格字符。保留新行字符。除新行外的每个非空白字符序列是否保留或被一个空格字符替换是未指定的。当从源文件中消耗字符以形成下一个预处理标记（即，不作为注释或其他形式的空白的一部分被消耗）时，除了匹配c-char-sequence、s-char-sequence、r-char-sequence、h-char-sequence或q-char-sequence时，universal-character-names被识别并被替换为翻译字符集的指定元素。将源文件的字符划分为预处理标记的过程是上下文相关的。
[示例1：参见在#include预处理指令（15.3）中对<的处理。- 示例结束]
4. 执行预处理指令，扩展宏调用，并执行_Pragma一元运算符表达式。#include预处理指令导致命名的头文件或源文件从阶段1到阶段4递归地被处理。然后删除所有预处理指令。
5. 对于两个或更多相邻的字符串字面量标记的序列，确定一个公共的编码前缀，如5.13.5中所指定的。然后认为每个这样的字符串字面量标记都具有那个公共的编码前缀。
6. 相邻的字符串字面量标记被连接（5.13.5）。
7. 分隔标记的空白字符不再重要。每个预处理标记被转换为一个标记（5.6）。结果标记构成一个翻译单元，并被语法和语义分析和翻译。
[注3：分析和翻译标记的过程有时会导致一个标记被一系列其他标记替换（13.3）。- 注结束]
是否需要提供当前翻译单元具有接口依赖性（10.1，10.3）的模块单元和头单元的源是由实现定义的。
[注4：源文件、翻译单元和翻译后的翻译单元不必一定存储为文件，也不必在这些实体和任何外部表示之间有任何一对一的对应关系。描述只是概念性的，不指定任何特定的实现。- 注结束]
8. 翻译后的翻译单元和实例化单元按如下方式组合：
[注5：这些可以全部或部分从库中提供。- 注结束]
检查每个翻译后的翻译单元以产生所需实例化的列表。
[注6：这可以包括已经明确请求的实例化（13.9.3）。- 注结束]
找到所需模板的定义。是否需要提供包含这些定义的翻译单元的源是由实现定义的。
[注7：实现可以选择将足够的信息编码到翻译后的翻译单元中，以确保这里不需要源。- 注结束]
执行所有所需的实例化以产生实例化单元。
[注8：这些与翻译后的翻译单元类似，但不包含对未实例化模板的引用和没有模板定义。- 注结束]
如果任何实例化失败，程序就是格式错误的。
9. 解析所有外部实体引用。链接库组件以满足对当前翻译中未定义的实体的外部引用。所有这样的翻译器输出被收集到一个程序映像中，该映像包含在其执行环境中执行所需的信息。


---
## 字符集



## end 

接下来你会翻译我说的每句英文为中文