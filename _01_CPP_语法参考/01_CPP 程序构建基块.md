## C++ ç¨‹åºæ„å»ºåŸºå—

- [ ] [ç”¨æˆ·å®šä¹‰æ–‡æœ¬](#ç”¨æˆ·å®šä¹‰æ–‡æœ¬-todo)


---
### è¯æ³•å…ƒç´ 

#### å­—ç¬¦é›†

C++ æŒ‡å®šå¯ç”¨äºæºæ–‡ä»¶çš„åŸºæœ¬æºå­—ç¬¦é›†å’Œé€šç”¨å­—ç¬¦é›†ï¼š

```c++
' ', '\t', '\v', '\f', '\n',
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '
```

é€šç”¨å­—ç¬¦åç§°æ˜¯å½¢å¦‚ `\u hhhh` æˆ– `\U HHHHHHHH` è¡¨ç¤ºçš„ Unicode ç ä½çš„å­—ç¬¦åºåˆ—ã€‚ç”¨äºæ ‡è¯†æ ‡è¯†ç¬¦ã€å­—ç¬¦ä¸²æˆ–å­—ç¬¦æ–‡æœ¬ã€‚

æ‰§è¡Œå­—ç¬¦é›†è¡¨ç¤ºç¼–è¯‘ç¨‹åºä¸­å¯æ˜¾ç¤ºçš„å­—ç¬¦å’Œå­—ç¬¦ä¸²ã€‚è¿™äº›å­—ç¬¦é›†åŒ…å«æºæ–‡ä»¶ä¸­å…è®¸çš„æ‰€æœ‰å­—ç¬¦ï¼Œä»¥åŠè¡¨ç¤º `\a`ã€`\b`ã€`\r` å’Œ `\0` çš„æ§åˆ¶å­—ç¬¦ã€‚æ‰§è¡Œå­—ç¬¦é›†å…·æœ‰ç‰¹å®šäºåŒºåŸŸè®¾ç½®çš„è¡¨ç¤ºå½¢å¼ã€‚

>---
#### æ ‡è®°

æ ‡è®°æœ‰äº”ç§ï¼šæ ‡è¯†ç¬¦ã€å…³é”®å­—ã€æ–‡æœ¬ã€è¿ç®—ç¬¦å’Œå…¶ä»–åˆ†éš”ç¬¦ï¼›ç©ºç™½å­—ç¬¦åŒ…æ‹¬æœ‰ç©ºæ ¼ ```' '```ã€æ°´å¹³åˆ¶è¡¨ç¬¦ ```'\t'```ã€æ¢è¡Œç¬¦ ```'\n'```ã€å›è½¦ç¬¦ ```'\r'```ã€æ¢é¡µç¬¦ ```'\f'``` å’Œå‚ç›´åˆ¶è¡¨ç¬¦ ```'\v'```ã€‚æ ‡è®°ç”±ç©ºç™½ç¬¦å’Œå…¶ä»–æ ‡è®°åˆ†éš”ï¼ˆåˆ’åˆ†è¾¹ç•Œï¼‰ï¼Œåœ¨åˆ†æä»£ç æ—¶ï¼Œç¼–è¯‘å™¨å°†å¿½ç•¥ç©ºç™½å­—ç¬¦ã€‚

æ ‡è¯†ç¬¦ä¸ºç¨‹åºä¸­çš„å¯¹è±¡ã€å˜é‡ã€ç±»å‹ã€ç±»å‹æˆå‘˜ã€å‡½æ•°ã€ç±»å‹å®šä¹‰ã€å®å®šä¹‰ã€å®å‚æ•°å‚æ•°å’Œæ ‡ç­¾æä¾›åç§°ï¼Œåç§°åœ¨æ‹¼å†™å’Œå¤§å°å†™ä¸Šå¿…é¡»ä¸ä»»ä½•å…³é”®å­—éƒ½ä¸åŒã€‚æ ‡è¯†ç¬¦çš„é¦–å­—ç¬¦ä¸å¯ä»¥æ˜¯æ•°å­—å­—ç¬¦ã€‚

```cpp
/* æœ‰æ•ˆæ ‡è¯†ç¬¦ */  // æ³¨é‡Š
_Identifier
Identifier
Identifier123
```

`final`ã€`import`ã€`module`ã€`override` ä¿ç•™å…³é”®å­—ç”± C++ ç¼–è¯‘å™¨ä½¿ç”¨ã€‚

>---
#### Keywords

| keyword | description |
| :------ | :---------- |
`alignas`
`alignof`
`asm`
`auto`
`bool`
`break`
`case`
`catch`
`char`
`char8_t`
`char16_t`
`char32_t`
`class`
`concept`
`const`
`consteval`
`constexpr`
`constinit`
`const_cast`
`continue`
`co_await`
`co_return`
`co_yield`
`decltype`
`default`
`delete`
`do`
`double`
`dynamic_cast`
`else`
`enum`
`explicit`
`export`
`extern`
`false`
`float`
`for`
`friend`
`goto`
`if`
`inline`
`int`
`long`
`mutable`
`namespace`
`new`
`noexcept`
`nullptr`
`operator`
`private`
`protected`
`public`
`register`
`reinterpret_cast`
`requires`
`return`
`short`
`signed`
`sizeof`
`static`
`static_assert`
`static_cast`
`struct`
`switch`
`template`
`this`
`thread_local`
`throw`
`true`
`try`
`typedef`
`typeid`
`typename`
`union`
`unsigned`
`using`
`virtual`
`void`
`volatile`
`wchar_t`
`while`


>---
#### Operators & Punctuation

```cpp
{ } [ ] ( )
<: :> <% %> ; : ...
? :: . .* -> ->* ~
! + - * / % ^ & |
= += -= *= /= %= ^= &= |=
== != < > <= >= <=> && ||
<< >> <<= >>= ++ -- ,
and or xor not bitand bitor compl
and_eq or_eq xor_eq not_eq
```

> æ›¿ç”¨æ ‡å¿—ï¼Œä¿ç•™

```cpp
// Alternative/Primary
    <%           {   
    %>           }    
    <:           [    
    :>           ]    
    %:           #    
    %:%:         ##   
    and          &&    
    or           ||  
    not          !  
    xor          ^     
    bitand       &    
    bitor        | 
    compl        ~     
    not_eq       !=  
    xor_eq       ^= 
    and_eq       &= 
    or_eq        |=  
```

>---
#### Number, Boolean, Pointer Literal

æ–‡æœ¬æ˜¯ä¸€ç§ç›´æ¥è¡¨ç¤ºå€¼çš„ç¨‹åºå…ƒç´ ã€‚åŒ…å«ç”±æ•´æ•°ã€æµ®ç‚¹ã€å¸ƒå°”ã€æŒ‡é’ˆã€å­—ç¬¦ã€å­—ç¬¦ä¸²ç±»å‹çš„æ–‡æœ¬ä»¥åŠç”¨æˆ·å®šä¹‰çš„æ–‡æœ¬ã€‚

æ•´æ•°æ–‡æœ¬å¯ä»¥æ˜¯äºŒè¿›åˆ¶ã€å…«è¿›åˆ¶ã€åè¿›åˆ¶æˆ–åå…­è¿›åˆ¶çš„æ•°å­—åºåˆ—ï¼š

```cpp
long b = 0b1011'0101;      // b-binary
long o = 013245670;        // 0-octal
long i = 1234567890LL;     // decimal
long long h = 0x1234'5678'90ab'cdfLL;  // x-hexadecimal

unsigned ui = 110u;
unsigned long long uh = 0XFFFFULL; //x-hexadecimal
size_t z = -10010z;
ssize_t uz = 10086uz;
```

æµ®ç‚¹æ–‡æœ¬æ˜¯åè¿›åˆ¶æˆ–åå…­è¿›åˆ¶ï¼ˆ`0x` or `0X` å‰ç¼€ï¼‰è¡¨ç¤ºçš„æ•°å­—åºåˆ—ã€‚*E* æŒ‡æ•°è¡¨ç¤ºæ³•ï¼ˆä»¥ 10 ä¸ºåŸºæ•°ï¼‰ç”¨äºåè¿›åˆ¶ï¼›*P* æŒ‡æ•°è¡¨ç¤ºæ³•ï¼ˆä»¥ 2 ä¸ºåŸºæ•°ï¼‰ç”¨äºåå…­è¿›åˆ¶ã€‚

```c++
float f = 3.1415F;
double d = 3.1415;
long double ld = 3.1415L;
float16_t f16 = 3.1415f16;
float32_t f32 = 3.1415f32;
float64_t d2 = 3.1415f64;
float128_t f64 = 3.1415f128;
bfloat16_t bf16 = 3.1415bf16;  // BF
// decimal
double e1 = 1.234e-2; 
double e2 = 1.234E2;
// hexadecimal
double p1 = 0x1p-2;	  // == 0.25
double p2 = 0x2.p10;  // == 2048.0
```

å¸ƒå°”æ–‡æœ¬æ˜¯å…³é”®å­— `false` å’Œ `true`ã€‚æ­¤ç±»æ–‡æœ¬çš„ç±»å‹ä¸º `bool`ã€‚

æŒ‡é’ˆæ–‡æœ¬æ˜¯å…³é”®å­— `nullptr`ã€‚å®ƒçš„ç±»å‹ä¸º `std::nullptr_t`ã€‚`nullptr` ç”¨æ¥åˆå§‹åŒ–é›¶å€¼æŒ‡é’ˆã€‚



>---
#### Character, String Literal

å­—ç¬¦æ–‡æœ¬è¡¨ç¤ºä¸€ä¸ªæˆ–å¤šä¸ªå¤šå­—èŠ‚å­—ç¬¦çš„åºåˆ—ã€‚`wchar_t`ã€`char16_t`ã€`char32_t` å­—ç¬¦ç§°ä¸ºå®½å­—ç¬¦ï¼Œ`char8_t` å’Œæ™®é€šå­—ç¬¦ä¸ºçª„å­—ç¬¦ã€‚åºåˆ—å…ƒç´ æ˜¯æºå­—ç¬¦é›†çš„ä»»ä½•æˆå‘˜ï¼›å®ƒä»¬ä»¥å®ç°å®šä¹‰çš„æ–¹å¼æ˜ å°„åˆ°æ‰§è¡Œå­—ç¬¦é›†çš„æˆå‘˜ã€‚

```c++
// Character literals
auto c0 =   'A';  // char; æ™®é€šå­—ç¬¦
auto c1 = u8'A';  // char; UTF-8
auto c2 =  L'A';  // wchar_t; å®½å­—ç¬¦
auto c3 =  u'A';  // char16_t; UTF-16
auto c4 =  U'A';  // char32_t; UTF-32
auto m0 = 'abcd'; // int, value 0x61626364; å¤šå­—èŠ‚

// å…«è¿›åˆ¶ã€åå…­è¿›åˆ¶è½¬ä¹‰åºåˆ—å’Œé€šç”¨å­—ç¬¦åºåˆ—
char u1 = 'A';          // 'A'
char u2 = '\101';       // octal, 'A'; 1-3 ä½å…«è¿›åˆ¶ï¼Œæœ€å¤§ \377
char u3 = '\x41';       // hexadecimal, 'A'
char u4 = '\u0041';     // \u UCN 'A'
char u5 = '\U00000041'; // \U UCN 'A'

// è½¬ä¹‰å­—ç¬¦
'\'' '\"' '\?' '\\' '\a' '\b' '\f' '\n' '\r' '\t' '\v'
```

å­—ç¬¦ä¸²æ–‡æœ¬çš„ç§ç±»ã€ç±»å‹åŠå…¶å…³è”çš„å­—ç¬¦ç¼–ç ç”±å…¶ç¼–ç å‰ç¼€å’Œå­—ç¬¦åºåˆ—å†³å®šã€‚å¸¸è§„å­—ç¬¦ä¸²æ–‡æœ¬å’Œ UTF-8 å­—ç¬¦ä¸²æ–‡æœ¬ç§°ä¸ºçª„å­—ç¬¦ä¸²æ–‡æœ¬ã€‚

```c++
auto s0 =   "hello"; // const char*
auto s1 = u8"hello"; // const char8_t* 
auto s2 =  L"hello"; // const wchar_t*
auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16
auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32
const char32_t* s5 = U"ğŸ˜ = \U0001F60E is B-)";
```

å‰ç¼€ä¸­å¸¦æœ‰ R çš„å­—ç¬¦ä¸²æ–‡æœ¬æ˜¯åŸå§‹å­—ç¬¦ä¸²æ–‡æœ¬ã€‚`R"delimiter( char-sequence )delimiter"` ä¸­ `delimiter` æœ€å¤šåŒ…å« 16 ä¸ªå­—ç¬¦ï¼›`R"((a|b))"` ç­‰ä»·äº `"(a|b)"`ã€‚

```c++
auto R0 =   R"("Hello \ world")"; // const char*
auto R1 = u8R"("Hello \ world")"; // const char8_t*
auto R2 =  LR"("Hello \ world")"; // const wchar_t*
auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16
auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32
```

`s` åç¼€è¡¨ç¤ºæ˜ å°„åˆ° `std::string` ç±»å‹çš„é™æ€å€¼ã€‚

```c++
auto S0 =   "hello"s; // std::string
auto S1 = u8"hello"s; // std::u8string in C++20
auto S2 =  L"hello"s; // std::wstring
auto S3 =  u"hello"s; // std::u16string
auto S4 =  U"hello"s; // std::u32string

auto S5 =   R"("Hello \ world")"s; // std::string from a raw const char*
auto S6 = u8R"("Hello \ world")"s; // std::u8string from a raw const char* 
auto S7 =  LR"("Hello \ world")"s; // std::wstring from a raw const wchar_t*
auto S8 =  uR"("Hello \ world")"s; // std::u16string from a raw const char16_t*, encoded as UTF-16
auto S9 =  UR"("Hello \ world")"s; // std::u32string from a raw const char32_t*, encoded as UTF-32
```

ç›¸é‚»å­—ç¬¦ä¸²æ–‡æœ¬åºåˆ—çš„å…¬å…±ç¼–ç å‰ç¼€è¦ä¹ˆç›¸åŒï¼Œè¦ä¹ˆå…¶ä¸­ä¸€ä¸ªæ²¡æœ‰ç¼–ç å‰ç¼€ï¼›ä»»ä½•å…¶ä»–ç»„åˆéƒ½æ˜¯æ ¼å¼ä¸æ­£ç¡®çš„ã€‚è®¡ç®—å­—ç¬¦ä¸²æ–‡æœ¬ä¼šç”Ÿæˆå…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å­—ç¬¦ä¸²æ–‡æœ¬å¯¹è±¡ã€‚

```c++
char str[] = "12" "34";  // "1234"
auto hi = u8"hello" " " "world"s;
auto err = U"hello" " " L"world"; // disagree on prefix
```

>---
#### User Defined Literal

ç”¨æˆ·å®šä¹‰æ–‡æœ¬å¯ä»¥æ˜¯æ•´æ•°ã€æµ®ç‚¹æ•°ã€å­—ç¬¦æˆ–å­—ç¬¦ä¸²ç”¨æˆ·å®šä¹‰ï¼Œç”¨æˆ·å®šä¹‰æ–‡æœ¬ç”±ä¸€ä¸ªç”¨æˆ·å®šä¹‰åç¼€æ ‡è¯†ã€‚ç”¨æˆ·å®šä¹‰æ–‡æœ¬è¢«è§†ä¸ºå¯¹æ–‡æœ¬è¿ç®—ç¬¦æˆ–æ–‡æœ¬è¿ç®—ç¬¦æ¨¡æ¿çš„è°ƒç”¨ã€‚

```c++
using namespace std;
long double operator""_w(long double);
string operator""_w(const char16_t *, size_t);
unsigned operator""_w(const char *);
int main()
{
	1.2_w;	  // calls operator ""_w(1.2L)
	u"one"_w; // calls operator ""_w(u"one", 3)
	12_w;	  // calls operator ""_w("12")
	"two"_w; // error: no applicable literal operator
}
```

é€šè¿‡ä»¥ä¸‹å½¢å¼ä¹‹ä¸€åœ¨å‘½åç©ºé—´èŒƒå›´å®šä¹‰ `operator""` æ¥å®ç°ç”¨æˆ·å®šä¹‰æ–‡æœ¬ï¼Œè¿™äº›å‡½æ•°éƒ½å¯å®šä¹‰ä¸º `constexpr`ï¼š

```c++
ReturnType operator "" _a(unsigned long long int);   // user-defined INTEGRAL literal
ReturnType operator "" _b(long double);              // user-defined FLOATING literal
ReturnType operator "" _c(char);                     // user-defined CHARACTER literal
ReturnType operator "" _d(wchar_t);                  // user-defined CHARACTER literal
ReturnType operator "" _e(char16_t);                 // user-defined CHARACTER literal
ReturnType operator "" _f(char32_t);                 // user-defined CHARACTER literal
ReturnType operator "" _g(const char*, size_t);      // user-defined STRING literal
ReturnType operator "" _h(const wchar_t*, size_t);   // user-defined STRING literal
ReturnType operator "" _i(const char16_t*, size_t);  // user-defined STRING literal
ReturnType operator "" _g(const char32_t*, size_t);  // user-defined STRING literal
ReturnType operator "" _r(const char*);              // Raw literal operator
template<char...> ReturnType operator "" _t();       // Literal operator template
```

---
### åŸºæœ¬æ¦‚å¿µ
#### ç¿»è¯‘é˜¶æ®µ

æºæ–‡ä»¶ä»¥åŠé€šè¿‡é¢„å¤„ç†æŒ‡ä»¤ `#include` åŒ…å«çš„æ‰€æœ‰å¤´æ–‡ä»¶å’Œæºæ–‡ä»¶ï¼Œå»æ‰ä»»ä½•è¢«æ¡ä»¶ç¼–è¯‘ `#if` è·³è¿‡çš„éƒ¨åˆ†ï¼Œä»¥åŠç”±ä»»ä½•æ¡ä»¶æ”¯æŒçš„æŒ‡ä»¤å’Œç¼–è¯‘æŒ‡ç¤ºçš„å®ç°å®šä¹‰è¡Œä¸ºä¿®æ”¹ï¼Œè¢«ç§°ä¸ºé¢„å¤„ç†ç¿»è¯‘å•å…ƒã€‚

æºæ–‡ä»¶ä¸éœ€è¦å…¨éƒ¨åŒæ—¶ç¿»è¯‘ï¼Œç¿»è¯‘å•å…ƒå’Œå®ä¾‹åŒ–å•å…ƒå¯ä»¥å•ç‹¬ä¿å­˜æˆ–ä¿å­˜åœ¨åº“ä¸­ï¼Œç¨‹åºçš„å•ç‹¬ç¿»è¯‘å•å…ƒé€šè¿‡è°ƒç”¨å…·æœ‰å¤–éƒ¨é“¾æ¥æˆ–æ¨¡å—é“¾æ¥çš„å‡½æ•°ã€å¯¹è±¡ç­‰çš„æ ‡è¯†ç¬¦ã€æˆ–æ“ä½œæ•°æ®æ–‡ä»¶è¿›è¡Œé€šä¿¡ã€‚ç¿»è¯‘å•å…ƒå¯ä»¥å•ç‹¬ç¿»è¯‘ï¼Œç„¶åé“¾æ¥å…¶ä»–å•å…ƒä»¥ç”Ÿæˆå¯æ‰§è¡Œç¨‹åºã€‚

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯èƒ½éœ€è¦åœ¨ .cpp æ–‡ä»¶ä¸­å£°æ˜å…¨å±€å˜é‡æˆ–ç±»ã€‚ åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œä½ éœ€è¦ä¸€ç§æ–¹æ³•æ¥å‘ŠçŸ¥ç¼–è¯‘å™¨å’Œé“¾æ¥å™¨åç§°æ‰€å…·æœ‰çš„é“¾æ¥ç±»å‹ã€‚ é“¾æ¥çš„ç±»å‹æŒ‡å®šå¯¹è±¡çš„åç§°æ˜¯ä»…åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­å¯è§ï¼Œè¿˜æ˜¯åœ¨æ‰€æœ‰æ–‡ä»¶ä¸­å¯è§ã€‚ é“¾æ¥çš„æ¦‚å¿µä»…é€‚ç”¨äºå…¨å±€åç§°ã€‚ é“¾æ¥çš„æ¦‚å¿µä¸é€‚ç”¨äºåœ¨ä¸€å®šèŒƒå›´å†…å£°æ˜çš„åç§°ã€‚ èŒƒå›´æ˜¯ç”±ä¸€ç»„å°é—­çš„å¤§æ‹¬å·æŒ‡å®šçš„ï¼Œä¾‹å¦‚åœ¨å‡½æ•°æˆ–ç±»çš„å®šä¹‰ä¸­ã€‚

1. å­—ç¬¦æ˜ å°„ï¼šæºæ–‡ä»¶ä¸­çš„å­—ç¬¦å°†æ˜ å°„åˆ°å†…éƒ¨æºè¡¨ç¤ºå½¢å¼ã€‚
2. è¡Œæ‹¼æ¥ï¼šä»¥åæ–œæ  (`\`) ç»“æŸä¸”åè·Ÿæ¢è¡Œç¬¦çš„æ‰€æœ‰è¡Œå°†ä¸æºæ–‡ä»¶ä¸­ä»ç‰©ç†è¡Œå½¢æˆé€»è¾‘è¡Œçš„ä¸‹ä¸€è¡Œè”æ¥ã€‚
3. ä»¤ç‰ŒåŒ–ï¼šæºæ–‡ä»¶åˆ†ä¸ºé¢„å¤„ç†æ ‡è®°å’Œç©ºç™½å­—ç¬¦ã€‚ æºæ–‡ä»¶ä¸­çš„æ³¨é‡Šå°†é€ä¸€æ›¿æ¢ä¸ºç©ºç™½å­—ç¬¦ã€‚ æ¢è¡Œç¬¦å°†ä¿ç•™ã€‚
4. é¢„å¤„ç†ï¼šæ‰§è¡Œé¢„å¤„ç†æŒ‡ä»¤ï¼Œæ‰©å±•å®è°ƒç”¨ï¼Œå¹¶æ‰§è¡Œ `_Pragma` è¡¨è¾¾å¼ã€‚`#include` è¯­å¥æŒ‰ç¬¬ 1 ~ 4 é˜¶æ®µé€’å½’å¤„ç†ã€‚ç„¶ååˆ é™¤æ‰€æœ‰é¢„å¤„ç†æŒ‡ä»¤ã€‚
5. å­—ç¬¦é›†æ˜ å°„ï¼šæ‰€æœ‰æºå­—ç¬¦é›†æˆå‘˜å’Œè½¬ä¹‰åºåˆ—å°†è½¬æ¢ä¸ºæ‰§è¡Œå­—ç¬¦é›†ä¸­çš„ç­‰æ•ˆé¡¹ã€‚
6. å­—ç¬¦ä¸²ä¸²è”ï¼šä¸²è”ç›¸é‚»çš„å­—ç¬¦ä¸²æ–‡å­—ä»¤ç‰Œã€‚
7. ç¿»è¯‘ï¼šå°†ä»è¯­æ³•å’Œè¯­ä¹‰ä¸Šåˆ†ææ‰€æœ‰ä»¤ç‰Œï¼›å¹¶å°†å®ƒä»¬è½¬æ¢ä¸ºå¯¹è±¡ä»£ç ã€‚
8. å®ä¾‹åŒ–å•å…ƒï¼šæ£€æŸ¥æ¯ä¸ªç¿»è¯‘çš„ç¿»è¯‘å•å…ƒï¼Œä»¥ç”Ÿæˆæ‰€éœ€å®ä¾‹åŒ–çš„åˆ—è¡¨ã€‚æ‰¾åˆ°æ‰€éœ€æ¨¡æ¿çš„å®šä¹‰ã€‚
9. é“¾æ¥ï¼šè§£ææ‰€æœ‰å¤–éƒ¨å¼•ç”¨ä»¥åˆ›å»ºå¯æ‰§è¡Œç¨‹åºæˆ–åŠ¨æ€é“¾æ¥åº“ã€‚

>---
#### ç¨‹åºå¯åŠ¨

ç¨‹åºå¯åŠ¨éœ€è¦å…¥å£å‡½æ•° `main`ï¼ŒåŠ¨æ€é“¾æ¥åº“å’Œé™æ€åº“æ²¡æœ‰ `main` å‡½æ•°ã€‚ç¨‹åºè¿›å…¥ `main` å‡½æ•°ä¹‹å‰ï¼Œæ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ `static` ç±»æˆå‘˜é›¶åˆå§‹åŒ–ã€‚

```c++
int main(); // æˆ–
int main(int argc, char *argv[]);
```

`argc` å’Œ `argv` çš„ç±»å‹ç”±è¯­è¨€å®šä¹‰ã€‚`argc` åŒ…å« `argv` å‚æ•°çš„è®¡æ•°ï¼Œ`argv` è‡³å°‘åŒ…å«ç¨‹åºåç§°çš„ `argv[0]`ã€‚`argv[1]` æ˜¯ç¬¬ä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•°ã€‚ å‘½ä»¤è¡Œçš„æœ€åä¸€ä¸ªå‚æ•°æ˜¯ `argv[argc - 1]`ï¼Œå¹¶ä¸” `argv[argc]` å§‹ç»ˆä¸º `NULL`ã€‚

```c++
#include <iostream>

using namespace std;
int main( int argc,      // Number of strings in array argv
          char *argv[])   // Array of command-line argument strings
{
    int count;
    // Display each command-line argument.
    cout << "\nCommand-line arguments:\n";
    for( count = 0; count < argc; count++ )
         cout << "  argv[" << count << "]   "
                << argv[count] << "\n";
}
```


>---
#### ç¨‹åºç»ˆæ­¢

åœ¨ C++ ä¸­ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼é€€å‡ºç¨‹åºï¼š

- è°ƒç”¨ `exit` å‡½æ•°ï¼Œç»ˆæ­¢ç¨‹åºå¹¶æ‰§è¡Œæ¸…ç†ï¼ˆå¦‚è°ƒç”¨å…¨å±€å¯¹è±¡ææ„å‡½æ•°ï¼‰ã€‚
- è°ƒç”¨ `abort` å‡½æ•°ã€‚ç«‹å³ç»ˆæ­¢ç¨‹åºï¼Œè·³è¿‡ `atexit` æœºåˆ¶ã€‚
- ä» `main` æ‰§è¡Œ `return` è¯­å¥ã€‚

```c++
#include <cstdlib>

int main() {
    if (cond1){
        exit(EXIT_SUCCESS);  // or EXIT_FAILURE 
    }else if (cond2) {
        abort();
    }else 
        return 0;
}
```

`atexit` ç”¨äºåœ¨ç¨‹åºç»ˆæ­¢ä¹‹å‰æ‰§è¡Œçš„æ“ä½œï¼Œåœ¨æ­¤ä¹‹å‰ä¸ä¼šé”€æ¯ä»»ä½•åˆå§‹åŒ–çš„å…¨å±€é™æ€å¯¹è±¡ã€‚

ä½¿ç”¨ `return` è¯­å¥å¯ä»¥ä» `main` æŒ‡å®šä¸€ä¸ªè¿”å›å€¼ï¼Œä»»ä½•è‡ªåŠ¨å˜é‡éƒ½å°†è¢«é”€æ¯ã€‚ ç„¶åï¼Œ`main` ä»¥è¿”å›å€¼ä½œä¸ºå‚æ•°è°ƒç”¨ `exit`ã€‚ç›´æ¥è°ƒç”¨ `exit` ä¸ä¼šé”€æ¯è‡ªåŠ¨å˜é‡ã€‚

> çº¿ç¨‹å’Œé™æ€å¯¹è±¡çš„é”€æ¯

ç›´æ¥è°ƒç”¨ `exit` æ—¶ï¼ˆæˆ–åœ¨ `main` çš„ `return` è¯­å¥ä¹‹åè°ƒç”¨å®ƒæ—¶ï¼‰ï¼Œå°†é”€æ¯ä¸å½“å‰çº¿ç¨‹å…³è”çš„çº¿ç¨‹å¯¹è±¡ã€‚ç„¶åæŒ‰ä¸åˆå§‹åŒ–ç›¸åçš„é¡ºåºé”€æ¯é™æ€å¯¹è±¡ï¼ˆåœ¨è°ƒç”¨æŒ‡å®šç»™ `atexit` çš„å‡½æ•°ï¼ˆå¦‚æœæœ‰ï¼‰ä¹‹åï¼‰ã€‚ 

```c++
#include <cstdio>
class ShowData {
public:
	ShowData(const char* szDev) {
		errno_t err;
		err = fopen_s(&OutputDev, szDev, "w");
	}

	~ShowData() { fclose(OutputDev); }
	void Disp(const char* szData) {
		fputs(szData, OutputDev);
	}
private:
	FILE* OutputDev;
};
//  Define a static object of type ShowData. The output device
//   selected is "CON" -- the standard output device.
ShowData sd1 = "CON";
ShowData sd2 = "CON";

int main() {
	sd1.Disp("hello sd1\n");
	sd2.Disp("hello sd2\n");  // ç›¸åé¡ºåºé”€æ¯å¹¶è°ƒç”¨ ~ShowData()
}
// hello sd2  
// hello sd1
```

>---
#### ç±»å‹ç³»ç»Ÿ

æ ‡é‡ç±»å‹ï¼šåŒ…å«å®šä¹‰èŒƒå›´çš„å•ä¸ªå€¼çš„ç±»å‹ã€‚æ ‡é‡åŒ…æ‹¬ç®—æœ¯ç±»å‹ï¼ˆæ•´å‹æˆ–æµ®ç‚¹å€¼ï¼‰ã€æšä¸¾ç±»å‹æˆå‘˜ã€æŒ‡é’ˆç±»å‹ã€æŒ‡é’ˆåˆ°æˆå‘˜ç±»å‹ä»¥åŠ std::nullptr_tã€‚åŸºæœ¬ç±»å‹é€šå¸¸æ˜¯æ ‡é‡ç±»å‹ã€‚

å¤åˆç±»å‹ï¼šå¤åˆç±»å‹åŒ…æ‹¬æ•°ç»„ç±»å‹ã€å‡½æ•°ç±»å‹ã€ç±»ï¼ˆæˆ–ç»“æ„ï¼‰ç±»å‹ã€è”åˆç±»å‹ã€æšä¸¾ã€å¼•ç”¨å’ŒæŒ‡å‘éé™æ€ç±»æˆå‘˜çš„æŒ‡é’ˆã€‚

å˜é‡ï¼šæ•°æ®é‡çš„ç¬¦å·åç§°ã€‚è¯¥åç§°å¯ç”¨äºè®¿é—®å®ƒåœ¨æ•´ä¸ªå®šä¹‰ä»£ç èŒƒå›´å†…å¼•ç”¨çš„æ•°æ®ã€‚å˜é‡é€šå¸¸æŒ‡æ ‡é‡å®ä¾‹ï¼Œå…¶ä»–ç±»çš„å®ä¾‹ä¸ºå¯¹è±¡ã€‚

å¯¹è±¡ï¼šè¡¨ç¤ºç±»æˆ–ç»“æ„çš„å®ä¾‹ã€‚åœ¨ä¸€èˆ¬æ„ä¹‰ä¸ŠåŒ…æ‹¬æ‰€æœ‰ç±»å‹ã€‚

POD ç±»å‹ï¼ˆçº¯æ—§æ•°æ®ï¼‰ï¼šC++ ä¸­æ­¤ç±»éæ­£å¼æ•°æ®ç±»å‹ç±»åˆ«æ˜¯æŒ‡ä½œä¸ºæ ‡é‡çš„ç±»å‹æˆ– POD ç±»ã€‚POD ç±»æ²¡æœ‰é POD çš„é™æ€æ•°æ®æˆå‘˜ï¼Œæ²¡æœ‰ç”¨æˆ·å®šä¹‰æ„é€ å‡½æ•°ã€ç”¨æˆ·å®šä¹‰ææ„å‡½æ•°æˆ–ç”¨æˆ·å®šä¹‰èµ‹å€¼è¿ç®—ç¬¦ã€‚POD ç±»æ— è™šå‡½æ•°ã€åŸºç±»ã€ç§æœ‰æˆ–å—ä¿æŠ¤çš„éé™æ€æ•°æ®æˆå‘˜ã€‚é€šå¸¸ç”¨äºå¤–éƒ¨æ•°æ®äº¤æ¢ï¼Œä¾‹å¦‚ä¸ç”¨ C è¯­è¨€ç¼–å†™çš„æ¨¡å—ï¼ˆä»…å…·æœ‰ POD ç±»å‹ï¼‰è¿›è¡Œæ•°æ®äº¤æ¢ã€‚

C++ æ˜¯å¼ºç±»å‹çš„é™æ€ç±»å‹è¯­è¨€ï¼Œæ¯ä¸ªå¯¹è±¡éƒ½æœ‰ä¸€ä¸ªç±»å‹ã€‚C++ ä¸­ä¸å­˜åœ¨æ´¾ç”Ÿæ‰€æœ‰å…¶ä»–ç±»å‹çš„é€šç”¨åŸºç±»å‹ã€‚C++ çš„å†…ç½®ç±»å‹åŒ…æ‹¬æ•°å€¼ç±»å‹ï¼ˆ`int`ã€`double`ã€`long`ã€`bool` ä»¥åŠåˆ†åˆ«é’ˆå¯¹ ASCII å’Œ UNICODE å­—ç¬¦çš„ `char` å’Œ `wchar_t` ç±»å‹ç­‰ï¼‰ã€‚C++ æ²¡æœ‰å†…ç½®å­—ç¬¦ä¸²ç±»å‹ï¼Œå®ƒæ˜¯ C æ ·å¼å­—ç¬¦ä¸²ã€‚


ä»»ä½•å†…ç½®æˆ–ç”¨æˆ·å®šä¹‰ç±»å‹éƒ½å¯ç”± `const` é™å®šã€‚ æˆå‘˜å‡½æ•°å¯å—åˆ° `const` é™å®šï¼Œä¹Ÿå¯ä»¥é‡è½½ `const`ã€‚`const` ç±»å‹çš„å€¼åˆå§‹åŒ–åæ— æ³•ä¿®æ”¹ã€‚ç”¨æˆ·å®šä¹‰ç±»å‹åŒ…å« `class`ã€`struct`ã€`union`ã€`enum`ã€‚

åœ¨ C++ ä¸­ï¼ŒåŸå§‹æŒ‡é’ˆå˜é‡å£°æ˜åªåˆ†é…è¶³å¤Ÿçš„å†…å­˜æ¥å­˜å‚¨åœ°å€ï¼Œä¸åŒ…å«å­˜å‚¨æ•°æ®å€¼æ‰€éœ€çš„å†…å­˜ï¼›ç”¨æˆ·å®šä¹‰ç±»å‹å¯ä»¥é€šè¿‡ `new` è¡¨è¾¾å¼åœ¨å †ä¸­åŠ¨æ€åˆ†é…å†…å­˜ï¼Œå¹¶åœ¨å¿…è¦æ—¶ç”±ç›¸åº”çš„ `delete` åˆ é™¤ï¼ˆCï¼š`malloc` > `free`ï¼‰ã€‚

>---
#### èŒƒå›´, é“¾æ¥å’Œå­˜å‚¨æœŸ

ç¨‹åºä¸­çš„å£°æ˜å¯ä»¥å‡ºç°åœ¨å¾ˆå¤šèŒƒå›´ï¼ˆ*scope*ï¼Œä½œç”¨åŸŸï¼‰ä¸­ã€‚å…¨å±€èŒƒå›´åŒ…å«æ•´ä¸ªç¨‹åºã€‚åç§°å¯è§çš„ä¸Šä¸‹æ–‡ç§°ä¸ºå…¶ç›®æ ‡èŒƒå›´ã€‚æœ‰å…­ç§èŒƒå›´ï¼š

- å…¨å±€èŒƒå›´ï¼šå…¨å±€åç§°æ˜¯åœ¨ä»»ä½•ç±»ã€å‡½æ•°æˆ–å‘½åç©ºé—´ä¹‹å¤–å£°æ˜çš„åç§°ã€‚å…¨å±€åç§°çš„èŒƒå›´ä»å£°æ˜ç‚¹æ‰©å±•åˆ°å£°æ˜æ–‡ä»¶æœ«å°¾ã€‚

+ å‘½åç©ºé—´èŒƒå›´ï¼šåœ¨å‘½åç©ºé—´ä¸­å£°æ˜çš„åç§°ï¼ˆåœ¨ä»»ä½•ç±»ã€æšä¸¾å®šä¹‰ã€æˆ–å‡½æ•°å—ä¹‹å¤–ï¼‰ä»å…¶å£°æ˜ç‚¹åˆ°å‘½åç©ºé—´æœ«å°¾å¯è§ã€‚å‘½åç©ºé—´å¯ä»¥åœ¨è·¨ä¸åŒæ–‡ä»¶çš„å¤šä¸ªå—ä¸­å®šä¹‰ã€‚

- å±€éƒ¨èŒƒå›´ï¼šåœ¨å‡½æ•°æˆ– lambda ä¸­å£°æ˜çš„åç§°ï¼ˆåŒ…æ‹¬å‚æ•°åç§°ï¼‰å…·æœ‰å±€éƒ¨èŒƒå›´ã€‚å±€éƒ¨å˜é‡ä»…ä»å£°æ˜ç‚¹åˆ°å‡½æ•°æˆ– lambda æ­£æ–‡çš„æœ«å°¾å¯è§ã€‚å±€éƒ¨èŒƒå›´æ˜¯ä¸€ç§å—èŒƒå›´ã€‚

+ ç±»èŒƒå›´ï¼šç±»æˆå‘˜çš„åç§°å…·æœ‰ç±»èŒƒå›´ï¼Œè¯¥èŒƒå›´åœ¨æ•´ä¸ªç±»å®šä¹‰ä¸­æ‰©å±•ï¼Œä¸å£°æ˜ç‚¹æ— å…³ã€‚ç±»æˆå‘˜å¯è®¿é—®æ€§ç”± `public`ã€`private` å’Œ `protected` å…³é”®å­—è¿›ä¸€æ­¥æ§åˆ¶ã€‚

- è¯­å¥èŒƒå›´ï¼šåœ¨ `for`ã€`if`ã€`while` æˆ– `switch` ã€`case` è¯­å¥ä¸­å£°æ˜çš„åç§°åœ¨è¯­å¥å—ç»“æŸä¹‹å‰å¯è§ã€‚

+ æ ‡ç­¾èŒƒå›´ï¼šæ ‡ç­¾å…·æœ‰å‡½æ•°èŒƒå›´ï¼Œè¿™æ„å‘³ç€å®ƒåœ¨æ•´ä¸ªå‡½æ•°æ­£æ–‡ä¸­ç”šè‡³åœ¨å£°æ˜ç‚¹ä¹‹å‰éƒ½æ˜¯å¯è§çš„ã€‚

ä¸€ä¸ª *symbol*ï¼ˆä¾‹å¦‚å˜é‡æˆ–å‡½æ•°åç§°ï¼‰å¯ä»¥åœ¨å…¶èŒƒå›´å†…è¿›è¡Œä»»æ„æ¬¡æ•°çš„å£°æ˜ã€‚ä½†ä¸€ä¸ªç¬¦å·åªèƒ½è¢«å®šä¹‰ä¸€æ¬¡ï¼ˆå•ä¸€å®šä¹‰åŸåˆ™ï¼ŒODRï¼‰ã€‚å£°æ˜åœ¨ç¨‹åºä¸­ï¼ˆé‡æ–°ï¼‰å¼•å…¥ä¸€ä¸ªåç§°å’Œè¶³å¤Ÿçš„ç±»å‹ä¿¡æ¯ï¼Œå®šä¹‰å¼•å…¥ä¸€ä¸ªåç§°å¹¶åˆ›å»ºå®ƒæ‰€éœ€çš„å…¨éƒ¨ä¿¡æ¯ã€‚åç§°è¡¨ç¤ºå˜é‡ï¼Œå®šä¹‰ä¼šæ˜¾å¼åˆ›å»ºå­˜å‚¨å¹¶è¿›è¡Œåˆå§‹åŒ–ã€‚å‡½æ•°å®šä¹‰ç”±ç­¾åå’Œå‡½æ•°ä½“ç»„æˆã€‚ç±»å®šä¹‰ç”±ç±»åå’Œåˆ—å‡ºçš„æ‰€æœ‰ç±»æˆå‘˜å’Œæˆå‘˜å‡½æ•°ç»„æˆã€‚ 

ä¸€ä¸ªç¨‹åºåŒ…æ‹¬ä¸€ä¸ªæˆ–å¤šä¸ªç¿»è¯‘å•å…ƒã€‚ä¸€ä¸ªç¿»è¯‘å•å…ƒç”±ä¸€ä¸ªå®ç°æ–‡ä»¶åŠå…¶ç›´æ¥æˆ–é—´æ¥åŒ…å«çš„æ‰€æœ‰æ ‡å¤´ç»„æˆã€‚ å®ç°æ–‡ä»¶é€šå¸¸å…·æœ‰ `.cpp` æˆ– `.cxx`ã€‚å¤´æ–‡ä»¶é€šå¸¸å…·æœ‰ `.h` æˆ– `.hpp`ã€‚ æ¯ä¸ªç¿»è¯‘å•å…ƒç”±ç¼–è¯‘å™¨ç‹¬ç«‹ç¼–è¯‘ã€‚ç¼–è¯‘å®Œæˆåï¼Œé“¾æ¥å™¨ä¼šå°†ç¼–è¯‘åçš„ç¿»è¯‘å•å…ƒåˆå¹¶åˆ°å•ä¸ªç¨‹åºä¸­ã€‚ODR è§„åˆ™çš„å†²çªé€šå¸¸æ˜¾ç¤ºä¸ºé“¾æ¥å™¨é”™è¯¯ã€‚åœ¨å¤šä¸ªç¿»è¯‘å•å…ƒä¸­å®šä¹‰åŒä¸€åç§°æ—¶ï¼Œå°†å‘ç”Ÿé“¾æ¥å™¨é”™è¯¯ã€‚

é€šå¸¸ï¼Œä½¿å˜é‡åœ¨å¤šä¸ªæ–‡ä»¶ä¸­å¯è§çš„æœ€ä½³æ–¹å¼æ˜¯åœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜å®ƒã€‚ç„¶åï¼Œåœ¨éœ€è¦å£°æ˜çš„æ¯ä¸ª `.cpp` æ–‡ä»¶ä¸­æ·»åŠ ä¸€ä¸ª `#include` æŒ‡ä»¤ã€‚é€šè¿‡åœ¨æ ‡å¤´å†…å®¹å‘¨å›´æ·»åŠ  `include` é˜²å«ï¼Œå¯ä»¥ç¡®ä¿æ ‡å¤´å£°æ˜çš„åç§°å¯¹æ¯ä¸ªç¿»è¯‘å•å…ƒåªå£°æ˜ä¸€æ¬¡ã€‚ä»…åœ¨ä¸€ä¸ªå®ç°æ–‡ä»¶ä¸­å®šä¹‰åç§°ã€‚

```c++
#ifndef HEADER_H
#  define HEADER_H
   // ... code in header.h
#endif
```

åœ¨ C++20 ä¸­ï¼Œæ¨¡å—ä½œä¸ºå¤´æ–‡ä»¶çš„æ”¹è¿›æ›¿ä»£æ–¹æ³•å¼•å…¥ã€‚

```c++
import std.compat;
int main()
{
    printf("Hello World");
}
```

é“¾æ¥çš„ç±»å‹æŒ‡å®šå¯¹è±¡çš„åç§°æ˜¯ä»…åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­å¯è§ï¼Œè¿˜æ˜¯åœ¨æ‰€æœ‰æ–‡ä»¶ä¸­å¯è§ã€‚*Free* å‡½æ•°æ˜¯åœ¨å…¨å±€èŒƒå›´æˆ–å‘½åç©ºé—´èŒƒå›´å†…å®šä¹‰çš„å‡½æ•°ã€‚éå¸¸é‡å…¨å±€å˜é‡å’Œ *Free* å‡½æ•°é€šå¸¸å…·æœ‰å¤–éƒ¨é“¾æ¥ï¼›å®ƒä»¬åœ¨ç¨‹åºä¸­çš„ä»»ä½•ç¿»è¯‘å•å…ƒå†…å¯è§ã€‚å¯ä»¥å°†ä¸€ä¸ªå…¨å±€åç§°å£°æ˜ä¸º `static`ï¼›å£°æ˜ä¸º `const`, `constexpr`, `typedef`, å…¨å±€èŒƒå›´çš„ `static` å¯¹è±¡å…·æœ‰å†…éƒ¨é“¾æ¥ï¼›`extern` æ˜¾å¼å£°æ˜å¤–éƒ¨é“¾æ¥ã€‚

```c++
constexpr int czero = 0;
const struct S { int v; };
typedef struct S S;
static S Max{ INT_MAX };

extern const S Zero { 0 };  // å¤–éƒ¨é“¾æ¥
```

>---
#### åç§°æŸ¥æ‰¾

åç§°æŸ¥æ‰¾è§„åˆ™ç»Ÿä¸€åœ°åº”ç”¨äºæ‰€æœ‰åç§°ï¼ˆåŒ…æ‹¬ *typedef-names*ï¼Œ*namespace-names* å’Œ *class-names*ï¼‰ã€‚åç§°æŸ¥æ‰¾å°†åç§°çš„ä½¿ç”¨ä¸è¯¥åç§°çš„ä¸€ç»„å£°æ˜ç›¸å…³è”ã€‚å¦‚æœé€šè¿‡åç§°æŸ¥æ‰¾æ‰¾åˆ°çš„å£°æ˜éƒ½è¡¨ç¤ºå‡½æ•°æˆ–å‡½æ•°æ¨¡æ¿ï¼Œåˆ™è¿™äº›å£°æ˜è¢«æ„æˆå‡½æ•°çš„é‡è½½é›†ã€‚

å¦åˆ™ï¼Œå¦‚æœé€šè¿‡åç§°æŸ¥æ‰¾æ‰¾åˆ°çš„å£°æ˜ä¸è¡¨ç¤ºç›¸åŒçš„å®ä½“ï¼Œåˆ™å®ƒä»¬å…·æœ‰äºŒä¹‰æ€§ã€‚é‡è½½å†³ç­–å‘ç”Ÿåœ¨åç§°æŸ¥æ‰¾æˆåŠŸåã€‚åªæœ‰åœ¨åç§°æŸ¥æ‰¾å’Œå‡½æ•°é‡è½½å†³ç­–æˆåŠŸåï¼Œæ‰ä¼šè€ƒè™‘å¯è®¿é—®æ€§è§„åˆ™ã€‚åªæœ‰åœ¨åç§°æŸ¥æ‰¾ã€å‡½æ•°é‡è½½å†³ç­–å’Œè®¿é—®æ£€æŸ¥æˆåŠŸä¹‹åï¼Œæ‰èƒ½åœ¨è¿›ä¸€æ­¥çš„å¤„ç†ä¸­ä½¿ç”¨å£°æ˜å¼•å…¥çš„è¯­ä¹‰å±æ€§ã€‚

å¦‚æœä¸€ä¸ªå¯¹è±¡æœ‰å¤šä¸ª `T` ç±»å‹çš„åŸºç±»å­å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥æ˜ç¡®åœ°æ‰¾åˆ°åŸºç±» `T` ä¸­å®šä¹‰çš„é™æ€æˆå‘˜ã€åµŒå¥—ç±»å‹æˆ–æšä¸¾æ•°ã€‚ä¸¤ä¸ªåŸºç±»å­å¯¹è±¡å…±äº«å…¶å…¬å…±è™šåŸºç±»çš„éé™æ€æˆå‘˜å­å¯¹è±¡ã€‚

```c++
struct V {
    int v;
};
struct A {
    int a;
    static int s;
    enum { e };
};
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };
void f(D* pd) {
    pd->v++;       // OK, only one v (virtual)
    pd->s++;       // OK, only one s (static)
    int i = pd->e; // OK, only one e (enumerator)
    pd->a++;       // error: ambiguous: two as in D
   	pd->B::a++;	   // OK: B::a
	pd->C::a++;	   // OK: C::a
}
```

ä»æŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡çš„æŒ‡é’ˆæˆ–æŒ‡å®šæ´¾ç”Ÿç±»å¯¹è±¡çš„è¡¨è¾¾å¼åˆ°æŒ‡å‘å…¶åŸºç±»ä¹‹ä¸€çš„æŒ‡é’ˆæˆ–å¼•ç”¨çš„æ˜¾å¼æˆ–éšå¼è½¬æ¢ï¼Œåº”æ˜ç¡®å¼•ç”¨è¡¨ç¤ºåŸºç±»çš„å”¯ä¸€å¯¹è±¡ã€‚

```c++
struct V { };
struct A { };
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };
void g() {
    D d;
    B* pb = &d;
    A* pa = &d; // error: ambiguous: Câ€™s A or Bâ€™s A?
    V* pv = &d; // OK, only one V subobject
}
```


>---
#### Lvalues å’Œ Rvalues

æ¯ä¸ª C++ è¡¨è¾¾å¼éƒ½æœ‰ä¸€ä¸ªç±»å‹ï¼Œå±äºå€¼ç±»åˆ«ã€‚å€¼ç±»åˆ«æ˜¯ç¼–è¯‘å™¨åœ¨è¡¨è¾¾å¼è®¡ç®—æœŸé—´åˆ›å»ºã€å¤åˆ¶å’Œç§»åŠ¨ä¸´æ—¶å¯¹è±¡æ—¶å¿…é¡»éµå¾ªçš„è§„åˆ™çš„åŸºç¡€ã€‚
-*glvalue* æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒçš„è®¡ç®—å¯ä»¥ç¡®å®šå¯¹è±¡ã€ä½åŸŸæˆ–å‡½æ•°çš„æ ‡è¯†ã€‚
- *prvalue* æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒçš„è®¡ç®—å¯ä»¥åˆå§‹åŒ–å¯¹è±¡æˆ–ä½åŸŸï¼Œæˆ–è®¡ç®—è¿ç®—ç¬¦çš„æ“ä½œæ•°å€¼ï¼Œç”±å®ƒå‡ºç°çš„ä¸Šä¸‹æ–‡æ‰€æŒ‡å®šçš„ã€‚
- *xvalue* æ˜¯ä¸€ä¸ª *glvalue*ï¼Œè¡¨ç¤ºä¸€ä¸ªå¯¹è±¡æˆ–ä½åŸŸï¼Œè¯¥å¯¹è±¡æˆ–ä½åŸŸçš„èµ„æºå¯é‡å¤ä½¿ç”¨ï¼ˆé€šå¸¸æ˜¯å› ä¸ºå®ƒæ¥è¿‘å…¶ç”Ÿå­˜æœŸçš„æœ«å°¾ï¼‰ã€‚æŸäº›æ¶‰åŠ *rvalue* å¼•ç”¨çš„ç±»å‹çš„è¡¨è¾¾å¼ä¼šç”Ÿæˆ *xvalue*ï¼Œä¾‹å¦‚å¯¹è¿”å›ç±»å‹ä¸º *rvalue* å¼•ç”¨æˆ–å¼ºåˆ¶è½¬æ¢ä¸º *rvalue* å¼•ç”¨ç±»å‹çš„å‡½æ•°çš„è°ƒç”¨ã€‚
- *lvalue* ä¸ºé *xvalue* çš„ *glvalue*ã€‚
- *rvalue* æ˜¯ä¸€ä¸ª *prvalue* æˆ– *xvalue*ã€‚

> *å„ç±»åˆ«ä¹‹é—´çš„å…³ç³»*
<pre>
                          lvalue
                glvalue â€”|
   expression â€”|         xvalue
                rvalue  â€”|
                          prvalue  
</pre>

*lvalue* å…·æœ‰ç¨‹åºå¯è®¿é—®çš„åœ°å€ã€‚*lvalue* è¡¨è¾¾å¼åŒ…æ‹¬å˜é‡åç§°ï¼Œä¾‹å¦‚ `const` å˜é‡ã€æ•°ç»„å…ƒç´ ã€è¿”å› *lvalue* å¼•ç”¨çš„å‡½æ•°è°ƒç”¨ã€ä½åŸŸã€è”åˆå’Œç±»æˆå‘˜ã€‚

*prvalue* è¡¨è¾¾å¼æ²¡æœ‰å¯ä¾›ç¨‹åºè®¿é—®çš„åœ°å€ã€‚ä¾‹å¦‚ï¼Œ*prvalue* è¡¨è¾¾å¼åŒ…æ‹¬æ–‡æœ¬ã€å¯è¿”å›éå¼•ç”¨ç±»å‹çš„å‡½æ•°è°ƒç”¨ï¼Œä»¥åŠåœ¨è¡¨è¾¾å¼è®¡ç®—æœŸé—´åˆ›å»ºä¸”ç”±ç¼–è¯‘å™¨è®¿é—®çš„ä¸´æ—¶å¯¹è±¡ã€‚

*xvalue* è¡¨è¾¾å¼æœ‰ä¸€ä¸ªåœ°å€ï¼Œè¯¥åœ°å€ä¸å†å¯ä¾›ç¨‹åºè®¿é—®ï¼Œä½†å¯ç”¨äºåˆå§‹åŒ– *rvalue* å¼•ç”¨ï¼Œä»¥æä¾›å¯¹è¡¨è¾¾å¼çš„è®¿é—®ã€‚ä¾‹å¦‚ï¼Œå®ƒåŒ…æ‹¬å¯è¿”å› *rvalue* å¼•ç”¨çš„å‡½æ•°è°ƒç”¨ï¼Œä»¥åŠæ•°ç»„ä¸‹æ ‡ã€æˆå‘˜å’ŒæŒ‡å‘å…¶ä¸­æ•°ç»„æˆ–å¯¹è±¡æ˜¯ *rvalue* å¼•ç”¨çš„æˆå‘˜è¡¨è¾¾å¼çš„æŒ‡é’ˆã€‚

>---
#### å¯¹é½æ–¹å¼

C++ çš„ä½çº§åŠŸèƒ½ä¹‹ä¸€æ˜¯èƒ½å¤ŸæŒ‡å®šå†…å­˜ä¸­å¯¹è±¡çš„ç²¾ç¡®å¯¹é½æ–¹å¼ï¼Œä»¥æœ€å¤§é™åº¦åˆ©ç”¨ç‰¹å®šçš„ç¡¬ä»¶ä½“ç³»ç»“æ„ã€‚é»˜è®¤æƒ…å†µä¸‹ã€ç¼–è¯‘å™¨ä¼šæ ¹æ®ç±»æˆ–ç»“æ„æˆå‘˜çš„å€¼çš„å¤§å°è¿›è¡Œå¯¹é½ï¼š`bool` å’Œ `char` åœ¨ 1 å­—èŠ‚è¾¹ç•Œä¸Šå¯¹é½ï¼Œ`short` åœ¨ 2 å­—èŠ‚è¾¹ç•Œä¸Šå¯¹é½ï¼Œ`int`ã€`long` å’Œ `float` åœ¨ 4 å­—èŠ‚è¾¹ç•Œä¸Šå¯¹é½ï¼Œ`long long`ã€`double` å’Œ `long double` åœ¨ 8 å­—èŠ‚è¾¹ç•Œä¸Šå¯¹é½ã€‚

å¯ä»¥ä½¿ç”¨ `alignof` å’Œ `alignas` æ¥è·å–æˆ–æŒ‡å®šå¯¹è±¡çš„å¯¹é½æ–¹å¼ï¼›å¯¹é½æ–¹å¼æ˜¯å†…å­˜åœ°å€çš„ä¸€ä¸ªå±æ€§ï¼Œè¡¨ç¤ºä¸ºæ•°å­—åœ°å€å¯¹ 2 çš„å¹‚æ¬¡æ–¹å–æ¨¡ï¼Œä¾‹å¦‚ï¼Œåœ°å€ 0x0001103F å¯¹ 4 å–æ¨¡ä¸º 3ï¼Œè¯¥åœ°å€å¯¹é½åˆ° 4n+3ã€‚

CPU æ‰§è¡Œä½œç”¨äºå†…å­˜ä¸­æ‰€å­˜å‚¨æ•°æ®çš„æŒ‡ä»¤ã€‚æ•°æ®åœ¨å†…å­˜ä¸­ç”¨åœ°å€æ ‡è¯†ã€‚å•ä¸ªåŸºå‡†ä¹Ÿå…·æœ‰å¤§å°ã€‚å¦‚æœä¸€ä¸ªåŸºå‡†çš„åœ°å€å¯¹é½åˆ°å…¶å¤§å°ï¼Œåˆ™ç§°å®ƒä¸ºè‡ªç„¶å¯¹é½ã€‚

ä¸€èˆ¬è€Œè¨€ï¼Œç¼–è¯‘å™¨ä¼šä»¥è‡ªç„¶å¯¹é½ç»“æ„çš„æ¯ä¸€ä¸ªå…ƒç´ çš„æ–¹å¼å¡«å……ç»“æ„ã€‚ä¾‹å¦‚ï¼š

```c++
struct x_
{
   char a;     // 1 byte
   // char _pad0[3];     // padding to put 'b' on 4-byte boundary
   int b;      // 4 bytes
   short c;    // 2 bytes
   char d;     // 1 byte
   // char _pad1[1];    // padding to make sizeof(x_) multiple of 4
} bar[3];
```

>---
#### å¸ƒå±€ä¸ POD

å¸ƒå±€æ˜¯æŒ‡ç±»ã€ç»“æ„æˆ–è”åˆç±»å‹å¯¹è±¡çš„æˆå‘˜åœ¨å†…å­˜ä¸­çš„æ’åˆ—æ–¹å¼ã€‚å¸ƒå±€ä¸€èˆ¬ç”±è¯­è¨€è§„èŒƒæ˜ç¡®å®šä¹‰ã€‚

å¦‚æœå½“ç±»æˆ–ç»“æ„åŒ…å«æŸäº› C++ è¯­è¨€åŠŸèƒ½ï¼ˆå¦‚è™šæ‹ŸåŸºç±»ã€è™šæ‹Ÿå‡½æ•°ã€å…·æœ‰ä¸åŒè®¿é—®æ§åˆ¶çš„æˆå‘˜ï¼‰æ—¶ï¼Œç¼–è¯‘å™¨å¯ä»¥è‡ªç”±é€‰æ‹©å¸ƒå±€ã€‚è¯¥å¸ƒå±€å¯èƒ½ä¼šå› ç¼–è¯‘å™¨çš„ä¼˜åŒ–æœ‰æ‰€ä¸åŒï¼Œå¯¹è±¡ç”šè‡³å¯èƒ½ä¸ä¼šå ç”¨è¿ç»­å†…å­˜åŒºåŸŸã€‚ä¾‹å¦‚ï¼Œå¦‚æœæŸä¸ªç±»å…·æœ‰è™šæ‹Ÿå‡½æ•°ï¼Œåˆ™è¯¥ç±»çš„æ‰€æœ‰å®ä¾‹å¯èƒ½ä¼šå…±äº«å•ä¸ªè™šæ‹Ÿå‡½æ•°è¡¨ã€‚ 

ç”±äºå¸ƒå±€æœªå®šä¹‰ï¼Œå› æ­¤æ— æ³•å°†å…¶ä¼ é€’åˆ°ä½¿ç”¨å…¶ä»–è¯­è¨€ï¼ˆä¾‹å¦‚ Cï¼‰ç¼–å†™çš„ç¨‹åºï¼Œå¹¶ä¸”ç”±äºå®ƒä»¬å¯èƒ½æ˜¯éè¿ç»­çš„ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨å¿«é€Ÿä½çº§å‡½æ•°ï¼ˆä¾‹å¦‚ `memcopy`ï¼‰å¯¹å…¶è¿›è¡Œå¯é å¤åˆ¶ï¼Œæˆ–è€…é€šè¿‡ç½‘ç»œå¯¹å…¶è¿›è¡Œåºåˆ—åŒ–ã€‚

> *Trivial* ç±»å‹

å½“ C++ ä¸­çš„ç±»æˆ–ç»“æ„å…·æœ‰ç¼–è¯‘å™¨æä¾›çš„æˆ–æ˜¾å¼é»˜è®¤è®¾ç½®çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°æ—¶ï¼Œè¯¥ç±»æˆ–ç»“æ„ä¸ºæ™®é€šç±»å‹ã€‚å®ƒå ç”¨è¿ç»­å†…å­˜åŒºåŸŸã€‚

æ™®é€šç±»å‹å…·æœ‰æ™®é€šé»˜è®¤æ„é€ å‡½æ•°ã€æ™®é€šå¤åˆ¶æ„é€ å‡½æ•°ã€æ™®é€šå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦å’Œæ™®é€šææ„å‡½æ•°ã€‚ åœ¨å„ç§æƒ…å†µä¸‹ï¼Œâ€œæ™®é€šâ€ æ„å‘³ç€æ„é€ å‡½æ•° / è¿ç®—ç¬¦ / ææ„å‡½æ•°å¹¶éç”¨æˆ·æä¾›ï¼Œå¹¶ä¸”å±äºå­˜åœ¨ä»¥ä¸‹æƒ…å†µçš„ç±»ï¼š
- æ²¡æœ‰è™šæ‹Ÿå‡½æ•°æˆ–è™šæ‹ŸåŸºç±»ï¼Œ
- æ²¡æœ‰å…·æœ‰ç›¸åº”éæ™®é€šæ„é€ å‡½æ•° / è¿ç®—ç¬¦ / ææ„å‡½æ•°çš„åŸºç±»
- æ²¡æœ‰å…·æœ‰ç›¸åº”éæ™®é€šæ„é€ å‡½æ•° / è¿ç®—ç¬¦ / ææ„å‡½æ•°çš„ç±»ç±»å‹çš„æ•°æ®æˆå‘˜

```c++
struct Trivial
{
   int i;
private:
   int j;
};

struct Trivial2
{
   int i;
   Trivial2(int a, int b) : i(a), j(b) {}
   Trivial2() = default;
private:
   int j;   // Different access control
};
```

> *standard-layout* ç±»å‹

å½“ç±»æˆ–ç»“æ„ä¸åŒ…å«æŸäº› C++ è¯­è¨€åŠŸèƒ½ï¼ˆä¾‹å¦‚æ— æ³•åœ¨ C è¯­è¨€ä¸­æ‰¾åˆ°çš„è™šæ‹Ÿå‡½æ•°ï¼‰ï¼Œå¹¶ä¸”æ‰€æœ‰æˆå‘˜éƒ½å…·æœ‰ç›¸åŒçš„è®¿é—®æ§åˆ¶æ—¶ï¼Œè¯¥ç±»æˆ–ç»“æ„ä¸ºæ ‡å‡†å¸ƒå±€ç±»å‹ã€‚å¯ä»¥åœ¨å†…å­˜ä¸­å¯¹å…¶è¿›è¡Œå¤åˆ¶ï¼Œå¯ä»¥ç”± C ç¨‹åºä½¿ç”¨ã€‚æ ‡å‡†å¸ƒå±€ç±»å‹å¯ä»¥å…·æœ‰ç”¨æˆ·å®šä¹‰çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°ã€‚æ ‡å‡†å¸ƒå±€ç±»å‹è¿˜å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š
- æ²¡æœ‰è™šæ‹Ÿå‡½æ•°æˆ–è™šæ‹ŸåŸºç±»
- æ‰€æœ‰éé™æ€æ•°æ®æˆå‘˜éƒ½å…·æœ‰ç›¸åŒçš„è®¿é—®æ§åˆ¶
- ç±»ç±»å‹çš„æ‰€æœ‰éé™æ€æˆå‘˜å‡ä¸ºæ ‡å‡†å¸ƒå±€
- æ‰€æœ‰åŸºç±»éƒ½ä¸ºæ ‡å‡†å¸ƒå±€
- æ²¡æœ‰ä¸ç¬¬ä¸€ä¸ªéé™æ€æ•°æ®æˆå‘˜ç±»å‹ç›¸åŒçš„åŸºç±»ã€‚
- æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ä¹‹ä¸€ï¼š
  - æœ€åº•å±‚æ´¾ç”Ÿç±»ä¸­æ²¡æœ‰éé™æ€æ•°æ®æˆå‘˜ï¼Œå¹¶ä¸”å…·æœ‰éé™æ€æ•°æ®æˆå‘˜çš„åŸºç±»ä¸è¶…è¿‡ä¸€ä¸ªï¼Œæˆ–è€…
  - ä¸å«éé™æ€æ•°æ®æˆå‘˜çš„åŸºç±»

```c++
struct SL
{
   // All members have same access:
   int i;
   int j;
   SL(int a, int b) : i(a), j(b) {} // User-defined constructor OK
};
```

`Base` æ˜¯æ ‡å‡†å¸ƒå±€ï¼Œ`Derived` ä¸æ˜¯æ ‡å‡†å¸ƒå±€ï¼Œå®ƒï¼ˆæœ€åº•å±‚æ´¾ç”Ÿç±»ï¼‰å’Œ `Base` éƒ½å…·æœ‰éé™æ€æ•°æ®æˆå‘˜ï¼š

```c++
struct Base
{
   int i;
   int j;
};

// std::is_standard_layout<Derived> == false!
struct Derived : public Base
{
   int x;
   int y;
};
```

`Derived` æ˜¯æ ‡å‡†å¸ƒå±€ï¼Œå› ä¸º `Base` æ²¡æœ‰éé™æ€æ•°æ®æˆå‘˜ï¼š

```c++
struct Base
{
   void Foo() {}
};

// std::is_standard_layout<Derived> == true
struct Derived : public Base
{
   int x;
   int y;
};
```

å¦‚æœ `Base` å…·æœ‰æ•°æ®æˆå‘˜ï¼Œå¹¶ä¸” `Derived` ä»…å…·æœ‰æˆå‘˜å‡½æ•°ï¼Œåˆ™ `Derived` ä¹Ÿæ˜¯æ ‡å‡†å¸ƒå±€ã€‚

> POD ç±»å‹

å½“æŸä¸€ç±»æˆ–ç»“æ„åŒæ—¶ä¸ºæ™®é€šå’Œæ ‡å‡†å¸ƒå±€æ—¶ï¼Œè¯¥ç±»æˆ–ç»“æ„ä¸º PODï¼ˆç®€å•æ—§æ•°æ®ï¼‰ç±»å‹ã€‚ å› æ­¤ï¼ŒPOD ç±»å‹çš„å†…å­˜å¸ƒå±€æ˜¯è¿ç»­çš„ï¼Œå¹¶ä¸”æ¯ä¸ªæˆå‘˜çš„åœ°å€éƒ½æ¯”åœ¨å…¶ä¹‹å‰å£°æ˜çš„æˆå‘˜è¦é«˜ï¼Œä»¥ä¾¿å¯ä»¥å¯¹è¿™äº›ç±»å‹æ‰§è¡Œé€å­—èŠ‚å¤åˆ¶å’ŒäºŒè¿›åˆ¶ I/Oã€‚æ ‡é‡ç±»å‹ï¼ˆä¾‹å¦‚ `int`ï¼‰ä¹Ÿæ˜¯ POD ç±»å‹ã€‚

ä½œä¸ºç±»çš„ POD ç±»å‹åªèƒ½å…·æœ‰ä½œä¸ºéé™æ€æ•°æ®æˆå‘˜çš„ POD ç±»å‹ã€‚

> æ™®é€šã€æ ‡å‡†å¸ƒå±€å’Œ POD ç±»å‹ä¹‹é—´çš„åŒºåˆ«

```c++
#include <type_traits>
#include <iostream>

using namespace std;

struct B
{
protected:
   virtual void Foo() {}
};

// Neither trivial nor standard-layout
struct A : B
{
   int a;
   int b;
   void Foo() override {} // Virtual function
};

// Trivial but not standard-layout
struct C
{
   int a;
private:
   int b;   // Different access control
};

// Standard-layout but not trivial
struct D
{
   int a;
   int b;
   D() {} //User-defined constructor
};

struct POD
{
   int a;
   int b;
};

int main()
{
   cout << boolalpha;
   cout << "A is trivial is " << is_trivial<A>() << endl; // false
   cout << "A is standard-layout is " << is_standard_layout<A>() << endl;  // false

   cout << "C is trivial is " << is_trivial<C>() << endl; // true
   cout << "C is standard-layout is " << is_standard_layout<C>() << endl;  // false

   cout << "D is trivial is " << is_trivial<D>() << endl;  // false
   cout << "D is standard-layout is " << is_standard_layout<D>() << endl; // true

   cout << "POD is trivial is " << is_trivial<POD>() << endl; // true
   cout << "POD is standard-layout is " << is_standard_layout<POD>() << endl; // true

   return 0;
}
```

>---
#### æ–‡æœ¬ç±»å‹

æ–‡æœ¬ç±»å‹æ˜¯å¯åœ¨ç¼–è¯‘æ—¶ç¡®å®šå…¶å¸ƒå±€çš„ç±»å‹ã€‚ä»¥ä¸‹å‡ä¸ºæ–‡æœ¬ç±»å‹ï¼š
- `void`ã€æ ‡é‡ç±»å‹ã€å¼•ç”¨ï¼›
- `void`ã€æ ‡é‡ç±»å‹æˆ–å¼•ç”¨çš„æ•°ç»„
- å…·æœ‰æ™®é€šææ„å‡½æ•°ä»¥åŠä¸€ä¸ªæˆ–å¤šä¸ª `constexpr` æ„é€ å‡½æ•°ä¸”æ²¡æœ‰ç§»åŠ¨æˆ–å¤åˆ¶æ„é€ å‡½æ•°çš„ç±»ã€‚æ­¤å¤–ï¼Œå…¶æ‰€æœ‰éé™æ€æ•°æ®æˆå‘˜å’ŒåŸºç±»å¿…é¡»æ˜¯æ–‡æœ¬ç±»å‹ä¸”ä¸å¯å˜ã€‚

>---
#### å€¼ç±»å‹

é»˜è®¤æƒ…å†µä¸‹ï¼ŒC++ ç±»æ˜¯å€¼ç±»å‹ã€‚å¯ä»¥æŒ‡å®šä¸ºå¼•ç”¨ç±»å‹ï¼Œä»¥å¤šæ€è¡Œä¸ºæ”¯æŒé¢å‘å¯¹è±¡çš„ç¼–ç¨‹ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå€¼ç±»å‹å¯ä»¥å¤åˆ¶ï¼Œè¿™æ„å‘³ç€æ€»æ˜¯æœ‰ä¸€ä¸ªå¤åˆ¶æ„é€ å‡½æ•°å’Œä¸€ä¸ªå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ã€‚ 

å¯¹äºå¼•ç”¨ç±»å‹ï¼Œå°†ç±»è®¾ä¸ºä¸å¯å¤åˆ¶ï¼ˆç¦ç”¨å¤åˆ¶æ„é€ å‡½æ•°å’Œå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ï¼‰ï¼Œå¹¶ä½¿ç”¨æ”¯æŒå…¶é¢„æœŸå¤šæ€æ€§çš„è™šæ‹Ÿææ„å‡½æ•°ã€‚ 

```c++
class MyRefType {
private:
    MyRefType & operator=(const MyRefType &);
    MyRefType(const MyRefType &);
public:
    MyRefType () {}
};

int main()
{
    MyRefType Data1, Data2;
    // ...
    Data1 = Data2;
    // error: 'MyRefType::operator =' : cannot access private member declared in class 'MyRefType'
}
```

> *å€¼ç±»å‹å’Œç§»åŠ¨æ•ˆç‡*

ç±»å¿…é¡»é€šè¿‡åœ¨ç±»å®šä¹‰ä¸­å£°æ˜ç§»åŠ¨èµ‹å€¼å’Œç§»åŠ¨æ„é€ å‡½æ•°ï¼Œä»¥æ”¯æŒå¤åˆ¶æ—¶çš„ç§»åŠ¨ä¼˜åŒ–ï¼Œé¿å…å¤åˆ¶åˆ†é…å¼€é”€ã€‚*Move* ä½¿ç”¨ `&&` *rvalue* å¼•ç”¨ï¼Œå®šä¹‰ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼å‡½æ•°ã€‚

 <!-- TODO -->

>---
#### ç±»å‹è½¬æ¢

å½“è¡¨è¾¾å¼åŒ…å«ä¸åŒå†…ç½®ç±»å‹çš„æ“ä½œæ•°ä¸”ä¸å­˜åœ¨æ˜¾å¼å¼ºåˆ¶è½¬æ¢æ—¶ï¼Œç¼–è¯‘å™¨å°†ä½¿ç”¨å†…ç½®çš„ â€œæ ‡å‡†è½¬æ¢â€ æ¥è½¬æ¢å…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°ï¼Œä»è€Œä½¿ç±»å‹ç›¸åŒ¹é…ã€‚

åœ¨æ‰©å¤§è½¬æ¢ä¸­ï¼Œè¾ƒå°çš„å˜é‡ä¸­çš„å€¼å°†èµ‹ç»™è¾ƒå¤§çš„å˜é‡ï¼ŒåŒæ—¶ä¸ä¼šä¸¢å¤±æ•°æ®ã€‚æ‰©å¤§è½¬æ¢å§‹ç»ˆæ˜¯å®‰å…¨çš„ã€‚

æ”¶ç¼©è½¬æ¢å¯èƒ½å­˜åœ¨æ•°æ®ä¸¢å¤±ï¼Œéšå¼æ‰§è¡Œæ”¶ç¼©è½¬æ¢ç¼–è¯‘å™¨å‘å‡ºè­¦å‘Šï¼Œå¯ä»¥æ·»åŠ æ˜¾å¼å¼ºåˆ¶è½¬æ¢ã€‚ä»»ä½•ä»æµ®ç‚¹ç±»å‹åˆ°æ•´å‹çš„è½¬æ¢éƒ½æ˜¯æ”¶ç¼©è½¬æ¢ï¼Œå°æ•°éƒ¨åˆ†å°†ä¼šä¸¢å¼ƒã€‚

```c++
int i = INT_MAX + 1;   // warning:'+':integral constant overflow
wchar_t wch = 'A';     // OK
char c = wch;          
// warning:'initializing':conversion from 'wchar_t' to 'char', possible loss of data

unsigned char c2 = 0xfffe; 
// warning:'initializing':truncation from 'int' to 'unsigned char'

int j = 1.9f; 
// warning:'initializing':conversion from 'float' to 'int', possible loss of data

int k = 7.7; 
// warning:'initializing':conversion from 'double' to 'int', possible loss of data
```

æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´å‹ä¹‹é—´çš„éšå¼è½¬æ¢ï¼Œå…·æœ‰ç›¸åŒçš„ä½æ¨¡å¼å’Œä¸åŒçš„å€¼è§£é‡Šæ–¹å¼ã€‚ç¼–è¯‘å™¨ä¸ä¼šå‘å‡ºæœ‰å…³æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´å‹ä¹‹é—´çš„éšå¼è½¬æ¢çš„è­¦å‘Šã€‚

åˆ©ç”¨å¼ºåˆ¶è½¬æ¢è¿ç®—ï¼Œå¯ä»¥æŒ‡ç¤ºç¼–è¯‘å™¨å°†ä¸€ç§ç±»å‹çš„å€¼è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚ä¾‹å¦‚ä»æŒ‡å‘æ´¾ç”Ÿç±»çš„æŒ‡é’ˆåˆ°æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆçš„å¼ºåˆ¶è½¬æ¢ã€‚è¿˜æœ‰ä¸€ç§ä½¿ç”¨æƒ…å†µæ˜¯å¼ºåˆ¶è½¬æ¢æ”¹å˜å˜é‡çš„å¸¸é‡æ€§ä»¥å°†å…¶ä¼ é€’ç»™éœ€è¦éå¸¸é‡å‚æ•°çš„å‡½æ•°ã€‚

```c++
(int) x;  // old-style cast, old-style syntax
int(x);   // old-style cast, functional syntax

static_cast<T>(v)
dynamic_cast<Derived>(base)
const_cast<constT>(noconstv)
reinterpret_cast<T>(v)
```


---
### å†…ç½®ç±»å‹

å†…ç½®ç±»å‹ï¼ˆä¹Ÿç§°åŸºæœ¬ç±»å‹ï¼‰ç”± C++ è¯­è¨€æ ‡å‡†æŒ‡å®šï¼Œæœªåœ¨ä»»ä½•å¤´æ–‡ä»¶ä¸­å®šä¹‰ã€‚åˆ†ä¸ºä¸‰ä¸ªä¸»è¦ç±»åˆ«ï¼šæ•´å‹ã€æµ®ç‚¹å’Œ `void`ã€‚

>---
#### Void 

`void` æè¿°å€¼çš„ç©ºé›†ã€‚æ²¡æœ‰ `void` ç±»å‹çš„å˜é‡ï¼Œä¸»è¦ç”¨äºæ— è¿”å›å€¼å‡½æ•°ï¼Œæˆ–å£°æ˜éç±»å‹åŒ–çš„ä¸€èˆ¬æŒ‡é’ˆã€‚ä»»ä½•è¡¨è¾¾å¼éƒ½å¯ä»¥æ˜¾ç¤ºæˆ–å¼ºåˆ¶è½¬æ¢ä¸ºç±»å‹ `void`ï¼Œä»…é™äºï¼š
- è¡¨è¾¾å¼è¯­å¥ï¼›
- é¡ºåºè¿ç®—ç¬¦çš„å·¦æ“ä½œæ•°ï¼›
- æ¡ä»¶è¿ç®—ç¬¦çš„ç¬¬äºŒä¸ªæˆ–ç¬¬ä¸‰ä¸ªæ“ä½œæ•°ï¼›

`void*` æŒ‡é’ˆå¯ä»¥æŒ‡å‘ä»»ä½•æœª `const` æˆ– `volatile` å£°æ˜çš„å˜é‡ã€‚æ— æ³•å¯¹ `void*` å–æ¶ˆå¼•ç”¨ï¼Œåªèƒ½å¼ºåˆ¶è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚`void*` æŒ‡é’ˆå¯ä»¥æŒ‡å‘ *Free* å‡½æ•°ï¼ˆéç±»æˆå‘˜å‡½æ•°ï¼‰æˆ–é™æ€æˆå‘˜å‡½æ•°ï¼Œä¸èƒ½æŒ‡å‘éé™æ€æˆå‘˜å‡½æ•°ã€‚

```c++
void return_nothing()
{
   // A void function without value returned
}

// void vobject;   // ERROR
void *pv;       // okay
int *pint; int i;
int main()
{
   pv = &i;
   // Cast is optional in C, required in C++
   pint = (int *)pv;
}
```

>---
#### std::nullptr_t

`nullptr` è¡¨ç¤ºä¸º `std::nullptr_t` çš„ç©ºæŒ‡é’ˆå¸¸é‡ï¼Œå¯è½¬æ¢ä¸ºä»»ä½•åŸå§‹æŒ‡é’ˆç±»å‹ã€‚é¿å…å°† NULL æˆ–é›¶ (0) ç”¨ä½œç©ºæŒ‡é’ˆå¸¸é‡

ä¾‹å¦‚ï¼Œå¯¹äºç»™å®š `func(std::pair<const char *, double>)`ï¼Œè°ƒç”¨ `func(std::make_pair(NULL, 3.14))` ä¼šå¯¼è‡´ç¼–è¯‘å™¨é”™è¯¯ã€‚å® `NULL` å°†æ‰©å±•åˆ° 0ï¼Œè°ƒç”¨ `std::make_pair(0, 3.14)` å°†è¿”å› `std::pair<int, double>`ï¼Œæ­¤ä¸å¯è½¬æ¢ä¸º `std::pair<const char *, double>` å‚æ•°ç±»å‹ã€‚

```c++
using namespace std;
void func(std::pair<const char*, double>) {
	cout << "call pair<const char*, double>\n";
}
void func(std::pair<int, double>) {
	cout << "call pair<int, double>\n";
}

int main() {
	func(std::make_pair(NULL, 3.14));
	func(std::make_pair(nullptr, 3.14));
	// call pair<int, double>
	// call pair<const char*, double>
}
```

>---
#### Boolean

`bool` ç±»å‹å…·æœ‰å€¼ `true` å’Œ `false`ï¼›æ¡ä»¶è¡¨è¾¾å¼å…·æœ‰ç±»å‹ `bool`ï¼›`bool` ç±»å‹å‚ä¸äº†é»˜è®¤æ•´å‹æå‡ã€‚

```c++
bool a = 1;  // true
bool b = 0;  // false
int ia = a;  // 1
int ib = b;  // 0
auto c = a + b;  // int; 1
```

>---
#### Character

`char` ç±»å‹æ˜¯ä¸€ç§å­—ç¬¦è¡¨ç¤ºç±»å‹ï¼Œå¯æœ‰æ•ˆåœ°å¯¹åŸºæœ¬æ‰§è¡Œå­—ç¬¦é›†çš„æˆå‘˜è¿›è¡Œç¼–ç ã€‚C++ ç¼–è¯‘å™¨å°† `char`, `signed char` å’Œ `unsigned char` ç±»å‹çš„å˜é‡è§†ä¸ºä¸åŒç±»å‹ã€‚

`wchar_t` ç±»å‹çš„å˜é‡æ˜¯å®½å­—ç¬¦æˆ–å¤šå­—èŠ‚å­—ç¬¦ç±»å‹ã€‚åœ¨å­—ç¬¦æˆ–å­—ç¬¦ä¸²æ–‡æœ¬å‰ä½¿ç”¨ L å‰ç¼€å¯æŒ‡å®šå®½å­—ç¬¦ç±»å‹ã€‚

`char8_t` ç±»å‹ç”¨äº UTF-8 å­—ç¬¦è¡¨ç¤ºå½¢å¼ã€‚`char16_t` ç±»å‹ç”¨äº UTF-16 å­—ç¬¦è¡¨ç¤ºå½¢å¼ã€‚`char32_t` ç±»å‹ç”¨äº UTF-32 å­—ç¬¦è¡¨ç¤ºå½¢å¼ã€‚ 

```c++
char       c = 'A';
int       mc = 'abcd';
char8_t   c8 = u8"A";
char16_t c16 = u"A";
char32_t c32 = U"A";
wchar_t   wc = L'A';
```

>---
#### Floating-point

æµ®ç‚¹ç±»å‹ä½¿ç”¨ IEEE-754 è¡¨ç¤ºå½¢å¼ï¼Œåœ¨å„ç§æ•°é‡çº§ä¸Šæä¾›å°æ•°å€¼çš„è¿‘ä¼¼å€¼ã€‚C++ æ ‡å‡†ä¸­æœªæŒ‡å®šå†…ç½®æµ®ç‚¹ç±»å‹çš„ç»å¯¹å¤§å°ã€‚

```c
float   // åœ¨ C++ ä¸­æœ€å°çš„æµ®ç‚¹ç±»å‹ã€‚
double  // å¤§äºæˆ–ç­‰äº float ç±»å‹ä½†å°äºæˆ–ç­‰äº long double ç±»å‹
long double // å¤§äºæˆ–ç­‰äº doubleç±»å‹

float  f = 3.1415f;
double d = 3.1415;
long double ld = 3.1415L; 
```

>---
#### Integer

`int` ç±»å‹æ˜¯é»˜è®¤çš„åŸºæœ¬æ•´æ•°ç±»å‹ã€‚å®ƒå¯ä»¥è¡¨ç¤ºæŸä¸ªç‰¹å®šäºå®ç°çš„èŒƒå›´çš„æ‰€æœ‰æ•´æ•°ã€‚æœ‰ç¬¦å·æ•´æ•°å¯ä»¥åŒæ—¶ä¿å­˜æ­£å€¼å’Œè´Ÿå€¼ã€‚å¤§å°ä¿®é¥°ç¬¦æŒ‡å®šä½¿ç”¨çš„æ•´æ•°è¡¨ç¤ºå½¢å¼çš„å®½åº¦ï¼Œä¾‹å¦‚ `short`ï¼Œ`long`ï¼Œ`long long`ã€‚

```c++
1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)

int i = 1;
unsigned ui = 1u;
short s = 1;
long  l = 1L;
long long ll = 1LL;
unsigned long long ull = 1ull;
```

> å£°æ˜åŒä¹‰è¯

```c++
short == short int == signed short == signed short int
unsigned short == unsigned short int
int == signed == signed int
unsigned == unsigned int
long == long int == signed long == signed long int
unsigned long == unsigned long int
long long == long long int == signed long long == signed long long int
unsigned long long == unsigned long long int
```

>---
#### æ•°å€¼é™åˆ¶

`<limits.h>` å’Œ `<float.h>`å®šä¹‰äº†æ•°å­—é™åˆ¶æˆ–ç»™å®šç±»å‹çš„å˜é‡å¯åŒ…å«çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚å‚é˜… [C stdlib](https://github.com/JimryYchao/Learn-Programming-C#c-%E6%A0%87%E5%87%86%E5%BA%93c23)ã€‚



---
### å£°æ˜ä¸å®šä¹‰

ç¨‹åºçš„å®ä½“ï¼ˆ*Entity*ï¼‰åŒ…æ‹¬å€¼ã€å¯¹è±¡ã€å¼•ç”¨ã€ç»“æ„åŒ–ç»‘å®šã€å‡½æ•°ã€æšä¸¾å™¨ã€ç±»å‹ã€ç±»æˆå‘˜ã€ä½å­—æ®µã€æ¨¡æ¿ã€æ¨¡æ¿ä¸“ç”¨åŒ–ã€å‘½åç©ºé—´æˆ–åŒ…ã€‚

åç§°æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦ã€é‡è½½è¿ç®—ç¬¦æ ‡è¯†ç¬¦ã€ç”¨æˆ·å®šä¹‰æ–‡æœ¬è¿ç®—ç¬¦æ ‡è¯†ç¬¦ã€æˆ–è¿ç®—ç¬¦è½¬æ¢ç±»å‹æ ‡è¯†ç¬¦ã€‚å®ä½“çš„åç§°ç”±å£°æ˜å¼•å…¥ï¼Œå£°æ˜å¯ä»¥æ˜¯åç§°å£°æ˜ã€å—å£°æ˜æˆ–æˆå‘˜å£°æ˜ï¼›åˆå§‹åŒ–å£°æ˜ï¼›ç»“æ„åŒ–ç»‘å®šå£°æ˜ï¼›å‚æ•°ã€ç±»å‹å‚æ•°ã€ç±»å‹å®šä¹‰ç­‰ã€‚å®ä½“ `E` ç”±å£°æ˜ `E` å¼•å…¥çš„åç§°ï¼ˆå¦‚æœæœ‰ï¼‰æˆ–ç”±æŒ‡å®š `E` çš„å£°æ˜å¼•å…¥çš„ *typedef-name* è¡¨ç¤ºã€‚

å˜é‡æ˜¯é€šè¿‡å£°æ˜éé™æ€æ•°æ®æˆå‘˜æˆ–å¯¹è±¡ä»¥å¤–çš„å¼•ç”¨æ¥å¼•å…¥çš„ã€‚å˜é‡çš„åç§°ï¼ˆå¦‚æœæœ‰ï¼‰è¡¨ç¤ºå¼•ç”¨æˆ–å¯¹è±¡ã€‚å±€éƒ¨å®ä½“æ˜¯å…·æœ‰è‡ªåŠ¨å­˜å‚¨æœŸçš„å˜é‡ã€ç»“æ„åŒ–ç»‘å®šå¯¹åº”çš„å˜é‡ï¼Œæˆ– *this å¯¹è±¡ã€‚

å£°æ˜å¯ä»¥ï¼ˆé‡æ–°ï¼‰å°†ä¸€ä¸ªæˆ–å¤šä¸ªåç§°å’Œ / æˆ–å®ä½“å¼•å…¥ç¿»è¯‘å•å…ƒï¼Œå¹¶æŒ‡å®šè¿™äº›åç§°çš„è§£é‡Šå’Œè¯­ä¹‰å±æ€§ã€‚å¦‚æœå¯ä»¥ä»å®ä½“æˆ– *typedef-name* `X` ä¸­è·å–å¦ä¸€ä¸ª `X` å£°æ˜ï¼Œåˆ™è¯¥å®ä½“æˆ– *typedef-name* `X` çš„å£°æ˜æ˜¯ `X` çš„é‡æ–°å£°æ˜ã€‚

åœ¨å¯¹è±¡çš„å®šä¹‰ä¸­ï¼Œè¯¥å¯¹è±¡çš„ç±»å‹ä¸åº”è¯¥æ˜¯ä¸å®Œæ•´ç±»å‹ã€æŠ½è±¡ç±»ç±»å‹æˆ–å…¶æ•°ç»„ï¼ˆå¯èƒ½æ˜¯å¤šç»´çš„ï¼‰ã€‚

```c++
// å®šä¹‰å£°æ˜
int a;                         // defines a
extern const int c = 1;        // defines c
int f(int x) { return x + a; } // defines f and defines x
struct S
{
    int a;
    int b;
}; // defines S, S::a, and S::b
struct X
{                 // defines X
    int x;        // defines non-static data member x
    static int y; // declares static data member y
    X() : x(0) {} // defines a constructor of X
};
int X::y = 1; // defines X::y
enum
{
    up,
    down
}; // defines up and down
namespace N
{
    int d;
} // defines N and N::d
namespace N1 = N; // defines N1
X anX;            // defines anX

// ä»…å£°æ˜
extern int a;       // declares a
extern const int c; // declares c
int f(int);         // declares f
struct S;           // declares S
typedef int Int;    // declares Int
extern X anotherX;  // declares anotherX
using N::d;         // declares d
```

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šä¸ºä¸€äº›å®šä¹‰å£°æ˜éšå¼å®šä¹‰é»˜è®¤æ„é€ å‡½æ•°ã€èµ‹å€¼æ„é€ å‡½æ•°ã€ç§»åŠ¨æ„é€ å‡½æ•°ã€å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ã€ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦æˆ–ç»ˆç»“å™¨ã€‚

```c++
struct C {
    std::string s; // std::string is the standard library class (23.4)
};
// å®ç°å°†éšå¼å®šä¹‰
struct C
{
    std::string s;
    C() : s() {}
    C(const C &x) : s(x.s) {}
    C(C &&x) : s(static_cast<std::string &&>(x.s)) {}
    // : s(std::move(x.s)) { }
    C &operator=(const C &x)
    {
        s = x.s;
        return *this;
    }
    C &operator=(C &&x)
    {
        s = static_cast<std::string &&>(x.s);
        return *this;
    }
    // { s = std::move(x.s); return *this; }
    ~C() {}
};
```

> One-definition rule 

å•ä¸€å®šä¹‰åŸåˆ™ï¼ŒODRï¼šä»»ä½•ç¿»è¯‘å•å…ƒä¸å¾—åŒ…å«ä»»ä½•å¯å®šä¹‰é¡¹çš„ä¸€ä¸ªä»¥ä¸Šå®šä¹‰ã€‚å¯å®šä¹‰é¡¹åŒ…æ‹¬ï¼šç±»ç±»å‹ã€æšä¸¾ç±»å‹ã€å‡½æ•°ã€å˜é‡ã€æ¨¡æ¿åŒ–å®ä½“ã€å‚æ•°çš„é»˜è®¤å®å‚ã€é»˜è®¤æ¨¡æ¿å®å‚ã€‚

>---
#### å­˜å‚¨ç±»è¯´æ˜ç¬¦

```c++
static
extern
register   // å¼ƒç”¨
thread_local
mutable
```

å˜é‡å£°æ˜ä¸Šä¸‹æ–‡ä¸­çš„å­˜å‚¨ç±»è¯´æ˜ç¬¦æ˜¯ç®¡ç†å¯¹è±¡çš„ç”Ÿå­˜æœŸã€é“¾æ¥å’Œå†…å­˜ä½ç½®çš„ç±»å‹è¯´æ˜ç¬¦ã€‚ç»™å®šå¯¹è±¡åªèƒ½æœ‰ä¸€ä¸ªå­˜å‚¨ç±»ã€‚å—ä¸­å®šä¹‰ä¸€èˆ¬å…·æœ‰è‡ªåŠ¨å­˜å‚¨æœŸï¼Œé™¤éä½¿ç”¨ `extern`ã€`static` æˆ– `thread_local`ã€‚è‡ªåŠ¨å­˜å‚¨æœŸå¯¹è±¡å’Œå˜é‡ä¸å…·æœ‰é“¾æ¥ï¼Œå—å¤–ä¸å¯è§ã€‚

`static` åœ¨å…¨å±€èŒƒå›´ã€å‘½åç©ºé—´èŒƒå›´å’Œç±»èŒƒå›´å£°æ˜å˜é‡å’Œå‡½æ•°ï¼Œä»¥ç»‘å®šå†…éƒ¨é“¾æ¥ï¼Œå˜é‡å…·æœ‰é™æ€å­˜å‚¨æœŸï¼Œç±»æ‰€æœ‰å®ä¾‹å…±äº«ç±» `static` å˜é‡å’Œå‡½æ•°ã€‚å±€éƒ¨èŒƒå›´çš„ `static` å±€éƒ¨å˜é‡å…·æœ‰é™æ€å­˜å‚¨æœŸï¼ˆç¨‹åºç»“æŸæ—¶é‡Šæ”¾ï¼‰ã€‚

```c++
// static1.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
void showstat( int curr ) {
   static int nStatic;    // Value of nStatic is retained
                          // between each function call
   nStatic += curr;
   cout << "nStatic is " << nStatic << endl;
}

int main() {
   for ( int i = 0; i < 5; i++ )
      showstat( i );  // 0,1,3,6,10
}
```

å£°æ˜ä¸º `extern` çš„å¯¹è±¡å’Œå˜é‡å°†åœ¨å¦ä¸€ä¸ªç¿»è¯‘å•å…ƒæˆ–åœ¨ä¸€ä¸ªå°é—­èŒƒå›´ä¸­å®šä¹‰çš„å¯¹è±¡å£°æ˜ä¸ºå…·æœ‰å¤–éƒ¨é“¾æ¥ã€‚`extern` å¯ä»¥åº”ç”¨äºå…¨å±€å˜é‡ã€å‡½æ•°ã€ç±»å‹æˆ–æ¨¡æ¿å£°æ˜ï¼Œæ ‡è¯†å¤–éƒ¨é“¾æ¥å±æ€§ã€‚
- åœ¨é `const` å…¨å±€å˜é‡å£°æ˜ä¸­ï¼Œ`extern` æŒ‡å®šå˜é‡æˆ–å‡½æ•°åœ¨å¦ä¸€ä¸ªç¿»è¯‘å•å…ƒä¸­å®šä¹‰ã€‚
- åœ¨ `const` å˜é‡ï¼ˆå†…éƒ¨é“¾æ¥ï¼‰å£°æ˜ä¸­ï¼Œå®ƒæŒ‡å®šå˜é‡å…·æœ‰å¤–éƒ¨é“¾æ¥ã€‚
- `extern "C"` æŒ‡å®šå‡½æ•°åœ¨åˆ«å¤„å®šä¹‰å¹¶ä½¿ç”¨ C è¯­è¨€è°ƒç”¨çº¦å®šã€‚`extern "C"` ä¿®é¥°ç¬¦ä¹Ÿå¯ä»¥åº”ç”¨äºå—ä¸­çš„å¤šä¸ªå‡½æ•°å£°æ˜ã€‚ä¸èƒ½é‡è½½å£°æ˜ä¸º `extern "C"` çš„å‡½æ•°ã€‚
- åœ¨æ¨¡æ¿å£°æ˜ä¸­ï¼Œ`extern` æŒ‡å®šæ¨¡æ¿å·²åœ¨å…¶ä»–ä½ç½®å®ä¾‹åŒ–ã€‚
- åœ¨å—èŒƒå›´å†…å£°æ˜çš„ `extern` å˜é‡å¼•ç”¨å¤–éƒ¨å˜é‡ï¼Œä¸”æ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼›ä»…å£°æ˜ã€‚

```c++
//fileA.cpp
int i = 42; // declaration and definition

//fileB.cpp
extern int i;  // declaration only. same as i in FileA
extern const int ci = 42;      // extern const definition
extern constexpr int cx = 10;  // extern constexpr definition

export extern "C" void F();
export extern "C++" void F(int);

int main() {
    extern int i /* = 10; ERR */;  // å¼•ç”¨å£°æ˜å¤–éƒ¨å˜é‡ i
}
```

`register` å…³é”®å­—ä¸å†æ˜¯å—æ”¯æŒçš„å­˜å‚¨ç±»ã€‚å·²ä½œä¸ºä¿ç•™ï¼ŒC++ 17 ä½œä¸ºè­¦å‘Šã€‚

```c++
void foo(){
    register int val; // warning: 'register' is no longer a supported storage class
}
```


å£°æ˜ä¸º `thread_local` çš„å˜é‡ä»…å¯åœ¨å®ƒåœ¨å…¶ä¸Šåˆ›å»ºçš„çº¿ç¨‹ä¸Šå¯è®¿é—®ï¼Œå˜é‡å…·æœ‰çº¿ç¨‹å­˜å‚¨æ—¶é—´ï¼ˆTLSï¼‰ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰å…¶è‡ªå·±çš„å˜é‡å‰¯æœ¬ã€‚
- åªèƒ½åœ¨å…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„æ•°æ®é¡¹ä¸ŠæŒ‡å®š `thread_local`
- `thread_local` è¯´æ˜ç¬¦å¯ä»¥ä¸ `static` æˆ– `extern` åˆå¹¶ã€‚
- `thread_local` ä¸èƒ½ç”¨äºå‡½æ•°å£°æ˜æˆ–å®šä¹‰ã€‚
- ä¸å»ºè®®å°† `thread_local` å˜é‡ä¸ `std::launch::async` ä¸€èµ·ä½¿ç”¨ã€‚


```c++
thread_local float f = 42.0; // Global namespace. Not implicitly static. extern TLS
struct S // cannot be applied to type definition
{
    thread_local int i; // Illegal. The member must be static.
    thread_local static char buf[10]; // OK; static TLS
};

void DoSomething()
{
    // Apply thread_local to a local variable.
    // Implicitly "thread_local static S my_struct".
    thread_local S my_struct;  // static TLS
}
```

`mutable` åªåº”ç”¨äºç±»çš„éé™æ€ã€éå¸¸é‡å’Œéå¼•ç”¨æ•°æ®æˆå‘˜ã€‚å¦‚æœæŸä¸ªæ•°æ®æˆå‘˜è¢«å£°æ˜ä¸º `mutable`ï¼Œåˆ™ä» `const` æˆå‘˜å‡½æ•°ä¸ºæ­¤æ•°æ®æˆå‘˜èµ‹å€¼æ˜¯åˆæ³•çš„ã€‚

```c++
// mutable.cpp
class X
{
public:
    bool GetFlag() const
    {
        m_accessCount++;  // allowed
        m_flag = true;    // illegal: assignment of member 'X::m_flag' in read-only object
        return m_flag;
    }
private:
    bool m_flag;
    mutable int m_accessCount;
};
```


>---
#### alignas å¯¹é½

å¯ä»¥å¯¹ `struct`ã€`class`ã€`union` æˆ–å˜é‡å£°æ˜ä½¿ç”¨ `alignas(N)` è¯´æ˜ç¬¦ï¼Œ`N = 0, 2^(1,2,4,8,16,...)`ã€‚ä¸èƒ½å°äºåº”ç”¨äºå®ƒçš„ç±»å‹çš„è‡ªç„¶å¯¹é½æ–¹å¼ã€‚ç”¨æˆ·å®šä¹‰çš„ç±»å‹çš„å£°æ˜å’Œå®šä¹‰å¿…é¡»å…·æœ‰ç›¸åŒçš„å¯¹é½å€¼ã€‚

```c++
struct alignas(8) S1     // 8
{
    int x;
};
class alignas(16) C{}    // 16
struct alignas(double) S2  // double
{
    int x;
};

template <typename... Ts> // max{ TS... }
class alignas(Ts...) C2
{
    char c;
};
alignof(C2<int, float, double>) == 8;
```

>---
#### auto ç±»å‹æ¨æ–­

`auto` æŒ‡ç¤ºç¼–è¯‘å™¨ä½¿ç”¨å·²å£°æ˜å˜é‡çš„åˆå§‹åŒ–è¡¨è¾¾å¼æˆ– lambda è¡¨è¾¾å¼å‚æ•°æ¥æ¨å¯¼å…¶ç±»å‹ã€‚`auto` è¢«è§†ä¸ºç±»å‹çš„å ä½ç¬¦ï¼Œä½†å®ƒæœ¬èº«ä¸æ˜¯ç±»å‹ã€‚å› æ­¤ä¸èƒ½ç”¨äºå¼ºåˆ¶è½¬æ¢æˆ–è¿ç®—ç¬¦ï¼Œå¦‚ `sizeof` å’Œï¼ˆç”¨äº C++/CLIï¼‰`typeid`ã€‚å˜é‡å¯ä»¥æŒ‡å®š `const`ã€`volatile` ç­‰è¯´æ˜ç¬¦å’Œå£°æ˜ç¬¦ã€æŒ‡é’ˆã€å³å€¼å¼•ç”¨ã€‚

ä½¿ç”¨ `auto` ä¼šåˆ é™¤å¼•ç”¨ã€`const` é™å®šç¬¦å’Œ `volatile` é™å®šç¬¦ã€‚

```c++
auto PI = 3.141592653;        // double
auto lambda = [](int a, int b){ 
	return a + b; 
};  // int lambda(int, int)

auto const V = 10010;	      // int
auto static SV(V);			  // static int; SV = V
auto extern const ECV = SV;   // extern const int
auto volatile* PSV(&SV);      // volatile int*
auto& reflv = V;			  // const int &
auto&& refrv(10086);		  // int &&
struct S {
	int x;
	int y;
};
auto A(S{ 1, 2 });

for (auto&& i = a; i >= 0; i--)
	cout << "Hello World\n";
```

>---
#### const ä¸å¯å˜

å½“å®ƒä¿®æ”¹æ•°æ®å£°æ˜æ—¶ï¼Œ`const` æŒ‡å®šå¯¹è±¡ã€å˜é‡ä¸å¯ä¿®æ”¹ã€‚`const T` å’Œ `T` æ˜¯ä¸åŒçš„æ•°æ®ç±»å‹ã€‚`const` å¸¸é‡å€¼å…·æœ‰å†…éƒ¨é“¾æ¥ã€‚å¯¹äºå£°æ˜ä¸º `const` çš„å¯¹è±¡ï¼Œåªèƒ½è°ƒç”¨å¸¸é‡æˆå‘˜å‡½æ•°ã€‚

```c++
const int i = 10;
i++;   // ERROR
const * pi = &i;
extern const double d;    // å¤–éƒ¨é“¾æ¥
```

> `const` ä¸æŒ‡é’ˆ

```c++
const int i = 10;
int mi = 10;

int const* pi = &mi;   // æŒ‡å‘å¸¸é‡æ•´æ•°çš„æŒ‡é’ˆ
const int* pi2 = pi;

int* const cpi = &mi;  // æŒ‡å‘æ•´æ•°çš„å¸¸é‡æŒ‡é’ˆ
const int* cpi2 = &mi;
*cpi = 100;   // æŒ‡é’ˆä¸å¯ä¿®æ”¹ï¼Œå€¼å¯ä¿®æ”¹

const int* const cpci = &i;   // æŒ‡å‘å¸¸é‡æ•´æ•°çš„å¸¸é‡æŒ‡é’ˆ
const int* const cpci2 = &mi; // æŒ‡å‘æ•´æ•°çš„å¸¸é‡æŒ‡é’ˆï¼Œä½†æ— æ³•ä»æŒ‡é’ˆä¿®æ”¹æ•°æ®
```

> `const` æˆå‘˜å‡½æ•°

```c++
rt-type funcName(params) const {}  
```

å£°æ˜ `const` æˆå‘˜å‡½æ•°å°†æŒ‡å®šä¸ºä¸€ä¸ª â€œåªè¯»â€ å‡½æ•°ï¼Œå®ƒä¸ä¼šä¿®æ”¹ä¸ºå…¶è°ƒç”¨è¯¥å‡½æ•°çš„å¯¹è±¡ã€‚å¸¸é‡æˆå‘˜å‡½æ•°ä¸èƒ½ä¿®æ”¹ä»»ä½•éé™æ€æ•°æ®æˆå‘˜ï¼ˆé™¤äº† `mutable`ï¼‰æˆ–è°ƒç”¨ä»»ä½•éå¸¸é‡æˆå‘˜å‡½æ•°ã€‚ 

```c++
class Date
{
public:
	Date(int mn, int dy, int yr);
	int getMonth() const;     // A read-only function
	void setMonth(int mn);   // A write function; can't be const
private:
	int month;
};

int Date::getMonth() const 
{
	return month;        // Doesn't modify anything
}
void Date::setMonth(int mn)
{
	month = mn;          // Modifies data member
}
int main()
{
	Date MyDate(7, 4, 1998);
	const Date BirthDate(1, 18, 1953);
	MyDate.setMonth(4);         // Okay
	auto _ = MyDate.getMonth(); // okay;
	BirthDate.getMonth();       // Okay
	BirthDate.setMonth(4);      // Error; const v call non-const-func
}
```

å¯ä»¥ä¸ºéå¸¸é‡å¯¹è±¡è°ƒç”¨å¸¸é‡æˆ–éå¸¸é‡æˆå‘˜å‡½æ•°ã€‚å¯ä»¥ä½¿ç”¨ `const` å…³é”®å­—é‡è½½æˆå‘˜å‡½æ•°ä½¿å¾—å¯ä»¥å¯¹å¸¸é‡å’Œéå¸¸é‡å¯¹è±¡è°ƒç”¨ä¸åŒç‰ˆæœ¬çš„å‡½æ•°ã€‚å¯¹äºå£°æ˜ä¸º `const` çš„å¯¹è±¡ï¼Œåªèƒ½è°ƒç”¨å¸¸é‡æˆå‘˜å‡½æ•°ã€‚

```c++
class Data {
public:
	void MulData(int data) const {
		this->data = data;
	}
	void MulData(int data) {
		this->data = data;
	}
private :
	mutable int data;  // can motify in const-func
};

int main() {
	const auto cd = Data();
	auto d = Data();
	cd.MulData(1);  // call Muldata() const
	d.MulData(1);   // call Muldata()
}
```

>---
#### constexpr å¸¸é‡è¡¨è¾¾å¼

ä¸ `const` ä¸€æ ·ï¼Œ`constexpr` å¯ä»¥åº”ç”¨äºå˜é‡ï¼›`constexpr` ä¹Ÿå¯ä»¥åº”ç”¨äºå‡½æ•°å’Œç±» constructorï¼ˆæ„é€ å‡½æ•°ï¼‰ã€‚`constexpr` æŒ‡ç¤ºå€¼æˆ–è¿”å›å€¼æ˜¯ constantï¼ˆå¸¸æ•°ï¼‰ã€‚å¦‚æœå¯èƒ½ï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶è¿›è¡Œè®¡ç®—ã€‚C++14 æ ‡å‡†è¦æ±‚å¸¸é‡è¡¨è¾¾å¼ä¸­æ¶‰åŠçš„ç±»å‹ä¸ºæ–‡æœ¬ç±»å‹ã€‚

`constexpr` å˜é‡å¿…é¡»åœ¨ç¼–è¯‘æ—¶è¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœåˆå§‹åŒ–ç”±æ„é€ å‡½æ•°æ‰§è¡Œï¼Œåˆ™å¿…é¡»å°†æ„é€ å‡½æ•°å£°æ˜ä¸º `constexpr`ã€‚å¼•ç”¨å¯ä»¥è¢«å£°æ˜ä¸º `constexpr`ï¼šå¼•ç”¨çš„å¯¹è±¡æ˜¯ç”±å¸¸é‡è¡¨è¾¾å¼åˆå§‹åŒ–ã€‚

`constexpr` å‡½æ•°æ˜¯åœ¨ä½¿ç”¨éœ€è¦å®ƒçš„ä»£ç æ—¶ï¼Œå¯åœ¨ç¼–è¯‘æ—¶è®¡ç®—å…¶è¿”å›å€¼çš„å‡½æ•°ã€‚å½“å…¶è‡ªå˜é‡ä¸º `constexpr` å€¼æ—¶ï¼Œå‡½æ•° `constexpr` å°†ç”Ÿæˆç¼–è¯‘æ—¶å¸¸é‡ã€‚ä»¥ä¸‹è§„åˆ™é€‚ç”¨äº `constexpr` å‡½æ•°ï¼š

- `constexpr` å‡½æ•°æˆ–æ„é€ å‡½æ•°é€šè¿‡éšå¼æ–¹å¼ `inline`ã€‚
- `constexpr` å˜é‡æˆ–å‡½æ•°å¿…é¡»è¿”å›æ–‡æœ¬ç±»å‹ã€‚
- `constexpr` å‡½æ•°å¯ä»¥é€’å½’ã€‚
- C++20 åå¯ä»¥å®šä¹‰ `virtual constexpr func`ï¼›å¸¦æœ‰è™šæ‹ŸåŸºç±»çš„ç±»ä¸èƒ½å£°æ˜ `constexpr ctor`ã€‚
- ä¸»ä½“å¯ä»¥å®šä¹‰ä¸º `= default` æˆ– `= delete`ã€‚
- å¯ä»¥å°†é `constexpr` æ¨¡æ¿çš„æ˜¾å¼ä¸“ç”¨åŒ–å£°æ˜ä¸º `constexpr`ã€‚`constexpr` æ¨¡æ¿çš„æ˜¾å¼ä¸“ç”¨åŒ–ä¸éœ€è¦åŒæ—¶æ˜¯ `constexpr`ã€‚
- å®ƒå¯èƒ½åŒ…å«å±€éƒ¨å˜é‡å£°æ˜ï¼Œä½†å¿…é¡»åˆå§‹åŒ–è¯¥å˜é‡ã€‚å®ƒå¿…é¡»æ˜¯æ–‡æœ¬ç±»å‹ï¼Œä¸èƒ½æ˜¯ `static` æˆ– `thread_local` çš„ã€‚å±€éƒ¨å˜é‡ä¸éœ€è¦æ˜¯ `const`ï¼Œå¹¶ä¸”å¯ä»¥å˜åŒ–ã€‚

```c++
template <typename T, int N>
void Iter(T arr[N]) {
	for (int i = 0; i < N; i++)
		cout << arr[i] << endl;
}

constexpr int arr[5] = { 1,3,4,5,6 };
Iter<const int, 5>(arr);

class B {
	constexpr B() = default;
	int constexpr foo() = delete;
};
```

>---
#### åˆå§‹å€¼è®¾å®šé¡¹

åˆå§‹å€¼è®¾å®šé¡¹å¯æŒ‡å®šå˜é‡çš„åˆå§‹å€¼ã€‚

```c++
struct Point {
    int x;
    int y;
};
class PointConsumer {
public:
    void set_point(Point p) {};
    void set_points(initializer_list<Point> my_list) {};
    // å‡½æ•°è¿”å›å€¼
    Point get_new_point(int x, int y) { return { x, y }; }
};

int main() {
    PointConsumer pc{};
    // å˜é‡
    int i = 3;
    Point p1{ 1, 2 };
    // å‡½æ•°å‚æ•°
    pc.set_point({});
    pc.set_point(Point{ 3,5 });
    pc.set_point({ 3, 4 });
    pc.set_points({ { 3, 4 }, { 5, 6 } });
}
```

é›¶åˆå§‹åŒ–æ˜¯æŒ‡å°†å˜é‡è®¾ç½®ä¸ºéšå¼è½¬æ¢ä¸ºè¯¥ç±»å‹çš„é›¶å€¼ã€‚

```c++
struct my_struct{
    int i;
    char c;
};

int i0;              // zero-initialized to 0
int main() {
    static float f1;  // zero-initialized to 0.000000000
    double d{};       // zero-initialized to 0.00000000000000000
    int* ptr{};       // initialized to nullptr
    char s_array[3]{'a', 'b'};  // the third char is initialized to '\0'
    int int_array[5] = { 8, 9, 10 };  // the fourth and fifth ints are initialized to 0
    my_struct a_struct{};   // i = 0, c = '\0'
}
```

ç±»ã€ç»“æ„å’Œè”åˆçš„é»˜è®¤åˆå§‹åŒ–æ˜¯å…·æœ‰é»˜è®¤æ„é€ å‡½æ•°çš„åˆå§‹åŒ–ã€‚ 

```c++
MyClass mc1;
MyClass* mc3 = new MyClass;
```

å¦‚æœå®šä¹‰æ ‡é‡å˜é‡æˆ–æ•°ç»„æ—¶ä¸ä½¿ç”¨åˆå§‹åŒ–è¡¨è¾¾å¼ï¼Œåˆ™è¿›è¡Œé»˜è®¤åˆå§‹åŒ–ã€‚å®ƒä»¬çš„å€¼æ˜¯ä¸ç¡®å®šçš„ã€‚é™æ€å˜é‡çš„å£°æ˜ä¸­æ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼Œåˆ™é›¶åˆå§‹åŒ–ã€‚

```c++
int i1;
float f;
char c;
int int_arr[3];
static int int1;       // 0
static char char1;     // '\0'
static bool bool1;     // false
static MyClass mc1;    // {0, '\0'}
```

å€¼åˆå§‹åŒ–ä½¿ç”¨ `{}` åˆå§‹åŒ–å·²å‘½åå€¼ã€`(), {}` åˆå§‹åŒ–åŒ¿åä¸´æ—¶å¯¹è±¡ã€`new T(), {}` åˆå§‹åŒ–å¯¹è±¡ã€‚ç›´æ¥åˆå§‹åŒ–ä½¿ç”¨ `{}, {values...}, (values...)`  æ˜¾å¼è°ƒç”¨æ„é€ å‡½æ•°åˆå§‹åŒ–ã€‚

```c++
class BaseClass {
private:
    int m_int;
};

int main() {
    BaseClass bc{};    // class is initialized
    BaseClass*  bc2 = new BaseClass();  // class is initialized, m_int value is 0
    int int_arr[3]{};  // value of all members is 0
    int a{};           // value of a is 0
    double b{};        // value of b is 0.00000000000000000
    
    double d(10);
    double d2{};
}
```

å¤åˆ¶åˆå§‹åŒ–æ˜¯æŒ‡ä½¿ç”¨ä¸€ä¸ªä¸åŒçš„å¯¹è±¡æ¥åˆå§‹åŒ–å¦ä¸€ä¸ªå¯¹è±¡ã€‚å¦‚æœç±»çš„å¤åˆ¶æ„é€ å‡½æ•°è¢«åˆ é™¤æˆ–ä¸å¯è®¿é—®ï¼Œå¤åˆ¶åˆå§‹åŒ–å°†å¯¼è‡´ç¼–è¯‘å™¨é”™è¯¯ã€‚

```c++
class MyClass {
public:
	MyClass() {}
private:
	MyClass(MyClass& c) = delete;
};
int main() {
	MyClass mc1;
	MyClass mc2 = mc1;  // ERROR: åˆ é™¤
}
```

åˆ—è¡¨åˆå§‹åŒ–ä½¿ç”¨ `{v1,v2,..}` åˆå§‹åŒ–å˜é‡æˆ–å‚æ•°ã€`new` ç±»å¯¹è±¡ã€éé™æ€æ•°æ®æˆå‘˜çš„åˆå§‹å€¼è®¾å®šé¡¹ã€æ„é€ å‡½æ•°åˆå§‹å€¼è®¾å®šé¡¹åˆ—è¡¨ä¸­ã€‚

```c++
class MyClass {
public:
    MyClass(int myInt, char myChar) {}
private:
    int m_int[5]{ 3 };
    char m_char;
};
class MyClassConsumer{
public:
    void set_class(MyClass c) {}
    MyClass get_class() { return MyClass{ 0, '\0' }; }
};
struct MyStruct{
    int my_int;
    char my_char;
    MyClass my_class;
};
int main() {
    MyClass mc1{ 1, 'a' };
    MyClass* mc2 = new MyClass{ 2, 'b' };
    MyClass mc3 = { 3, 'c' };

    MyClassConsumer mcc;
    mcc.set_class(MyClass{ 3, 'c' });
    mcc.set_class({ 4, 'd' });

    MyStruct ms1{ 1, 'a', { 2, 'b' } };
}
```

èšåˆåˆå§‹åŒ–æ˜¯é’ˆå¯¹æ•°ç»„æˆ–ç±»ç±»å‹ï¼ˆé€šå¸¸ä¸ºç»“æ„æˆ–è”åˆï¼‰çš„ä¸€ç§åˆ—è¡¨åˆå§‹åŒ–å½¢å¼ã€‚

```c++
struct Point3D {
	struct Point2D {
		int x, y;
	} xy;
	int z;
};
int main() {
    int arr[10](1, 2, 3, 4 /*,0 ...*/);
    int arr2[]{ 1,2,3,4,5,6 };  // arr2[6]

	using Point2D = Point3D::Point2D;
	Point2D p2{ 1,1 };
	Point3D p3{ 1,2,3 };
	Point3D p3_2{ {1,2},3 };
};
```

å¼•ç”¨ç±»å‹çš„å˜é‡å¿…é¡»ä½¿ç”¨å¼•ç”¨ç±»å‹æ´¾ç”Ÿè‡ªçš„ç±»å‹çš„å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–ï¼Œæˆ–ä½¿ç”¨å¯è½¬æ¢ä¸ºå¼•ç”¨ç±»å‹æ´¾ç”Ÿè‡ªçš„ç±»å‹çš„ç±»å‹çš„å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–ã€‚
- å¼•ç”¨è‡ªå˜é‡çš„å£°æ˜éœ€è¦åˆå§‹åŒ–è®¾å®šé¡¹ï¼›é™¤äº†ï¼š
  ```c++
  int func( int& );  // å‡½æ•°åŸå‹
  int& func( int& ); // å¼•ç”¨è¿”å›
  class c {public:   int& i;};  // æˆå‘˜å£°æ˜
  extern int& iVal;  // å¤–éƒ¨å¼•ç”¨å£°æ˜
  ```

```c++
int iVar;
long lVar;
int main()
{
    long& LongRef1 = lVar;        // No conversion required.
    long& LongRef2 = iVar;        // Error; wrong type
    const long& LongRef3 = iVar;  // OK
    LongRef1 = 23L;               // Change lVar through a reference.
    LongRef2 = 11L;               // Change iVar through a reference.
    LongRef3 = 11L;               // Error ; const

	volatile int& viVarRef = iVar;
	const int& ciVarRef = iVar;
}
```

>---
#### using åˆ«åå’Œ typedef

â€œåˆ«åå£°æ˜â€ å£°æ˜ä¸€ä¸ªç±»å‹çš„åŒä¹‰è¯åˆ«åï¼›

```c++
using identifier = type;
typedef type identifier;

using fmtfl = std::ios_base::fmtflags;
typedef std::ios_base::fmtflags fmtfl;

using func = void(*)(int);
typedef void (*func)(int);
```

`using` åˆ«åå’Œ `typedef` çš„åŒºåˆ«åœ¨äº `using` å¯ä»¥åˆ›å»ºåˆ«åæ¨¡æ¿ï¼š

```c++
template<typename T> using ptr = T*;
ptr<int> ptr_int;
```

`typedef` å£°æ˜åœ¨å…¶èŒƒå›´å†…å¼•å…¥ä¸€ä¸ªåç§°ï¼Œè¯¥åç§°æˆä¸ºå£°æ˜çš„ â€œç±»å‹å£°æ˜â€ éƒ¨åˆ†ç»™å®šçš„ç±»å‹çš„åŒä¹‰è¯ã€‚ä¸å¼•å…¥æ–°ç±»å‹ã€‚å¼•å…¥çš„åç§°ä¸èƒ½ç”¨ä½œç±»å£°æ˜ä¸­çš„æ„é€ å‡½æ•°åç§°æˆ–ææ„å‡½æ•°åç§°ã€‚

```c++
typedef unsigned long UL;   // Declare a typedef name, UL.
int UL;                     // Error: redefined.
int Foo()
{
   unsigned int UL;   // Redeclaration hides typedef name
}

typedef char CHAR, *PSTR;
typedef void DRAWF( int, int );  // func

typedef struct {
	int x, y;
} Point2D, * PPoint2D, & RPoint2D, && RRPoint2D;
int main(){
	RRPoint2D rra = Point2D{ 1,1 };
	RPoint2D ra = rra;
	PPoint2D pa = &rra;
}
```

>---
#### using å£°æ˜

`using` å£°æ˜å°†åç§°å¼•å…¥å£°æ˜æ€§åŒºåŸŸï¼›

```c++
using [typename] nested-name-specifier unqualified-id;
using declarator-list;
```

- *nested-name-specifier* è¡¨ç¤ºå‘½åç©ºé—´ã€ç±»æˆ–æšä¸¾åç§°å’ŒèŒƒå›´è§£æè¿ç®—ç¬¦ (`::`) çš„åºåˆ—ï¼Œç”±èŒƒå›´è§£æè¿ç®—ç¬¦ç»ˆæ­¢ã€‚å•ä¸ªèŒƒå›´è§£æè¿ç®—ç¬¦ç”¨äºä»å…¨å±€å‘½åç©ºé—´å¼•å…¥åç§°ã€‚å…³é”®å­— `typename` æ˜¯å¯é€‰çš„ï¼Œåœ¨ä»åŸºç±»å¼•å…¥åˆ°ç±»æ¨¡æ¿æ—¶ï¼Œå¯ç”¨äºè§£æä¾èµ–åç§°ã€‚

- *unqualified-id* å¯ä»¥æ˜¯æ ‡è¯†ç¬¦ã€é‡è½½è¿ç®—ç¬¦åç§°ã€ç”¨æˆ·å®šä¹‰çš„æ–‡æœ¬è¿ç®—ç¬¦æˆ–è½¬æ¢å‡½æ•°åç§°ã€ç±»ææ„å‡½æ•°åç§°æˆ–æ¨¡æ¿åç§°å’Œå‚æ•°åˆ—è¡¨ã€‚
  
`using` å£°æ˜å¼•å…¥éé™å®šåç§°ä½œä¸ºåœ¨å…¶ä»–åœ°æ–¹å£°æ˜çš„å®ä½“çš„åŒä¹‰è¯ã€‚å®ƒå…è®¸ä½¿ç”¨ç‰¹å®šå‘½åç©ºé—´ä¸­çš„å•ä¸ªåç§°ã€‚è¿™ä¸ `using` æŒ‡ä»¤ç›¸åï¼Œ`using` æŒ‡ä»¤å…è®¸å‘½åç©ºé—´ä¸­çš„æ‰€æœ‰åç§°åœ¨æ²¡æœ‰é™å®šçš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚å±€éƒ¨å‡½æ•°å£°æ˜ä¸èƒ½ä¸ `using` å£°æ˜å¼•å…¥çš„å‡½æ•°å…·æœ‰ç›¸åŒçš„åç§°å’Œç±»å‹ã€‚

```c++
#include <iostream>
namespace mySpace {
	void Foo() {};
	struct S {};
};
int main() {
	using std::ostream;

	std::cout << "using std::ostream" << std::endl;

	mySpace::Foo(); // é™å®šä½¿ç”¨

	using mySpace::S;
	S s{};  // using å£°æ˜å¼•å…¥

	using namespace std;
	// å¼•å…¥å‘½åç©ºé—´
	cout << "using namespace std" << endl;
}
```

ç”¨äºå£°æ˜æˆå‘˜æ—¶ï¼Œ`using` å£°æ˜å¿…é¡»å¼•ç”¨åŸºç±»çš„æˆå‘˜ã€‚

```c++
#include <stdio.h>
class B {
public:
   void f(char) {
      printf_s("In B::f()\n");
   }

   void g(char) {
      printf_s("In B::g()\n");
   }
};

class C {
public:
   int g();
};

class D2 : public B {
public:
   using B::f;   // ok: B is a base of D2
   // using C::g;   // error: C isn't a base of D2
};

int main() {
   D2 MyD2;
   MyD2.f('a');
}
```

`using` å£°æ˜ä¸­æåŠçš„åç§°çš„æ‰€æœ‰å®ä¾‹éƒ½å¿…é¡»å¯è®¿é—®ã€‚

```c++
class A {
private:
   void f(char);
public:
   void f(int);
protected:
   void g();
};

class B : public A {
   using A::f;   // C2876: A::f(char) is inaccessible
public:
   using A::g;   // B::g is a public synonym for A::g
};
```

è¿›è¡Œ `using` å£°æ˜æ—¶ï¼Œç”±è¯¥å£°æ˜åˆ›å»ºçš„åŒä¹‰è¯ä»…å¼•ç”¨åœ¨è¿›è¡Œ `using` å£°æ˜æ—¶æœ‰æ•ˆçš„å®šä¹‰ã€‚ä¹‹åæ·»åŠ åˆ°å‘½åç©ºé—´çš„å®šä¹‰ä¸æ˜¯æœ‰æ•ˆåŒä¹‰è¯ã€‚

```c++
namespace A {
   void f(int) {}
}
using A::f;   // f is a synonym for A::f(int) only
namespace A {
   void f(char) {}  // after using A::f
}

void f() {
   f('a');   // refers to A::f(int), even though A::f(char) exists
}

void b() {
   using A::f;   // refers to A::f(int) AND A::f(char)
   f('a');   // calls A::f(char);
}
```

>---
#### volatile æ˜“å˜

`volatile` æ˜¯ç”¨äºå£°æ˜å¯åœ¨ç¨‹åºä¸­ç”±ç¡¬ä»¶ä¿®æ”¹çš„å¯¹è±¡çš„ç±»å‹é™å®šç¬¦ã€‚å¯ä»¥ä½¿ç”¨ `volatile` é™å®šç¬¦æä¾›å¯¹å¼‚æ­¥è¿‡ç¨‹ï¼ˆå¦‚ä¸­æ–­å¤„ç†ç¨‹åºï¼‰ä½¿ç”¨çš„å†…å­˜ä½ç½®çš„è®¿é—®æƒã€‚

å¦‚æœå°† `struct` æˆå‘˜æ ‡è®°ä¸º `volatile`ï¼Œåˆ™ `volatile` å°†ä¼ æ’­åˆ°æ•´ä¸ªç»“æ„ã€‚å¦‚æœæ»¡è¶³ä¸‹åˆ—æ¡ä»¶ä¹‹ä¸€ï¼Œåˆ™ `volatile` å¯èƒ½å¯¹å­—æ®µä¸èµ·ä½œç”¨ï¼š
- å¯å˜å­—æ®µçš„é•¿åº¦è¶…è¿‡å¯ä½¿ç”¨ä¸€æ¡æŒ‡ä»¤åœ¨å½“å‰ä½“ç³»ç»“æ„ä¸Šå¤åˆ¶çš„æœ€å¤§å¤§å°ã€‚
- æœ€å¤–å±‚åŒ…å« `struct` çš„é•¿åº¦ï¼ˆæˆ–å¦‚æœå®ƒæ˜¯å¯èƒ½åµŒå¥—çš„ `struct` çš„æˆå‘˜ï¼‰è¶…è¿‡å¯ä½¿ç”¨ä¸€æ¡æŒ‡ä»¤åœ¨å½“å‰ä½“ç³»ç»“æ„ä¸Šå¤åˆ¶çš„æœ€å¤§å¤§å°ã€‚

å°½ç®¡å¤„ç†å™¨ä¸ä¼šå¯¹ä¸å¯ç¼“å­˜çš„å†…å­˜è®¿é—®é‡æ–°æ’åºï¼Œä½†å¿…é¡»å°†ä¸å¯ç¼“å­˜çš„å˜é‡æ ‡è®°ä¸º `volatile`ï¼Œä»è€Œä¿è¯æ­¤ç¼–è¯‘å™¨ä¸ä¼šå¯¹å†…å­˜è®¿é—®é‡æ–°æ’åºã€‚

ä¸ `const` ç›¸ä¼¼ï¼Œå¯ä»¥å£°æ˜ `volatile` æˆå‘˜å‡½æ•°ï¼Œ`volatile struct` çš„æ˜“å˜å®ä¾‹åªèƒ½è°ƒç”¨æ˜“å˜æˆå‘˜å‡½æ•°ï¼›æ™®é€šç»“æ„å®ä¾‹å¯ä»¥è°ƒç”¨æ‰€æœ‰æˆå‘˜å‡½æ•°ã€‚

```c++
volatile struct  S {
	int V;
public:
	volatile void Foo(volatile int& V) volatile;
	void Foo(int& V); // é‡è½½
	//void Foo(volatile int V);  // äºŒä¹‰æ€§
	//void Foo(int V);  
};
volatile void S::Foo(volatile int& V) volatile {
	cout << "V Foo&" << endl;
}
void S::Foo(int& V) {
	cout << "Foo&" << endl;
}
int main() {
	volatile auto s = S{ 10 }; 
	volatile auto& vrv = s.V;
	int& rv = ( int&)vrv;
	S s2{};
	s.Foo(vrv);   // call s.Foo volatile
	s2.Foo(vrv);  // V Foo&
	s2.Foo(rv);   // Foo&
}
```


>---
#### decltype å’Œè½¬å‘å‡½æ•°

`decltype` ç±»å‹è¯´æ˜ç¬¦ç”ŸæˆæŒ‡å®šè¡¨è¾¾å¼çš„ç±»å‹ã€‚ä½¿ç”¨ `auto` å’Œ `decltype` å£°æ˜å…¶è¿”å›ç±»å‹å–å†³äºå…¶æ¨¡æ¿è‡ªå˜é‡ç±»å‹çš„å‡½æ•°æ¨¡æ¿ã€‚æˆ–è€…ä½¿ç”¨ `auto` å’Œ `decltype` å£°æ˜ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œç”¨æ¥åŒ…è£…å¯¹å…¶ä»–å‡½æ•°çš„è°ƒç”¨ï¼Œç„¶åè¿”å›åŒ…è£…å‡½æ•°çš„è¿”å›ç±»å‹ã€‚

```c++
//C++11
template<typename T, typename U>
auto myFunc(T&& t, U&& u) -> decltype (forward<T>(t) + forward<U>(u))
        { return forward<T>(t) + forward<U>(u); };

//C++14
template<typename T, typename U>
decltype(auto) myFunc(T&& t, U&& u)
        { return forward<T>(t) + forward<U>(u); };
```

> *è½¬å‘å‡½æ•°* C++11

è½¬å‘å‡½æ•°åŒ…è£…å¯¹å…¶ä»–å‡½æ•°çš„è°ƒç”¨ã€‚è½¬å‘å‡½æ•°çš„è¿”å›ç±»å‹ä¸åŒ…è£…å‡½æ•°çš„è¿”å›ç±»å‹ç›¸åŒã€‚

```c++
#include <iostream>
#include <string>
#include <utility>
#include <iomanip>

using namespace std;

template<typename T1, typename T2>
auto Plus(T1&& t1, T2&& t2) ->
decltype(forward<T1>(t1) + forward<T2>(t2))
{
    return forward<T1>(t1) + forward<T2>(t2);
}
class X
{
    friend X operator+(const X& x1, const X& x2)
    {
        return X(x1.m_data + x2.m_data);
    }

public:
    X(int data) : m_data(data) {}
    int Dump() const { return m_data; }
private:
    int m_data;
};

int main()
{
    // Integer
    int i = 4;
    cout <<
        "Plus(i, 9) = " <<
        Plus(i, 9) << endl;   // Plus(i, 9) = 13

    // Floating point
    float dx = 4.0;
    float dy = 9.5;
    cout <<
        setprecision(3) <<
        "Plus(dx, dy) = " <<
        Plus(dx, dy) << endl;  // Plus(dx, dy) = 13.5

    // String
    string hello = "Hello, ";
    string world = "world!";
    cout << Plus(hello, world) << endl;  // Hello, world!

    // Custom type
    X x1(20);
    X x2(22);
    X x3 = Plus(x1, x2);
    cout <<
        "x3.Dump() = " <<
        x3.Dump() << endl;  // x3.Dump() = 42
}
```

>---
#### ç‰¹æ€§å£°æ˜

C++ æ ‡å‡†å®šä¹‰äº†ä¸€ç»„é€šç”¨å±æ€§ã€‚å±æ€§ä»£è¡¨ `#pragma` æŒ‡ä»¤ã€`__declspec()` (Visual C++) æˆ– `__attribute__` (GNU) ç­‰ä¾›åº”å•†ç‰¹å®šæ‰©å±•çš„æ ‡å‡†åŒ–æ›¿ä»£é¡¹ã€‚æ ‡å‡†å±æ€§åŒ…å«ï¼š
- `[[carries_dependency]]` æŒ‡å®šå‡½æ•°ä¼ æ’­çº¿ç¨‹åŒæ­¥çš„æ•°æ®ä¾èµ–é¡¹é¡ºåºã€‚åº”ç”¨äºä¸€ä¸ªæˆ–å¤šä¸ªå‚æ•°ï¼Œä»¥æŒ‡å®šä¼ å…¥çš„å‚æ•°è¦å°†ä¾èµ–é¡¹å¸¦å…¥å‡½æ•°ä¸»ä½“ä¸­ã€‚ç”¨äºå‡½æ•°æœ¬èº«ä»¥æŒ‡å®šè¿”å›å€¼è¦å°†ä¾èµ–é¡¹å¸¦å‡ºå‡½æ•°ã€‚
- `[[deprecated]]` æŒ‡å®šå‡½æ•°ä¸é€‚åˆä½¿ç”¨ï¼Œè¡¨æ˜å·²å¼ƒç”¨ï¼›åº”ç”¨äºç±»ã€typedef åç§°ã€å˜é‡ã€éé™æ€æ•°æ®æˆå‘˜ã€å‡½æ•°ã€å‘½åç©ºé—´ã€æšä¸¾ã€æšä¸¾å™¨æˆ–æ¨¡æ¿ä¸“ç”¨åŒ–çš„å£°æ˜ã€‚
- [[fallthrough]] å¯åœ¨ `switch` è¯­å¥çš„ä¸Šä¸‹æ–‡ä¸­ç”¨ä½œå‘ç¼–è¯‘å™¨ï¼ˆæˆ–é˜…è¯»ä»£ç çš„ä»»ä½•äººï¼‰æ˜¾ç¤ºçš„æç¤ºï¼ŒæŒ‡å‡ºå¤±è´¥è¡Œä¸ºæ˜¯æœ‰æ„çš„ã€‚
- [[likely]] å‘ç¼–è¯‘å™¨æŒ‡å®šæç¤ºï¼ŒæŒ‡å‡ºå±æ€§åŒ–æ ‡ç­¾æˆ–è¯­å¥çš„ä»£ç è·¯å¾„çš„æ‰§è¡Œå¯èƒ½æ€§é«˜äºæ›¿ä»£é¡¹ã€‚
- [[unlikely]] å‘ç¼–è¯‘å™¨æŒ‡å®šæç¤ºï¼ŒæŒ‡å‡ºå±æ€§åŒ–æ ‡ç­¾æˆ–è¯­å¥çš„ä»£ç è·¯å¾„çš„æ‰§è¡Œå¯èƒ½æ€§ä½äºæ›¿ä»£é¡¹ã€‚
- [[maybe_unused]] æŒ‡å®šå˜é‡ã€å‡½æ•°ã€ç±»ã€*typedef*ã€éé™æ€æ•°æ®æˆå‘˜ã€æšä¸¾æˆ–æ¨¡æ¿ä¸“ç”¨åŒ–å¯èƒ½æ˜¯æœ‰æ„ä¸ä½¿ç”¨çš„ã€‚
- [[nodiscard]] æŒ‡å®šä¸åº”è¯¥ä¸¢å¼ƒå‡½æ•°çš„è¿”å›å€¼ã€‚
- [[noreturn]] æŒ‡å®šå‡½æ•°æ°¸ä¸è¿”å›ï¼›å®ƒå§‹ç»ˆå¼•å‘å¼‚å¸¸æˆ–é€€å‡ºã€‚

```c++
#include <iostream>
#include <utility>
using namespace std;
template<typename T1, typename T2>
[[nodiscard]] auto Plus(T1&& t1, T2&& t2) ->
decltype(forward<T1>(t1) + forward<T2>(t2))
{
	return forward<T1>(t1) + forward<T2>(t2);
}
int main() {
	std::cout << Plus(1, 2) << std::endl;
}

[[noreturn]] void Foo(int exitcode) {
	_Exit(exitcode);
}
```

---
### è¿ç®—ç¬¦ä¸è¡¨è¾¾å¼

C++ è¯­è¨€åŒ…æ‹¬æ‰€æœ‰ C è¿ç®—ç¬¦å¹¶æ·»åŠ å¤šä¸ªæ–°çš„è¿ç®—ç¬¦ã€‚C++ è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å’Œå…³è”æ€§ï¼š

| precedence | operator                     | description        | associativity | alternative |
| :--------- | :--------------------------- | :----------------- | :------------ | :---------- |
| 1          | `::`                         | èŒƒå›´è§£æ           |               |             |
| 2          | `.`,`->`                     | æˆå‘˜é€‰æ‹©           | ä»å·¦åˆ°å³      |             |
| 2          | `[]`                         | æ•°ç»„ç´¢å¼•           | ä»å·¦åˆ°å³      |             |
| 2          | `()`                         | å‡½æ•°è°ƒç”¨           | ä»å·¦åˆ°å³      |             |
| 2          | `++`                         | åç¼€é€’å¢           | ä»å·¦åˆ°å³      |             |
| 2          | `--`                         | åç¼€é€’å‡           | ä»å·¦åˆ°å³      |             |
| 2          | `typeid`                     | ç±»å‹åç§°           | ä»å·¦åˆ°å³      |             |
| 2          | `const_cast`                 | å¸¸é‡ç±»å‹è½¬æ¢       | ä»å·¦åˆ°å³      |             |
| 2          | `dynamic_cast`               | åŠ¨æ€ç±»å‹è½¬æ¢       | ä»å·¦åˆ°å³      |             |
| 2          | `reinterpret_cast`           | é‡æ–°è§£é‡Šçš„ç±»å‹è½¬æ¢ | ä»å·¦åˆ°å³      |             |
| 2          | `static_cast`                | é™æ€ç±»å‹è½¬æ¢       | ä»å·¦åˆ°å³      |             |
| 3          | `sizeof`                     | å¯¹è±¡æˆ–ç±»å‹çš„å¤§å°   | ä»å³åˆ°å·¦      |             |
| 3          | `++`                         | å‰ç¼€é€’å¢           | ä»å³åˆ°å·¦      |             |
| 3          | `--`                         | å‰ç¼€é€’å‡           | ä»å³åˆ°å·¦      |             |
| 3          | `~`                          | äºŒè¿›åˆ¶åç          | ä»å³åˆ°å·¦      | `compl`     |
| 3          | `!`                          | é€»è¾‘ â€œéâ€          | ä»å³åˆ°å·¦      | `not`       |
| 3          | `-`                          | ä¸€å…ƒæ±‚å           | ä»å³åˆ°å·¦      |             |
| 3          | `+`                          | ä¸€å…ƒåŠ              | ä»å³åˆ°å·¦      |             |
| 3          | `&`                          | Address-of         | ä»å³åˆ°å·¦      |             |
| 3          | `*`                          | é—´æ¥å¯»å€           | ä»å³åˆ°å·¦      |             |
| 3          | `new`                        | åˆ›å»ºå¯¹è±¡           | ä»å³åˆ°å·¦      |             |
| 3          | `delete`                     | é”€æ¯å¯¹è±¡           | ä»å³åˆ°å·¦      |             |
| 3          | `typename(V)`, `(typename)V` | å¼ºåˆ¶è½¬æ¢           | ä»å³åˆ°å·¦      |             |
| 4          | `.*`, `->*`                  | æŒ‡å‘æˆå‘˜çš„æŒ‡é’ˆ     | ä»å·¦åˆ°å³      |             |
| 5          | `*`                          | ä¹˜æ³•               | ä»å·¦åˆ°å³      |             |
| 5          | `/`                          | é™¤æ³•               | ä»å·¦åˆ°å³      |             |
| 5          | `%`                          | å–æ¨¡               | ä»å·¦åˆ°å³      |             |
| 6          | `+`                          | åŠ æ³•               | ä»å·¦åˆ°å³      |             |
| 6          | `-`                          | å‡æ³•               | ä»å·¦åˆ°å³      |             |
| 7          | `<<`                         | å·¦ç§»               | ä»å·¦åˆ°å³      |             |
| 7          | `>>`                         | å³ç§»               | ä»å·¦åˆ°å³      |             |
| 8          | `<`                          | å°äº               | ä»å·¦åˆ°å³      |             |
| 8          | `>`                          | å¤§äº               | ä»å·¦åˆ°å³      |             |
| 8          | `<=`                         | å°äºæˆ–ç­‰äº         | ä»å·¦åˆ°å³      |             |
| 8          | `>=`                         | å¤§äºæˆ–ç­‰äº         | ä»å·¦åˆ°å³      |             |
| 9          | `==`                         | ç­‰å¼               | ä»å·¦åˆ°å³      |             |
| 9          | `!=`                         | ä¸ç›¸ç­‰             | ä»å·¦åˆ°å³      | `not_eq`    |
| 10         | `&`                          | æŒ‰ä½ â€œä¸â€          | ä»å·¦åˆ°å³      | `bitand`    |
| 11         | `^`                          | æŒ‰ä½ â€œå¼‚æˆ–â€        | ä»å·¦åˆ°å³      | `xor`       |
| 12         | `` \| ``                     | æŒ‰ä½ â€œä¸æˆ–â€        | ä»å·¦åˆ°å³      | `bitor`     |
| 13         | `&&`                         | é€»è¾‘ä¸             | ä»å·¦åˆ°å³      | `and`       |
| 14         | `\|\|`                       | é€»è¾‘æˆ–             | ä»å·¦åˆ°å³      | `or`        |
| 15         | `? :`                        | æ¡ä»¶               | ä»å³åˆ°å·¦      |             |
| 15         | `=`                          | èµ‹å€¼               | ä»å³åˆ°å·¦      |             |
| 15         | `*=`                         | ä¹˜æ³•èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `/=`                         | é™¤æ³•èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `%=`                         | å–æ¨¡èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `+=`                         | åŠ æ³•èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `-=`                         | å‡æ³•èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `<<=`                        | å·¦ç§»èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `>>=`                        | å³ç§»èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `&=`                         | æŒ‰ä½ â€œä¸â€ èµ‹å€¼     | ä»å³åˆ°å·¦      | `and_eq`    |
| 15         | `\|=`                        | æŒ‰ä½ â€œä¸æˆ–â€ èµ‹å€¼   | ä»å³åˆ°å·¦      | `or_eq`     |
| 15         | `^=`                         | æŒ‰ä½ â€œå¼‚æˆ–â€ èµ‹å€¼   | ä»å³åˆ°å·¦      | `xor_eq`    |
| 15         | `throw`                      | å¼•å‘è¡¨è¾¾å¼         | ä»å³åˆ°å·¦      |             |
| 16         | `,`                          | é¡ºåºè¿ç®—           | ä»å·¦åˆ°å³      |             |
	         	
>---
#### alignof å¯¹é½

`alignof` æŒ‡å®šç±»å‹çš„å¯¹é½æ–¹å¼ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ä½œä¸ºç±»å‹ `size_t` çš„å€¼è¿”å›ï¼›å¸¸ä½œä¸ºæŸä¸ªå†…å­˜åˆ†é…ä¾‹ç¨‹çš„å‚æ•°å‡ºç°ã€‚

```c++
typedef alignas(32) struct { int a; double b; } S;
int n = 50; // array size
S* p = (S*)aligned_malloc(n * sizeof(S), alignof(S));
```

å¯ä»¥ä½¿ç”¨ `#pragma pack`ã€`alignas` ä¿®æ”¹ç±»å‹å¯¹è±¡çš„å¯¹é½æ–¹å¼ï¼›

```c++
#include <stddef.h>
#include <stdio.h>

struct S {
	int i;      // size 4
	short j;    // size 2
	double k;   // size 8
};

#pragma pack(2)
struct T {
	int i;
	short j;
	double k;
};
#pragma pack(0)  // æ¢å¤é»˜è®¤
int main() {
	printf("alignof(S) %zu ", alignof(S));  // 8
	printf("sizeof(S) %zu ", sizeof(S));  // 16
	printf("%zu ", offsetof(S, i));  // 0
	printf("%zu ", offsetof(S, j));  // 4 
	printf("%zu\n", offsetof(S, k)); // 8

	printf("alignof(T) %zu ", alignof(T));  // 2
	printf("sizeof(T) %zu ", sizeof(T));  // 14
	printf("%zu ", offsetof(T, i));  // 0
	printf("%zu ", offsetof(T, j));  // 4
	printf("%zu\n", offsetof(T, k)); // 6
}
```

>---
#### ç®—æ•°è¿ç®—

```c++
auto add = a + b;
auto sub = a - b;
auto mul = a * b;
auto div = a / b;
auto mod = a & b;   // integer
auto post = +a;
auto nega = -a;
```

åœ¨ Microsoft C++ ä¸­ï¼Œå–æ¨¡è¡¨è¾¾å¼çš„ç»“æœçš„ç¬¦å·å§‹ç»ˆä¸ç¬¬ä¸€ä¸ªæ“ä½œæ•°çš„ç¬¦å·ç›¸åŒã€‚

>---
#### å¢é‡å‡é‡è¿ç®—

```c++
i++;  // åç¼€é€’å¢
i--;  // åç¼€é€’å‡
++i;  // å‰ç¼€é€’å¢
--i;  // åç¼€é€’å¢
```

æ— æ³•ä¿è¯åç¼€è¿ç®—ä½œä¸ºå‡½æ•°æˆ–è¡¨è¾¾å¼å‚æ•°æŒ‰æœŸæœ›çš„å€¼è¿›è¡Œä¼ é€’ï¼›å‰¯ä½œç”¨å¯èƒ½å‘ç”Ÿåœ¨è¡¨è¾¾å¼æ±‚å€¼æˆ–å‚æ•°æ±‚å€¼ä¹‹åã€‚å‰ç¼€è¿ç®—çš„å‰¯ä½œç”¨å‘ç”Ÿåœ¨ä½œä¸ºä¼ é€’å‚æ•°æˆ–èµ‹å€¼ç­‰æ“ä½œä¹‹å‰ï¼›

```c++
int i = 10;  // or float
cout << i++ << endl;  // 10
cout << i << endl;    // 11
cout << --i << endl;  // 10
```

ä¸æ”¯æŒç›´æ¥å¯¹æšä¸¾ç±»å‹æˆ–å…¶ä»–ç”¨æˆ·å®šä¹‰ç±»å‹æ‰§è¡Œå‰ç¼€æˆ–åç¼€è¿ç®—ï¼›å¯ä»¥è®¾ç½®ç”¨æˆ·å®šä¹‰è¿ç®—ç¬¦ï¼š

```c++
enum Compass { North, South, East, West };
Compass myCompass;
for( myCompass = North; myCompass != West; myCompass++ ) // Error
    ;

Compass& operator++(Compass& c) {
	c = static_cast<Compass>(c + 1);
	return c;
}  // å‰ç¼€é€’å¢
Compass& operator--(Compass& c) {
	c = static_cast<Compass>(c - 1);
	return c;
}  // å‰ç¼€é€’å‡
Compass operator++(Compass& c, int i) {
	c = static_cast<Compass>(c + i);
	return c;
}  // åç¼€é€’å¢
Compass operator--(Compass& c, int i) {
	c = static_cast<Compass>(c - i);
	return c;
}  // åç¼€é€’å‡

Compass myCompass;
for (myCompass = North; myCompass != West; myCompass++) // ok
	;
for (myCompass = North; myCompass != West; ++myCompass) // ok
	;
```

>---
#### Address-of

*Address-of* è¿ç®—ç¬¦ (`&`) è¿”å›å…¶æ“ä½œæ•°çš„åœ°å€ï¼›æ“ä½œæ•°æ˜¯å‡½æ•°æŒ‡ç¤ºç¬¦ï¼Œæˆ–å¼•ç”¨éä½å­—æ®µå¯¹è±¡çš„ *lvalue*ï¼ˆåŸºæœ¬ç±»å‹ã€ç»“æ„ã€ç±»æˆ–è”åˆçš„å˜é‡ï¼Œæˆ–ä¸‹æ ‡æ•°ç»„å¼•ç”¨ï¼‰ã€‚ä»…å½“æ˜ç¡®è¦å¼•ç”¨çš„å‡½æ•°çš„ç‰ˆæœ¬æ—¶ï¼Œæ‰èƒ½é‡‡ç”¨é‡è½½å‡½æ•°çš„åœ°å€ã€‚

åº”ç”¨äºé™å®šåæ—¶ï¼Œç»“æœå°†å–å†³äºé™å®šåç§°æ˜¯å¦æŒ‡å®šé™æ€æˆå‘˜ï¼Œåˆ™ç»“æœä¸ºæŒ‡å‘æˆå‘˜ç±»å‹çš„æŒ‡é’ˆã€‚å¯¹äºéé™æ€æˆå‘˜ï¼Œåˆ™ç»“æœä¸ºæŒ‡å‘ç”±é™å®šåç§°æŒ‡ç¤ºçš„ç±»çš„æˆå‘˜åç§°çš„æŒ‡é’ˆã€‚

```c++
class PTM {
public:
    int iValue;
    static float fValue;
};

int main() {
   int   PTM::*piValue = &PTM::iValue;  // OK: non-static
   float PTM::*pfValue = &PTM::fValue;  // error: static
   float *spfValue     = &PTM::fValue;  // OK
// ç”±äº `fValue` æ˜¯é™æ€æˆå‘˜ï¼Œå› æ­¤è¡¨è¾¾å¼ `&PTM::fValue` äº§ç”Ÿ
// ç±»å‹ `float *` è€Œä¸æ˜¯ç±»å‹ `float PTM::*`ã€‚
}
```

>---
#### Size-of

```c++
sizeof ( type-name );
sizeof unary-expr; 
sizeof ( unary-expr ); 
```

`sizeof` è¿”å›ç»™å®š `type-name` æˆ–ä¸€ä¸ªä¸€å…ƒè¡¨è¾¾å¼çš„å­—èŠ‚å¤§å°ï¼›ç»“æœä¸º `size_t`ã€‚`sizeof` æ˜¯ä¸æ±‚å€¼è¡¨è¾¾å¼ã€‚

å½“ `sizeof` è¿ç®—ç¬¦åº”ç”¨äº `class`ã€`struct` æˆ– `union` ç±»å‹æ—¶ï¼Œç»“æœæ˜¯è¯¥ç±»å‹å¯¹è±¡ä¸­çš„å­—èŠ‚æ•°ï¼ŒåŠ ä¸Šä¸ºå¯¹é½å­—è¾¹ç•Œä¸Šçš„æˆå‘˜è€Œæ·»åŠ çš„ä»»ä½•å¡«å……ã€‚ç»“æœä¸ä¸€å®šå¯¹åº”äºé€šè¿‡å°†å„ä¸ªæˆå‘˜çš„å­˜å‚¨éœ€æ±‚ç›¸åŠ è®¡ç®—å‡ºçš„å¤§å°ã€‚ä¸è®¡ç®—ç»“æ„ä¸­çµæ´»æ•°ç»„çš„å¤§å°ã€‚

`type-name` ä¸èƒ½æ˜¯å‡½æ•°ã€ä½åŸŸã€æœªå®šä¹‰ç±»ã€`void`ã€åŠ¨æ€åˆ†é…çš„æ•°ç»„ã€å¤–éƒ¨æ•°ç»„ã€ä¸å®Œæ•´ç±»å‹æˆ–ä¸å®Œæ•´ç±»å‹åç§°ã€‚

```c++
sizeof(ClassA);
sizeof(int);
sizeof ptr;
auto arrLength = sizeof array / sizeof array[0]
```

>---
#### æˆå‘˜è®¿é—®

```c++
struct X
{
	void m_func() {
		cout << m_num << endl;
	};
	int m_num;
};
int main() {
	// å‡½æ•°æˆå‘˜æŒ‡é’ˆ
	void (X:: * pxfun)() = &X::m_func;
	int X::* pxnum = &X::m_num;

	X x{0};
	X* px = new X;
	
	// . -> è®¿é—®
	x.m_num = 10;
	x.m_func();
	px->m_num = 100;
	px->m_func();

	// .* ->* æˆå‘˜æŒ‡é’ˆè®¿é—®
	(x.*pxfun)();  // 10
	x.*pxnum = -10;
	(px->*pxfun)(); // 100
	//px->*pxnum = -100;
}
```

>---
#### èŒƒå›´è§£æ

èŒƒå›´è§£æè¿ç®—ç¬¦ `::` ç”¨äºæ ‡è¯†å’Œæ¶ˆé™¤åœ¨ä¸åŒèŒƒå›´å†…ä½¿ç”¨çš„æ ‡è¯†ç¬¦ã€‚`:: qualified-id` è¡¨ç¤ºä»å…¨å±€èŒƒå›´æŸ¥æ‰¾ã€‚

```c++
namespace NamespaceB {
    class ClassB {
    public:
        int x;
    };
}
namespace NamespaceC{
    using namespace NamespaceB;
}
int main() {
    NamespaceB::ClassB b_b;
    NamespaceC::ClassB c_b;
    b_b.x = 3;
    c_b.x = 4;
}
```

å¿…é¡»ä½¿ç”¨èŒƒå›´è§£æè¿ç®—ç¬¦æ¥è°ƒç”¨ç±»çš„é™æ€æˆå‘˜ã€‚

```c++
class ClassG {
public:
    static int get_x() { return x;}
    static int x;
};

int ClassG::x = 6;
int main() {
    int gx1 = ClassG::x;
    int gx2 = ClassG::get_x();
}
```

èŒƒå›´è§£æè¿ç®—ç¬¦è¿˜å¯ä»¥ä¸åŒºåˆ†èŒƒå›´çš„æšä¸¾å€¼ä¸€èµ·ä½¿ç”¨ï¼š

```c++
enum class EnumA{
    First, Second, Third
};

EnumA enum_value = EnumA::First;
```

>---
#### èµ‹å€¼è¿ç®—

```c
int a = b;  
int a += b; // a = a + b
int a -= b;
int a *= b;
int a /= b;
int a %= b;
int a <<= b;
int a >>= b;
int a &= b;  // a = a and_eq b
int a ^= b;  // a = a or_eq  b
int a |= b;  // a = a xor_eq b
```

`const` å’Œ `volatile` ç±»å‹çš„å¯¹è±¡å¯ä»¥èµ‹ç»™ä»…ä¸º `volatile` æˆ–ä¸ä¸º `const` æˆ– `volatile` çš„ç±»å‹çš„å·¦å€¼ã€‚

å¯¹ç±»ç±»å‹ï¼ˆ`struct`ã€`union` å’Œ `class` ç±»å‹ï¼‰çš„å¯¹è±¡çš„èµ‹å€¼ç”± `operator=` å‡½æ•°æ‰§è¡Œã€‚é»˜è®¤è¡Œä¸ºæ˜¯å°†æ‰§è¡Œå¯¹è±¡çš„éé™æ€æ•°æ®æˆå‘˜å’Œç›´æ¥åŸºç±»çš„é€ä¸ªæˆå‘˜å¤åˆ¶èµ‹å€¼ï¼›ä»»ä½•ä»ç»™å®šåŸºç±»æ˜ç¡®æ´¾ç”Ÿçš„ç±»çš„å¯¹è±¡å‡å¯èµ‹ç»™åŸºç±»çš„å¯¹è±¡ã€‚

åœ¨ ANSI C ä¸­ï¼Œèµ‹å€¼è¡¨è¾¾å¼çš„ç»“æœä¸æ˜¯å·¦å€¼ã€‚ è¿™æ„å‘³ç€ C ä¸­ä¸å…è®¸ä½¿ç”¨åˆæ³•çš„ C++ è¡¨è¾¾å¼ `(a += b) += c`ã€‚

>---
#### æŒ‰ä½è¿ç®—

```c++
unsigned char a = 0b10100101;
unsigned char b = 0b11000011;
auto print = [=](unsigned char expr) {
	char s[64];
	_itoa_s(expr, s, 64, 2);
	printf("%08.8s\n", s);
	};
print(a & b);  // 10000001; æŒ‰ä½ä¸
print(a | b);  // 11100111; æŒ‰ä½æˆ–
print(a ^ b);  // 01100110; æŒ‰ä½å¼‚æˆ–
print(~a);     // 01011010; æŒ‰ä½æ±‚è¡¥
```

>---
#### ç§»ä½è¿ç®—

`<<` å·¦ç§»ç”¨é›¶è¡¥é½ä½ä½ï¼Œæ˜¯é€»è¾‘ç§»ä½ï¼›`>>` å³ç§»æ—¶ï¼Œæ— ç¬¦å·æ•°é›¶è¡¥é½é«˜ä½ï¼Œæœ‰ç¬¦å·æ•°ç¬¦å·ä½è¡¥é½é«˜ä½ (Microsoft C++ è¡Œä¸º)ã€‚

```c++
unsigned char c1 = 64;
cout << bitset<8>{ (unsigned __int64)c1 } << endl;		// 01000000
cout << bitset<8>{ (unsigned __int64)c1 << 1} << endl;	// 10000000
cout << bitset<8>{ (unsigned __int64)c1 >> 2 } << endl;	// 00010000

signed char c2 = -55;
cout << bitset<8>{ (unsigned __int64)c2 } << endl;		// 11001001
cout << bitset<8>{ (unsigned __int64)c2 << 3} << endl;	// 01001000
cout << bitset<8>{ (unsigned __int64)c2 >> 2 } << endl;	// 11110010
```

>---
#### å¼ºåˆ¶è½¬æ¢

`()` è¿ç®—ç¬¦æä¾›äº†ç”¨äºæ˜¾å¼è½¬æ¢å¯¹è±¡ç±»å‹çš„æ–¹æ³•ã€‚

```c++
typeA a = (typeA)vb;   // cast å½¢å¼çš„å¼ºåˆ¶ç±»å‹è½¬æ¢
typeA a = typeA(vb);   // æ˜¾å¼ç±»å‹è½¬æ¢
```

ç”¨æˆ·å®šä¹‰çš„å¼ºåˆ¶è½¬æ¢ `operator type ()`ï¼š

```c++
struct KM {
	long double distance;
public:
	KM() { distance = 0; };
	KM(long double dis) { distance = dis; };
	operator long double() { return distance; }   // user-defned cast
	KM operator=(int dis) { return KM{ (long double)dis }; }
	KM operator=(long double dis) { return KM{ dis }; }
	KM operator=(unsigned long long dis) { return KM{ (long double)dis }; }
};
KM operator ""km(long double dis) {
	return KM{ dis };
};
KM operator ""km(unsigned long long dis) {
	return KM{ (long double)dis };
};

int main() {
	KM d1 = 10km;    // int to KM
	KM d2 = 3.14km;  // double to KM
	KM d3 = 10;
	KM d4 = 3.14L;
	long double d = d1;  // or (long double)d1;
}
```

`cast` è¯­æ³•åªèƒ½ä»å•ä¸ªå€¼è½¬æ¢ï¼Œåœ¨å¼ºåˆ¶è½¬æ¢ä¸­çš„ç±»å‹å®šä¹‰æ˜¯éæ³•çš„ã€‚æ˜¾å¼ç±»å‹è½¬æ¢å¯ä»¥è½¬æ¢æŒ‡å®šå¤šä¸ªè‡ªå˜é‡ï¼Œä¾‹å¦‚ï¼š

```c++
struct Point { int x, y; };
Point p = Point(1, 2);
```

æœ‰å‡ ç§ç‰¹å®šäº C++ è¯­è¨€çš„è½¬æ¢è¿ç®—ç¬¦ã€‚

```c++
// æ“ä½œæ•° expression è½¬æ¢ä¸º type-id ç±»å‹çš„å¯¹è±¡;
dynamic_cast < type-id > ( expression )   

// ä»…æ ¹æ®è¡¨è¾¾å¼ä¸­å­˜åœ¨çš„ç±»å‹ï¼Œå°† expression è½¬æ¢ä¸º type-id ç±»å‹
static_cast <type-id> ( expression )    

// ä»æŸä¸ªç±»åˆ é™¤ constã€volatile å’Œ __unaligned å±æ€§ã€‚
const_cast <type-id> (expression)          

// å…è®¸å°†ä»»ä½•æŒ‡é’ˆè½¬æ¢ä¸ºä»»ä½•å…¶ä»–æŒ‡é’ˆç±»å‹ã€‚ä¹Ÿå…è®¸å°†ä»»ä½•æ•´æ•°ç±»å‹è½¬æ¢ä¸ºä»»ä½•æŒ‡é’ˆç±»å‹ä»¥åŠåå‘è½¬æ¢ã€‚
reinterpret_cast < type-id > ( expression )  
```

> *dynamic_cast*

`dynamic_cast` ç”¨äºå¤šæ€ç±»å‹çš„è½¬æ¢ã€‚`type-id` æ˜¯ç±»ç±»å‹çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œæˆ–è€…æ˜¯ `void*`ï¼›

æ‰˜ç®¡ä»£ç ä¸­çš„ `dynamic_cast` è¡Œä¸ºæœ‰ä¸¤é¡¹ä¸­æ–­æ€§å˜æ›´ï¼š
  - å¯¹æŒ‡å‘è£…ç®±æšä¸¾çš„åŸºç¡€ç±»å‹çš„æŒ‡é’ˆçš„ dynamic_cast å°†åœ¨è¿è¡Œæ—¶å¤±è´¥ï¼Œè¿”å› 0 è€Œä¸æ˜¯è½¬æ¢åçš„æŒ‡é’ˆã€‚
  - å½“ `type-id` æ˜¯æŒ‡å‘å€¼ç±»å‹çš„å†…éƒ¨æŒ‡é’ˆæ—¶ï¼Œ`dynamic_cast` å°†ä¸å†å¼•å‘å¼‚å¸¸ï¼Œå¤±è´¥è¿”å›ç©ºæŒ‡é’ˆå€¼ï¼›å¼ºåˆ¶è½¬æ¢åœ¨è¿è¡Œæ—¶å¤±è´¥ã€‚

å¦‚æœ `type-id` æ˜¯æŒ‡å‘ `expression` çš„æ˜ç¡®å¯è®¿é—®çš„ç›´æ¥æˆ–é—´æ¥åŸºç±»çš„æŒ‡é’ˆï¼Œåˆ™ç»“æœæ˜¯æŒ‡å‘ `type-id` ç±»å‹çš„å”¯ä¸€å­å¯¹è±¡çš„æŒ‡é’ˆã€‚

```c++
class B { };
class C : public B { };
class D : public C { };

D* pd = new D;
C* pc = dynamic_cast<C*>(pd);   
// ok: C is a direct base class, pc points to C subobject of pd
B* pb = dynamic_cast<B*>(pd);  
// ok: B is an indirect base class, pb points to B subobject of pd
```

å¦‚æœ `type-id` æ˜¯ `void*`ï¼Œåˆ™è¿›è¡Œè¿è¡Œæ—¶æ£€æŸ¥ä»¥ç¡®å®š `expression` çš„å®é™…ç±»å‹ã€‚ç»“æœæ˜¯æŒ‡å‘ç”± `expression` æŒ‡å‘çš„å®Œæ•´å¯¹è±¡çš„æŒ‡é’ˆã€‚

```c++
class A {virtual void f();};
class B {virtual void f();};

A* pa = new A;
B* pb = new B;
void* pv = dynamic_cast<void*>(pa);  // pv now points to an object of type A
pv = dynamic_cast<void*>(pb);        // pv now points to an object of type B
```
  
å¦‚æœ `type-id` ä¸æ˜¯ `void*`ï¼Œåˆ™è¿›è¡Œè¿è¡Œæ—¶æ£€æŸ¥ï¼Œçœ‹çœ‹æ˜¯å¦å¯ä»¥å°† `expression` æŒ‡å‘çš„å¯¹è±¡è½¬æ¢ä¸º `type-id` æŒ‡å‘çš„ç±»å‹ã€‚
  
å¦‚æœ `expression` çš„ç±»å‹æ˜¯ `type-id` ç±»å‹çš„åŸºç±»ï¼Œåˆ™è¿›è¡Œè¿è¡Œæ—¶æ£€æŸ¥ï¼Œçœ‹çœ‹ `expression` æ˜¯å¦å®é™…æŒ‡å‘ `type-id` ç±»å‹çš„å®Œæ•´å¯¹è±¡ã€‚å¦‚æœæ˜¯ï¼Œåˆ™ç»“æœæ˜¯æŒ‡å‘ `type-id` ç±»å‹çš„å®Œæ•´å¯¹è±¡çš„æŒ‡é’ˆã€‚

```c++
class B {virtual void f();};
class D : public B {virtual void f();};

B* pb = new D;   // unclear but ok
B* pb2 = new B;
D* pd = dynamic_cast<D*>(pb);     // ok: pb actually points to a D
D* pd2 = dynamic_cast<D*>(pb2);   // not ok: pb2 points to a B not a D
```

å¦‚æœæœ‰å¤šé‡ç»§æ‰¿ï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸æ˜ç¡®ã€‚ä½¿ç”¨è™šæ‹ŸåŸºç±»æ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ›´å¤šä¸æ˜ç¡®çš„æƒ…å†µã€‚

```c++
class A { virtual void f(); };
class B : public A { virtual void f(); };
class C : public A { virtual void f(); };
class D : public B, public C { virtual void f(); };

D* pd = new D;
A* pa = dynamic_cast<A*>(pd);   // C4540, ambiguous cast fails at runtime

// æŒ‡å‘ `D` ç±»å‹å¯¹è±¡çš„æŒ‡é’ˆå¯ä»¥å®‰å…¨åœ°å¼ºåˆ¶è½¬æ¢ä¸º `B` æˆ– `C`ã€‚ä½†æ˜¯ï¼Œå¦‚æœ `D` å¼ºåˆ¶
// è½¬æ¢ä¸ºæŒ‡å‘ `A` å¯¹è±¡çš„æŒ‡é’ˆï¼Œä¼šäº§ç”Ÿ `A` çš„å“ªä¸ªå®ä¾‹ï¼Ÿ è¿™å°†å¯¼è‡´ä¸æ˜ç¡®çš„å¼ºåˆ¶è½¬æ¢é”™è¯¯ã€‚
// è‹¥è¦è§£å†³æ­¤é—®é¢˜ï¼Œå¯ä»¥æ‰§è¡Œä¸¤ä¸ªæ˜ç¡®çš„å¼ºåˆ¶è½¬æ¢ã€‚
B* pb = dynamic_cast<B*>(pd);   // first cast to B
A* pa2 = dynamic_cast<A*>(pb);  // ok: unambiguous
```

æœªèƒ½å¼ºåˆ¶è½¬æ¢ä¸ºæŒ‡é’ˆç±»å‹çš„å€¼æ˜¯ç©ºæŒ‡é’ˆã€‚å¦‚æœå¯¹å¼•ç”¨ç±»å‹çš„å¼ºåˆ¶è½¬æ¢å¤±è´¥ï¼Œä¼šå¼•å‘ `bad_cast` å¼‚å¸¸ã€‚ å¦‚æœ `expression` æ²¡æœ‰æŒ‡å‘æˆ–å¼•ç”¨æœ‰æ•ˆå¯¹è±¡ï¼Œåˆ™ä¼šå¼•å‘ `__non_rtti_object` å¼‚å¸¸ã€‚

```c++
class A { virtual void g() {} };
class B { virtual void f() {} };

int main() {
	A* pa = new A;
	try {
		B* pb = dynamic_cast<B*>(pa);   // fails at runtime, not safe;  
		// B not derived from A; pb is null
		B& rb = dynamic_cast<B&>(*pa);  // Bad dynamic_cast!
	}
	catch (bad_cast e) {
		cout <<  e.what() << endl;  
	}
}
```

> *static_cast*

`static_cast` ç”¨äºéå¤šæ€ç±»å‹çš„è½¬æ¢ã€‚å¯ç”¨äºå°†æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆè½¬æ¢ä¸ºæŒ‡å‘æ´¾ç”Ÿç±»çš„æŒ‡é’ˆç­‰æ“ä½œï¼Œä½†éå§‹ç»ˆå®‰å…¨ã€‚é€šå¸¸ä½¿ç”¨ `static_cast` è½¬æ¢æ•°å€¼æ•°æ®ç±»å‹ï¼Œä¾‹å¦‚å°†æšä¸¾å‹è½¬æ¢ä¸ºæ•´å‹æˆ–å°†æ•´å‹è½¬æ¢ä¸ºæµ®ç‚¹å‹ã€‚

`static_cast` è½¬æ¢å®‰å…¨æ€§ä¸å¦‚ `dynamic_cast` è½¬æ¢ï¼Œå› ä¸º `static_cast` ä¸æ‰§è¡Œè¿è¡Œæ—¶ç±»å‹æ£€æŸ¥ã€‚

```c++
class B {};
class D : public B { int V; };

B b{};
B* pb = &b; 
D* pd = static_cast<D*>(pb);   // Not safe, D can have fields
```

ä¸ `dynamic_cast` ä¸åŒï¼Œ`pb` çš„ `static_cast` è½¬æ¢ä¸æ‰§è¡Œè¿è¡Œæ—¶æ£€æŸ¥ã€‚ç”± `pb` æŒ‡å‘çš„å¯¹è±¡å¯èƒ½ä¸æ˜¯ `D` ç±»å‹çš„å¯¹è±¡ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ä½¿ç”¨ `*pd` ä¼šæ˜¯ç¾éš¾æ€§çš„ã€‚

```c++
class B {
public:
	virtual void Test() {}  // å¤šæ€ç±»å‹
};
class D : public B {};

int main() {
	B b{};
	B* pb = &b;

	// D* pd1 = pb; // not allowed  
	D* pd1 = dynamic_cast<D*>(pb);
	D* pd2 = static_cast<D*>(pb);
}
```

å¦‚æœ `pb` ç¡®å®æŒ‡å‘ `D` ç±»å‹çš„å¯¹è±¡ï¼Œåˆ™ `pd1` å’Œ `pd2` å°†è·å–ç›¸åŒçš„å€¼ã€‚å¦‚æœ `pb == 0`ï¼Œå®ƒä»¬ä¹Ÿå°†è·å–ç›¸åŒçš„å€¼ã€‚

å¦‚æœ `pb` æŒ‡å‘ `B` ç±»å‹çš„å¯¹è±¡ï¼Œè€ŒéæŒ‡å‘å®Œæ•´çš„ `D` ç±»å‹ï¼Œåˆ™ `dynamic_cast` è¶³ä»¥åˆ¤æ–­è¿”å›é›¶ã€‚ä½†æ˜¯ï¼Œ`static_cast` ä¾èµ–äºæ–­è¨€ï¼Œå‡å®š `pb` æŒ‡å‘ `D` ç±»å‹çš„å¯¹è±¡ï¼›`static_cast` å¯ä»¥åå‘æ‰§è¡Œéšå¼è½¬æ¢ï¼Œè€Œåœ¨è¿™ç§æƒ…å†µä¸‹ç»“æœæ˜¯ä¸ç¡®å®šçš„ã€‚è¿™éœ€è¦ç¨‹åºå‘˜æ¥éªŒè¯ `static_cast` è½¬æ¢çš„ç»“æœæ˜¯å¦å®‰å…¨ã€‚

```c++
	assert(pd1 == nullptr);  // ok
	assert(pd2 == pd1);  // assert failed
```

è¯¥è¡Œä¸ºä¹Ÿé€‚ç”¨äºç±»ä»¥å¤–çš„ç±»å‹ã€‚ ä¾‹å¦‚ï¼Œ`static_cast` å¯ç”¨äºå°† `int` è½¬æ¢ä¸º `char`ã€‚ä½†æ˜¯ï¼Œå¾—åˆ°çš„ `char` å¯èƒ½æ²¡æœ‰è¶³å¤Ÿçš„ä½æ¥ä¿å­˜æ•´ä¸ª `int` å€¼ã€‚åŒæ ·ï¼Œè¿™éœ€è¦ç¨‹åºå‘˜æ¥éªŒè¯ `static_cast` è½¬æ¢çš„ç»“æœæ˜¯å¦å®‰å…¨ã€‚

`static_cast` è¿ç®—ç¬¦è¿˜å¯ç”¨äºæ‰§è¡Œä»»ä½•éšå¼è½¬æ¢ï¼ŒåŒ…æ‹¬æ ‡å‡†è½¬æ¢å’Œç”¨æˆ·å®šä¹‰çš„è½¬æ¢ã€‚

```c++
typedef unsigned char BYTE;

void f() {
   char ch;
   int i = 65;
   float f = 2.5;
   double dbl;

   ch = static_cast<char>(i);      // int to char
   dbl = static_cast<double>(f);   // float to double
   i = static_cast<BYTE>(ch);
}
```

`static_cast` è¿ç®—ç¬¦å¯ä»¥å°†æ•´æ•°å€¼æ˜¾å¼è½¬æ¢ä¸ºæšä¸¾ç±»å‹ã€‚å¦‚æœæ•´å‹å€¼ä¸åœ¨æšä¸¾å€¼çš„èŒƒå›´å†…ï¼Œç”Ÿæˆçš„æšä¸¾å€¼æ˜¯ä¸ç¡®å®šçš„ã€‚è¿ç®—ç¬¦å¯ä»¥å°†ç©ºæŒ‡é’ˆå€¼è½¬æ¢ä¸ºç›®æ ‡ç±»å‹çš„ç©ºæŒ‡é’ˆå€¼ã€‚

ä»»ä½•è¡¨è¾¾å¼éƒ½å¯ä»¥é€šè¿‡ `static_cast` è¿ç®—ç¬¦æ˜¾å¼è½¬æ¢ä¸º `void` ç±»å‹ã€‚ç›®æ ‡ `void` ç±»å‹å¯ä»¥é€‰æ‹©æ€§åœ°åŒ…å« `const`ã€`volatile` æˆ– `__unaligned` ç‰¹æ€§ã€‚`static_cast` è¿ç®—ç¬¦æ— æ³•å¼ºåˆ¶è½¬æ¢æ‰ `const`ã€`volatile` æˆ– `__unaligned` ç‰¹æ€§ã€‚

```c++
enum E {
	a,b,c,d,
};
void main() {
	//E a = 0;  // not assigned to
	const E a = static_cast<E>(0);  // ok; == E::a
	assert(a == E::a);  // assert success
}
```

> *const_cast*

`const_cast` ç”¨äºåˆ é™¤ `const`ã€`volatile` å’Œ `__unaligned` ç‰¹æ€§ã€‚æŒ‡å‘ä»»ä½•å¯¹è±¡ç±»å‹æˆ–æ•°æ®æˆå‘˜çš„ `const`ã€`volatile`ã€`__unaligned` æŒ‡é’ˆå¯æ˜¾å¼è½¬æ¢ä¸ºå®Œå…¨ç›¸åŒçš„åŸå§‹ç±»å‹ï¼›ç»“æœå°†å¼•ç”¨åŸå§‹å¯¹è±¡æˆ–æ•°æ®æˆå‘˜çš„åŸå§‹å¯¹è±¡ã€‚æ ¹æ®å¼•ç”¨å¯¹è±¡çš„ç±»å‹ï¼Œé€šè¿‡ç”Ÿæˆçš„æŒ‡é’ˆã€å¼•ç”¨æˆ–æŒ‡å‘æ•°æ®æˆå‘˜çš„æŒ‡é’ˆçš„å†™å…¥æ“ä½œå¯èƒ½äº§ç”Ÿæœªå®šä¹‰çš„è¡Œä¸ºã€‚

`const_cast` ä¹Ÿå¯ä»¥å°†ä¸€ä¸ªç©ºæŒ‡é’ˆå€¼è½¬æ¢ä¸ºå…¶ä»–ç›®æ ‡ç±»å‹çš„ç©ºæŒ‡é’ˆå€¼ã€‚ä¸èƒ½ä½¿ç”¨ `const_cast` è¿ç®—ç¬¦ç›´æ¥é‡å†™ `constexpr` å˜é‡çš„å¸¸é‡çŠ¶æ€ã€‚

```c++
int number = 10010;
const int& ref_number = number;
int& v = const_cast<int&>(ref_number);
v = 110; 
assert(v == number);  // assert success; both are 110

constexpr int c_number = 10086;
const int& ref_c_number = c_number;
v = const_cast<int&>(ref_c_number);
v = 911;
assert(v == c_number); // failed; c_number = 10086
```

> *reinterpret_cast* 

`reinterpret_cast` ç”¨äºå¯¹ä½è¿›è¡Œç®€å•çš„é‡æ–°è§£é‡Šã€‚å…è®¸å°†ä»»ä½•æŒ‡é’ˆè½¬æ¢ä¸ºä»»ä½•å…¶ä»–æŒ‡é’ˆç±»å‹ï¼Œä¹Ÿå…è®¸å°†ä»»ä½•æ•´æ•°ç±»å‹è½¬æ¢ä¸ºä»»ä½•æŒ‡é’ˆç±»å‹ä»¥åŠåå‘è½¬æ¢ã€‚

æ»¥ç”¨ `reinterpret_cast` è¿ç®—ç¬¦å¯èƒ½å¾ˆå®¹æ˜“å¸¦æ¥é£é™©ã€‚`reinterpret_cast` è¿ç®—ç¬¦å¯ç”¨äº `char*` åˆ° `int*` æˆ– `One_class*` åˆ° `Unrelated_class*` ä¹‹ç±»çš„è½¬æ¢ï¼Œè¿™æœ¬èº«å¹¶ä¸å®‰å…¨ã€‚`reinterpret_cast` è¿ç®—ç¬¦æ— æ³•å¼ºåˆ¶è½¬æ¢æ‰ `const`ã€`volatile` æˆ– `__unaligned` ç‰¹æ€§ã€‚

ä¸€èˆ¬ä½¿ç”¨ `reinterpret_cast` å°†ç©ºæŒ‡é’ˆå€¼è½¬æ¢ä¸ºç›®æ ‡ç±»å‹çš„ç©ºæŒ‡é’ˆå€¼ã€‚ä¹Ÿå…è®¸å°†æŒ‡é’ˆè§†ä¸ºæ•´æ•°ç±»å‹ï¼Œå¹¶åœ¨æŒ‡é’ˆå’Œæ•´æ•°ä¹‹é—´ç›¸äº’è½¬æ¢ã€‚

```c++
struct IntVector2 { int x, y; };
struct IntVector3 { int x, y, z; };

int main() {
	IntVector2* v2 = new IntVector2{ 2, 2 };
	IntVector3* v3 = new IntVector3{ 3, 3, 3 };

	IntVector2* pv2 = reinterpret_cast<IntVector2*>(v3);  // v3 cast to v2; not safy
	pv2->x = 1; pv2->y = 99;
	printf("v3 = {%d,%d,%d}", v3->x, v3->y, v3->z); // {1,99,3}

	IntVector3* pv3 = reinterpret_cast<IntVector3*>(v2);  // v2 cast to v3; not safy
	pv3->x = 9; pv3->y = 9;
	printf("v2 = {%d,%d}", v2->x, v2->y); // {9,9}
	pv3->z = 10;  // maybe stackOverflow ; danger!
    
	// æœªå®šä¹‰è¡Œä¸º
	IntVector3 v = static_cast<IntVector3>(*pv3);  
	printf("v = {%d,%d,%d}", v.x, v.y, v.z); // {9,9,10}
}
```

> å‘ä¸Šè½¬æ¢å’Œå‘ä¸‹è½¬æ¢

ä»æ´¾ç”Ÿç±»æŒ‡é’ˆåˆ°åŸºç±»æŒ‡é’ˆçš„è½¬æ¢æ˜¯ä¸€ç§éšå¼çš„å‘ä¸Šè½¬æ¢ï¼›åè¿‡æ¥ä»åŸºç±»æŒ‡é’ˆåˆ°æ´¾ç”Ÿç±»æŒ‡é’ˆçš„è½¬æ¢æ˜¯å‘ä¸‹è½¬æ¢ï¼Œå¦‚æœæœ‰å¤šå±‚ç»§æ‰¿ï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸æ˜ç¡®ã€‚

ä»¥ä¸‹ç¤ºä¾‹æ¼”ç¤ºäº† `dynamic_cast` å’Œ `static_cast` çš„ç”¨æ³•

```c++
class Base { virtual void f() {}; };
class DerivedA : public Base { virtual void f() {}; };
class DerivedB : public Base { virtual void f() {}; };
class Derived : public DerivedA, public DerivedB {  };

int main() {
	Derived* d = new Derived;
	Base* b = new Base;
	// å‘ä¸Šè½¬æ¢
	DerivedA* da = static_cast<DerivedA*>(d);
	DerivedB* db = static_cast<DerivedB*>(d);
	// å¤šæ€çš„æƒ…å†µä¸‹åŸºç±»ä¸æ˜ç¡®
	// Base * bd = static_cast<Base*>(d);  
	// Base* bd = dynamic_cast<Base*>(d);  

	// Derived* pd = static_cast<Derived*>(b);  // æ— æ³•ç¼–è¯‘ï¼›Derived åŒ…å«å¤šä¸ª Base çš„å®ä¾‹
	Derived* pd = dynamic_cast<Derived*>(b); 
	assert(pd == nullptr); // b ä¸åŒ…å« Derived çš„å€¼ï¼Œè¿”å› nullptr
	Base* b1 = dynamic_cast<Base*>(da); // ok; å‘ä¸Š
	Base* b2 = dynamic_cast<Base*>(db); // ok; å‘ä¸Š
	pd = dynamic_cast<Derived*>(b1);
	assert(pd != nullptr);  // å‘ä¸‹è½¬æ¢ï¼›okï¼›Base åŒ…å« Derived çš„å€¼ï¼Œä¸”æ˜¯ DerivedA::Base åˆ° Derived
	pd = dynamic_cast<Derived*>(b2);
	assert(pd != nullptr);  // å‘ä¸‹è½¬æ¢; ok; Base åŒ…å« Derived çš„å€¼ï¼Œä¸”æ˜¯ DerivedB::Base åˆ° Derived
}
```

>---
#### é¡ºåºè¿ç®—ç¬¦

é¡ºåºè¿ç®—ç¬¦ `(expr1, expr2)` å§‹ç»ˆè®¡ç®—å·¦æ“ä½œæ•°ï¼Œå¹¶ä¸”åœ¨è®¡ç®—å³æ“ä½œæ•°ä¹‹å‰å°†å®Œæˆæ‰€æœ‰å‰¯ä½œç”¨ï¼Œè¡¨è¾¾å¼çš„ç±»å‹å’Œå€¼æ˜¯å³æ“ä½œæ•°çš„ç±»å‹å’Œå€¼ã€‚

```c++
int i = 10, b = 20, c= 30;
i = b, c;  // i = b = 20

i = (b, c); // i = c = 30

i = ((b , c), ++i);   // i = ++i
```

>---
#### æ¡ä»¶è¿ç®—ç¬¦

```c++
cond-expr ? true-expr : false-expr
```

`cond-expr` å¿…é¡»æ˜¯æ•´æ•°ï¼ˆ`bool`ï¼‰æˆ–æŒ‡é’ˆç±»å‹ï¼›æ¡ä»¶è¿ç®—çš„ç»“æœæ˜¯ç¬¬äºŒä¸ªæˆ–ç¬¬ä¸‰ä¸ªè¡¨è¾¾å¼çš„è®¡ç®—ç»“æœï¼›ä¸¤è€…å…·æœ‰ç›¸åŒçš„ç±»å‹æˆ–å…¼å®¹ç±»å‹ï¼Œæˆ– `void`ï¼Œæˆ–ç¬¬ä¸‰ä¸ªæ“ä½œæ•°è¿”å› `std::exception`ã€‚

```c++
isRequest ? Handle(httpRequest) : throw exception{};
```

>---
#### å…³ç³»å’Œç›¸ç­‰è¿ç®—

```c++
bool rt = a == b;
bool rt = a != b;
bool rt = a >= b;
bool rt = a <= b;
bool rt = a > b;
bool rt = a < b;
```

>---
#### é€»è¾‘è¿ç®—

```c++
bool rt = expr1 && expr2;
bool rt = expr1 || expr2;
bool rt = !expr;
```

é€»è¾‘è¿ç®—ç¬¦çš„æ“ä½œæ•°å¿…é¡»æ˜¯å¸ƒå°”ã€æ•´æ•°æˆ–æŒ‡é’ˆç±»å‹æˆ–å¯ä»¥è½¬æ¢ä¸º `bool` çš„ç±»å‹ã€‚



>---
#### å‡½æ•°è°ƒç”¨å’Œå‡½æ•°è°ƒç”¨è¿ç®—ç¬¦é‡è½½

å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦ `( argu-list )` é¦–å…ˆå¯¹å‚æ•°åˆ—è¡¨ï¼ˆå¦‚æœæœ‰ï¼‰è¿›è¡Œæ±‚å€¼ï¼Œå‚æ•°åˆ—è¡¨ä¸­ï¼Œé¦–å…ˆè®¡ç®—ä½œä¸ºå®å‚ä¼ é€’çš„å‡½æ•°è¡¨è¾¾å¼ï¼Œç„¶åè®¡ç®—ä»»æ„çš„å‚æ•°è¡¨è¾¾å¼æˆ–é»˜è®¤å‚æ•°ï¼Œå‚æ•°è¡¨è¾¾å¼åœ¨ä¸ç¡®å®šåºåˆ—ä¸­æ±‚å€¼ã€‚è®¡ç®—ç»“æœå¯ä»¥æ˜¯å‡½æ•°ã€å‡½æ•°æŒ‡é’ˆã€å¯è°ƒç”¨å¯¹è±¡ã€æˆ–å¯¹ä¸€ä¸ªå¯¹è±¡çš„å¼•ç”¨è¡¨è¾¾å¼

å‡½æ•°ç¬¦å·ã€å‡½æ•°ç±»å‹ã€å‡½æ•°æŒ‡é’ˆå¯ä»¥ä½¿ç”¨å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦ï¼š

```c++
int func(int i) { return i; }       // è¿”å› T çš„å‡½æ•° func
typedef int funcType(int i);        // å‡½æ•°ç±»å‹ï¼Œå…·æœ‰ T (int i) ç­¾å
typedef int (*funcPointer)(int i);  // å‡½æ•°æŒ‡é’ˆç±»å‹
typedef int(&funcLv)(int i);        // å‡½æ•°å¼•ç”¨
typedef int(&& funcRv)(int i);      // å³å€¼

int main() {
	funcType* f = &func;
	funcPointer pf = &func;
	funcLv flv = func;
	funcRv frv = flv;
    f(0);
    pf(1);
    flv(2);
    frv(3);
}
```

>---
#### new åˆ†é…å†…å­˜

C++ æ”¯æŒä½¿ç”¨ `new` å’Œ `delete` è¿ç®—ç¬¦åŠ¨æ€åˆ†é…å’Œè§£é™¤åˆ†é…å¯¹è±¡ï¼Œ`new` è°ƒç”¨ç‰¹æ®Šå‡½æ•° `operetor new`ï¼Œ`delete` è°ƒç”¨ç‰¹æ®Šå‡½æ•° `operator delete`ã€‚`new` åœ¨å †ä¸­ä¸ºå¯¹è±¡åˆ†é…å†…å­˜ã€‚

```c++
type-id * pobj = [::] new type-id ( argu? )?;
type-id * parr = [::] new type-id[size];
[::] delete pobj;
[::] delete [] parr;
```

`new` å°è¯•åˆ†é…å’Œåˆå§‹åŒ–æŒ‡å®šç±»å‹æˆ–å ä½ç¬¦ç±»å‹çš„å¯¹è±¡æˆ–å¯¹è±¡æ•°ç»„ï¼Œå¹¶è¿”å›æŒ‡å‘å¯¹è±¡ï¼ˆæˆ–æŒ‡å‘æ•°ç»„åˆå§‹å¯¹è±¡ï¼‰çš„é€‚å½“ç±»å‹åŒ–çš„éé›¶æŒ‡é’ˆã€‚æœªæˆåŠŸï¼Œå°†è¿”å›é›¶æˆ–å¼•å‘å¼‚å¸¸ï¼›å¯ä»¥é€šè¿‡ç¼–å†™è‡ªå®šä¹‰å¼‚å¸¸å¤„ç†ä¾‹ç¨‹å¹¶è°ƒç”¨ `std::_set_new_handler` è¿è¡Œæ—¶åº“å‡½æ•°ï¼ˆä½¿ç”¨å‡½æ•°åä½œä¸ºå…¶å‚æ•°ï¼‰æ¥æ›´æ”¹æ­¤é»˜è®¤è¡Œä¸ºã€‚

ä½¿ç”¨ `new` ä¸º C++ ç±»å¯¹è±¡åˆ†é…å†…å­˜æ—¶ï¼Œå°†åœ¨åˆ†é…å†…å­˜åè°ƒç”¨å¯¹è±¡çš„æ„é€ å‡½æ•°ã€‚ä½¿ç”¨ `delete` è¿ç®—ç¬¦è§£é™¤ç”± `new` è¿ç®—ç¬¦åˆ†é…çš„å†…å­˜æˆ–æ•°ç»„ã€‚`new` ä¸åˆ†é…å¼•ç”¨ç±»å‹å’Œå‡½æ•°æŒ‡é’ˆï¼Œä½†å¯ä»¥åˆ†é…å‡½æ•°æŒ‡é’ˆçš„æ•°ç»„ã€‚

```c++
type *pt1 = new type;
type *pt2 = new type(argus);
const int *cpi = new int(0);
volatile int *vpi = new int(10);
char (*pchar)[10] = new char[dim][10];
int (**p) () = new (int (*[7]) ());

delete cpi;
delete [] pchar;
```

`operator new` çš„ç¬¬ä¸€ä¸ªè‡ªå˜é‡å¿…é¡»ä¸º `size_t` ç±»å‹ï¼Œä¸”è¿”å›ç±»å‹å§‹ç»ˆä¸º `void*`ã€‚åŒ…å«ç”¨æˆ·å®šä¹‰ `operator new` çš„ç±»ç±»å‹è°ƒç”¨ç”¨æˆ·å®šä¹‰ `new`ï¼Œå¦åˆ™è°ƒç”¨å…¨å±€ `::operator new`ï¼›ä¸ºç±»å®šä¹‰çš„ `operator new` å‡½æ•°æ˜¯é™æ€æˆå‘˜å‡½æ•°ï¼ˆä¸èƒ½æ˜¯è™šå‡½æ•°ï¼‰ï¼Œè¯¥å‡½æ•°éšè—æ­¤ç±»ç±»å‹çš„å¯¹è±¡çš„å…¨å±€ `operator new` å‡½æ•°ã€‚

```c++
#include <malloc.h>
#include <memory.h>
class Blanks
{
public:
    Blanks(){}
    void *operator new( size_t stAllocateBlock, char chInit );
};
void *Blanks::operator new( size_t stAllocateBlock, char chInit )
{
    void *pvTemp = malloc( stAllocateBlock );
    if( pvTemp != 0 )
        memset( pvTemp, chInit, stAllocateBlock );
    return pvTemp;
}
// For discrete objects of type Blanks, the global operator new function
// is hidden. Therefore, the following code allocates an object of type
// Blanks and initializes it to 0xa5
int main()
{
   Blanks *a5 = new(0xa5) Blanks;
   return a5 != 0;
}
```

å¦‚æœåˆ†é…è¯·æ±‚çš„å†…å­˜ä¸è¶³ï¼Œ`operator new` ä¼šå¼•å‘ `std::bad_alloc` å¼‚å¸¸æˆ– `nullptr`ã€‚

```c++
#include <iostream>
#include <new>
using namespace std;
#define BIG_NUMBER 10000000000LL

// æ ‡å‡† C++ è¦æ±‚åˆ†é…å™¨å¼•å‘ std::bad_alloc æˆ–æ´¾ç”Ÿè‡ª std::bad_alloc çš„ç±»
try {
    int *pI = new int[BIG_NUMBER];
}
catch (bad_alloc& ex) {
    cout << "Caught bad_alloc: " << ex.what() << endl;
    return -1;
}

// nothrow new
int *pI = new(nothrow) int[BIG_NUMBER];
if ( pI == nullptr ) {
    cout << "Insufficient memory" << endl;
    return -1;
}

// é“¾æ¥ nothrownew.obj æ–‡ä»¶æ›¿æ¢å…¨å±€ operator new
int *pI = new int[BIG_NUMBER];
if ( !pI ) {
    cout << "Insufficient memory" << endl;
    return -1;
}
```

å¯ä»¥ä¸ºå¤±è´¥çš„å†…å­˜åˆ†é…è¯·æ±‚æä¾›å¤„ç†ç¨‹åºã€‚ä¾‹å¦‚ç¼–å†™è‡ªå®šä¹‰æ¢å¤ä¾‹ç¨‹æ¥å¤„ç†æ­¤ç±»å¤±è´¥ã€‚

```c++
void handler()  {
	cerr << "Insufficient memory" << endl;
	throw bad_alloc();
};
set_new_handler(&handler);
int* pI = new int[BIG_NUMBER];
```

>---
#### delete é‡Šæ”¾å†…å­˜

`delete` ç”¨ä»¥é‡Šæ”¾ `new` åŠ¨æ€åˆ†é…çš„å†…å­˜å—ã€‚`delete` è¿ç®—ç¬¦è°ƒç”¨ `operator delete` å‡½æ•°ï¼Œå¹¶å°†å†…å­˜é‡Šæ”¾å›å¯ç”¨æ± ã€‚

```c++
[::] delete cast-expression;       // new ptr
[::] delete [] cast-expression;    // new arr[N]
```

*cast-expression* è‡ªå˜é‡å¿…é¡»æ˜¯æŒ‡å‘ä»¥å‰åˆ†é…ç»™ä½¿ç”¨ `new` è¿ç®—ç¬¦åˆ›å»ºçš„å¯¹è±¡çš„å†…å­˜å—çš„æŒ‡é’ˆã€‚å¯¹å…¶ä»–æŒ‡é’ˆä½¿ç”¨ `delete` è¡Œä¸ºæœªå®šä¹‰ï¼›ä½†å¯ä»¥å¯¹ç©ºæŒ‡é’ˆä½¿ç”¨ `delete`ï¼Œå› ä¸º `new` åˆ†é…å¤±è´¥æ—¶ä¹Ÿä¼šè¿”å› `nullptr`ï¼›è¢«é‡Šæ”¾çš„æŒ‡é’ˆå–å¼•ç”¨è¡Œä¸ºæœªå®šä¹‰ã€‚

å¯¹å¯¹è±¡ä½¿ç”¨ `delete` å°†é‡Šæ”¾å…¶å†…å­˜ã€‚é‡Šæ”¾ C++ ç±»å¯¹è±¡ï¼ˆ`class`ã€`struct` æˆ– `union`ï¼‰çš„å†…å­˜æ—¶ï¼Œå°†åœ¨é‡Šæ”¾è¯¥å¯¹è±¡çš„å†…å­˜ä¹‹å‰è°ƒç”¨è¯¥å¯¹è±¡çš„ææ„å‡½æ•°ï¼ˆå¦‚æœæœ‰ï¼‰ï¼›å…¶ä»–éç±»å¯¹è±¡è°ƒç”¨å…¨å±€ `::delete`ã€‚å¯¹å¯ä¿®æ”¹çš„å·¦å€¼ä½¿ç”¨ï¼Œåˆ™åœ¨ `delete` è¯¥å¯¹è±¡åæœªå®šä¹‰å…¶å€¼ã€‚

```c++
struct C {
public:
	~C() { cout << "call ~C" << endl; }
};

int main() {
	C* pc = new C;
	C* pac = new C[10];

	::delete [] pac;
	delete pc;
}
```

å…¨å±€ `operator delete` å‡½æ•°å’Œç±»æˆå‘˜ `operator delete` å‡½æ•°å­˜åœ¨ä¸¤ç§å½¢å¼ã€‚åªèƒ½ä¸ºç»™å®šç±»å®šä¹‰å…¶ä¸­çš„ä¸€ä¸ª `operator delete` å‡½æ•°ï¼›å¦‚æœå®šä¹‰ï¼Œå®ƒä¼šéšè—å…¨å±€ `operator delete` å‡½æ•°ã€‚å§‹ç»ˆä¸ºæ‰€æœ‰ç±»å‹çš„æ•°ç»„è°ƒç”¨å…¨å±€ `operator delete` å‡½æ•°ã€‚å¯¹äºä¸æ˜¯ç±»ç±»å‹çš„å¯¹è±¡ï¼Œå°†è°ƒç”¨å…¨å±€ `delete` è¿ç®—ç¬¦ `::delete`ã€‚

```c++
void operator delete( void * );
void operator delete( void *, size_t );
```

ä¸‹é¢æ˜¯ä¸€ä¸ªè®°å½•å†…å­˜çš„åˆ†é…å’Œè§£é™¤åˆ†é…çš„ç”¨æˆ·å®šä¹‰çš„ `operator new` å’Œ `operator delete` å‡½æ•°ï¼š

```c++
#include <iostream>
using namespace std;

int fLogMemory = 0;      
int cBlocksAllocated = 0;  // Count of blocks allocated.

// User-defined operator new.
void* operator new(size_t stAllocateBlock) {
	if (stAllocateBlock == 0) return nullptr;
	static int fInOpNew = 0;   // Guard flag.
	if (fLogMemory && !fInOpNew) {
		fInOpNew = 1;
		cout << "Memory block " << (++cBlocksAllocated)
			<< " allocated for " << stAllocateBlock
			<< " bytes\n";
		fInOpNew = 0;
	}
	return malloc(stAllocateBlock);
}

// User-defined operator delete.
void operator delete(void* pvMem) {
	if (!pvMem) return;
	static int fInOpDelete = 0;   // Guard flag.
	if (fLogMemory && !fInOpDelete) {
		fInOpDelete = 1;
		cout << "Memory block " << cBlocksAllocated--
			<< " deallocated\n";
		fInOpDelete = 0;
	}
	free(pvMem);
}

int main() {
	fLogMemory = 1;   // Turn logging on
	for (int i = 0; i < 10; ++i) {
		char* pMem = new char[i];
		delete[] pMem;
	}
	fLogMemory = 0;  // Turn logging off.
	return cBlocksAllocated;
}
```

åœ¨ç±»å£°æ˜ä¸­æ”¯æŒæˆå‘˜æ•°ç»„ `new` å’Œ `delete` è¿ç®—ç¬¦ã€‚

```c++
class X  {
public:
   void * operator new[] (size_t) { return 0; }
   void operator delete[] (void*) {}
};
void f() {
   X *pX = new X[5];
   delete [] pX;
}
```


å¯¹äºç±»ç±»å‹çš„å¯¹è±¡ï¼Œå¦‚æœ `delete` è¡¨è¾¾å¼ä»¥ä¸€å…ƒèŒƒå›´è§£æè¿ç®—ç¬¦ (`::`) å¼€å§‹ï¼Œåˆ™ä¼šåœ¨å…¨å±€èŒƒå›´ä¸­è§£æè§£é™¤åˆ†é…å‡½æ•°çš„åç§°ã€‚å¦åˆ™ï¼Œ`delete` è¿ç®—ç¬¦å°†åœ¨é‡Šæ”¾å†…å­˜ä¹‹å‰ä¸ºå¯¹è±¡è°ƒç”¨ææ„å‡½æ•°ï¼ˆå¦‚æœæŒ‡é’ˆä¸ä¸º `null`ï¼‰ã€‚

å¦‚æœ `delete` è¡¨è¾¾å¼ç”¨äºé‡Šæ”¾å…¶é™æ€å¯¹è±¡å…·æœ‰è™šæ‹Ÿææ„å‡½æ•°çš„ç±»å¯¹è±¡ï¼Œåˆ™å°†é€šè¿‡å¯¹è±¡çš„åŠ¨æ€ç±»å‹çš„è™šæ‹Ÿææ„å‡½æ•°è§£æé‡Šæ”¾å‡½æ•°ã€‚




>---
#### æŒ‡é’ˆè¿ç®—ä¸é—´æ¥å¯»å€

```c++
// address-of
int * pi = &i;
const type cp = &const_type;
volatile type vp = &vola_type;
// ç®—æ•°
int * p = p + integer;
int * p = p - integer;
ptrdiff_t diff = p1 - p2;
p++;
p--;
p += i;
p -= i;
```

`*` å–æ¶ˆå¼•ç”¨æŒ‡é’ˆå°†å…¶è½¬æ¢ä¸ºä¸€ä¸ªå·¦å€¼ã€‚å¦‚æœè¯¥æŒ‡é’ˆçš„å€¼æ— æ•ˆï¼Œåˆ™ç»“æœæ˜¯æœªå®šä¹‰çš„ã€‚ä¾‹å¦‚ï¼š
- è¯¥æŒ‡é’ˆä¸º null æŒ‡é’ˆã€‚
- è¯¥æŒ‡é’ˆæŒ‡å®šå¼•ç”¨æ—¶ä¸å¯è§çš„æœ¬åœ°é¡¹çš„åœ°å€ã€‚
- è¯¥æŒ‡é’ˆæŒ‡å®šæœªé’ˆå¯¹æ‰€æŒ‡å‘çš„å¯¹è±¡ç±»å‹æ­£ç¡®å¯¹é½çš„åœ°å€ã€‚
- è¯¥æŒ‡é’ˆæŒ‡å®šæ‰§è¡Œç¨‹åºæœªä½¿ç”¨çš„åœ°å€ã€‚

```c++
int i = 100;
int *pi = &i;

*pi = 10086; // now i = 10086
```

>---
#### æ•°ç»„ä¸‹æ ‡è¿ç®—

```c++
int nArray[5] = { 0, 1, 2, 3, 4 };
cout << nArray[2] << endl;            // prints "2"
cout << 2[nArray] << endl;            // prints "2"

int* pArray = new int[5] { 0, 1, 2, 3, 4 };
cout << pArray[2] << endl;            // prints "2"
cout << 2[pArray] << endl;            // prints "2"

// å¤šç»´
int arr[10][10][10]{};
arr[5][5][5] = 1;
5[5[5[arr]]] = 1;  // ä¸æ¨è
```

C++ æ•°ç»„çš„èŒƒå›´æ˜¯ä» `array[0]` åˆ° `array[size â€“ 1]`ï¼›ä½†æ”¯æŒæ­£è´Ÿä¸‹æ ‡ï¼Œæ•°ç»„ä¸‹æ ‡é”™è¯¯ä¸ä¼šäº§ç”Ÿç¼–è¯‘æ—¶é”™è¯¯ã€‚è´Ÿä¸‹æ ‡å¿…é¡»åœ¨æ•°ç»„è¾¹ç•Œå†…ï¼Œå¦åˆ™ç»“æœä¸å¯é¢„çŸ¥ï¼š

```c++
#include <iostream>
using namespace std;
int main() {
    int intArray[1024];
    for (int i = 0, j = 0; i < 1024; i++)
        intArray[i] = j++;
    cout << intArray[512] << endl;   // 512
    cout << 257[intArray] << endl;   // 257
    int *midArray = &intArray[512];  // pointer to the middle of the array
    cout << midArray[-256] << endl;  // 256
    cout << intArray[-256] << endl;  // unpredictable, may crash
}
```

é‡è½½ä¸‹æ ‡è¿ç®—ç¬¦ï¼š

```c++
template<typename T> 
struct Array {
	T* arr;
	size_t len;
public:
	Array(size_t size) {
		arr = new T[size];
		len = size;
	}
	T& operator [] (size_t i) {
		if (i < 0 || i >= len) 
			throw out_of_range("i");
		return this->arr[i];
	}
	~Array() { delete arr; }
};

int main() {
	Array<int> arr(10);
	arr[10] = 10;
}
```

>---
#### typeid

```c++
typeid(type-id)
typeid(expression)
```

`typeid` è¿ç®—ç¬¦å…è®¸åœ¨è¿è¡Œæ—¶ç¡®å®šå¯¹è±¡çš„ç±»å‹ï¼›ç»“æœæ˜¯ `const type_info&`ã€‚`typeid` è¿ç®—ç¬¦ä¸é€‚ç”¨äºæ‰˜ç®¡ç±»å‹ï¼ˆæŠ½è±¡å£°æ˜ç¬¦æˆ–å®ä¾‹ï¼‰ã€‚åœ¨åº”ç”¨äºå¤šæ€ç±»ç±»å‹çš„ *lvalue* æ—¶æ‰§è¡Œè¿è¡Œæ—¶æ£€æŸ¥ï¼Œå…¶ä¸­å¯¹è±¡çš„å®é™…ç±»å‹ä¸èƒ½ç”±æä¾›çš„é™æ€ä¿¡æ¯ç¡®å®šã€‚ æ­¤ç±»æƒ…å†µæ˜¯ï¼š
- å¯¹ç±»çš„å¼•ç”¨
- ä½¿ç”¨ `*` å–æ¶ˆå¼•ç”¨çš„æŒ‡é’ˆ
- å¸¦ä¸‹æ ‡çš„æŒ‡é’ˆ (`[ ]`)ã€‚å°†ä¸‹æ ‡ä¸æŒ‡å‘å¤šæ€ç±»å‹çš„æŒ‡é’ˆä¸€èµ·ä½¿ç”¨æ˜¯ä¸å®‰å…¨çš„ã€‚
		
å¦‚æœ `expression` æŒ‡å‘åŸºç±»ç±»å‹ï¼Œä½†å¯¹è±¡æ˜¯æ´¾ç”Ÿç±»å‹çš„å€¼ï¼Œåˆ™ç»“æœæ˜¯æ´¾ç”Ÿç±»å‹çš„ `type_info`ã€‚`expression` å¿…é¡»æŒ‡å‘å¤šæ€ç±»å‹ï¼ˆå…·æœ‰è™šå‡½æ•°çš„ç±»ï¼‰ã€‚å¦åˆ™ç»“æœæ˜¯ `expression` ä¸­å¼•ç”¨çš„é™æ€ç±»çš„ `type_info`ã€‚å¿…é¡»å–æ¶ˆå¼•ç”¨æŒ‡é’ˆï¼Œè¿™æ ·ä½¿ç”¨çš„å¯¹è±¡å°±æ˜¯å®ƒæ‰€æŒ‡å‘çš„å¯¹è±¡ï¼›å¦åˆ™ç»“æœå°†æ˜¯æŒ‡é’ˆçš„ `type_info`ã€‚	
		
```c++
class Base {
public:
   virtual void vvfunc() {}
};
class Derived : public Base {};
int main() {
   Derived* pd = new Derived;
   Base* pb = pd;
   cout << typeid( pb ).name() << endl;   // "class Base *"
   cout << typeid( *pb ).name() << endl;  // "class Derived"
   cout << typeid( pd ).name() << endl;   // "class Derived *"
   cout << typeid( *pd ).name() << endl;  // "class Derived"
   delete pd;
}
```		
		
åœ¨ `typeif` ä¸­å–æ¶ˆå¼•ç”¨é›¶å€¼æŒ‡é’ˆå°†å¼•å‘ `bad_typeid`ï¼›æŒ‡é’ˆä¸æŒ‡å‘æœ‰æ•ˆçš„å¯¹è±¡ï¼Œåˆ™ä¼šå¼•å‘ `__non_rtti_object` å¼‚å¸¸ã€‚

å¦‚æœ `expression` ä¸æ˜¯æŒ‡é’ˆæˆ–å¯¹å¯¹è±¡çš„åŸºç±»çš„å¼•ç”¨ï¼Œåˆ™ç»“æœæ˜¯è¡¨ç¤º `expression` çš„é™æ€ç±»å‹çš„ `type_info` å¼•ç”¨ã€‚ è¡¨è¾¾å¼çš„é™æ€ç±»å‹å°†å¼•ç”¨åœ¨ç¼–è¯‘æ—¶å·²çŸ¥çš„è¡¨è¾¾å¼çš„ç±»å‹ã€‚åœ¨è®¡ç®—è¡¨è¾¾å¼çš„é™æ€ç±»å‹æ—¶ï¼Œå°†å¿½ç•¥æ‰§è¡Œè¯­ä¹‰ï¼›å¹¶ä¸”å°†å¿½ç•¥å¼•ç”¨ï¼ˆå¦‚æœå¯èƒ½ï¼‰ã€‚

```c++
typeid(int) == typeid(int&); // evaluates to true
```

`typeid` å¯ä»¥åœ¨æ¨¡æ¿ä¸­ä½¿ç”¨ï¼Œä»¥ç¡®å®šæ¨¡æ¿å‚æ•°çš„ç±»å‹ï¼š

```c++
template < typename T >
T max( T arg1, T arg2 ) {
   cout << typeid( T ).name() << "s compared." << endl;
   return ( arg1 > arg2 ? arg1 : arg2 );
}
```
		
> *type_info* 
		
`type_info` ç±»æè¿°ç¼–è¯‘å™¨åœ¨ç¨‹åºä¸­ç”Ÿæˆçš„ç±»å‹ä¿¡æ¯ã€‚æ­¤ç±»çš„å¯¹è±¡å¯ä»¥æœ‰æ•ˆå­˜å‚¨æŒ‡å‘ç±»å‹åç§°çš„æŒ‡é’ˆã€‚`type_info` ç±»è¿˜å¯å­˜å‚¨é€‚åˆæ¯”è¾ƒä¸¤ä¸ªç±»å‹æ˜¯å¦ç›¸ç­‰æˆ–æ¯”è¾ƒå…¶æ’åˆ—é¡ºåºçš„ç¼–ç å€¼ã€‚

```c++
class DerivedA {};
class DerivedB {};
class Derived : public DerivedA, public DerivedB {  };

int main() {
	Derived* d = new Derived;
	DerivedA* da = static_cast<DerivedA*>(d);
	DerivedB* db = static_cast<DerivedB*>(d);
	assert(typeid(*da) == typeid(*db));  // true;
}
```

---
### è¯­å¥
#### ç©ºè¯­å¥

```c++
while(cond)
    ;
```

>---
#### if-else

```c++
if ( [init-statemnet]; condition ) 
    ;  // body or statement
[ else [if-clause] ]
    ;  // body or statement
```
```c++
if (x < 11)
    cout << "x < 11 is true!\n";  // executed
else
    cout << "x < 11 is false!\n"; // not executed
```

å¯ä»¥å¯é€‰çš„åŒ…å«ä¸€ä¸ªåˆå§‹åŒ–è¯­å¥ã€‚

```c++
if (auto it = m.find(10); it != nullptr)
    cout << it->name << endl;
```

ä» C++17 å¼€å§‹ï¼Œå¯ä»¥ä½¿ç”¨å‡½æ•°æ¨¡æ¿ä¸­çš„ `if constexpr` è¯­å¥åšå‡ºç¼–è¯‘æ—¶åˆ†æ”¯å†³ç­–ï¼Œè€Œæ— éœ€æ±‚åŠ©äºå¤šä¸ªå‡½æ•°é‡è½½ã€‚

```c++
template<typename T>
auto Show(T t)
{
	//if (std::is_pointer_v<T>) // Show(a) results in compiler error for return *t. Show(b) results in compiler error for return t.
	if constexpr (std::is_pointer_v<T>) // This statement goes away for Show(a)
		return *t;
	else
		return t;
}

int main() {
	using namespace std;
	int a = 42;
	int* pB = &a;
	cout << Show(a) << endl;  // prints "42"
	cout << Show(pB) << endl; // prints "42"
}
```

>---
#### switch-case

```c++
swtich ( [init-statement;] condition ){
    case cond1:
        ;  // statements
        break; // return; 
    // case ...
    [default: ]
}

```

`switch` è¯­å¥ä½“ç”±ä¸€ç³»åˆ— `case` æ ‡ç­¾å’Œä¸€ä¸ª `default`ï¼ˆå¯é€‰ï¼‰æ ‡ç­¾ç»„æˆã€‚è¯­å¥ä½¿æ§ä»¶æ ¹æ® `condition` çš„å€¼è½¬ç§»åˆ°å…¶è¯­å¥æ­£æ–‡ä¸­çš„ä¸€ä¸ªæ ‡ç­¾åˆ†æ”¯è¯­å¥ `case` æˆ– `default`ï¼›`condition` å¿…é¡»æ˜¯æ•´æ•°å‹æˆ–å¯æ˜ç¡®è½¬æ¢ä¸ºæ•´æ•°å‹çš„ç±»ç±»å‹ï¼›æ ‡ç­¾ä¹‹é—´å¯ä»¥è´¯ç©¿ï¼Œç¼–è¯‘å™¨ç»™å‡ºè­¦å‘Šã€‚`condition` ä¸­å…è®¸ä½¿ç”¨ä¸€ä¸ªåˆå§‹åŒ–å¥ã€‚

```c++
struct S {
	int stat;
public:
	S(int stat) { S::stat = stat; };
	int operator ()() {
		return this->stat;
	}
};
int main() {
	S s(1);
	switch (int a = s(); a) // or switch( s() ) // s() è½¬æ¢ä¸º int
	{
	case 1:
		//...
		break;
	// case ...
	default:break;
	}
}
```

å±æ€§ `[[fallthrough]]` è¡¨ç¤ºåœ¨ `case` ä¹‹é—´äººä¸ºè®¾å®šçš„å‘ç”Ÿè´¯ç©¿ï¼Œå‘ŠçŸ¥ç¼–è¯‘å™¨ä¸¤ä¸ª `case` çš„è´¯ç©¿æ˜¯å¯è¡Œçš„ï¼Œä¸å¿…å‘å‡ºè­¦å‘Šï¼›

```c++
switch (1) {
case 1:
	cout << 1 << endl;
	[[fallthrough]];
case 2:
	cout << 2 << endl;
default:break; // warning: fallthrough
}
```

åœ¨ `case` ä¸­å£°æ˜çš„å˜é‡å±äº `switch` è¯­å¥èŒƒå›´ï¼Œå› æ­¤å…±äº«åç§°ç©ºé—´å’Œéµå¾ªå•ä¸€å®šä¹‰åŸåˆ™ï¼›ä½†å‰ææ˜¯å¯ä»¥è®¿é—®åˆ°å®ƒä»¬ï¼Œå³æ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œè·¯å¾„éƒ½ä¸ä¼šç»•è¿‡å®ƒä»¬ã€‚

```c++
// switch (char szChEntered[] = "Character entered was:"; 'a')  // init at swtich condition; is ok
switch ('a')  
{
    // Error. Unreachable declaration.
    char szChEntered[] = "Character entered was: "; 
case 'a':
{
    // Declaration of szChEntered OK. Local scope.
    char szChEntered[] = "Character entered was: ";
    cout << szChEntered << "a\n";
}
break;
case 'b':
    // Error. Value of szChEntered undefined.
    cout << szChEntered << "b\n";
    break;
default:
    // Error. Value of szChEntered undefined.
    cout << szChEntered << "neither a nor b\n";
    break;
}
```

>---
#### goto ä¸æ ‡ç­¾

æ ‡ç­¾å…·æœ‰å‡½æ•°èŒƒå›´ï¼Œåœ¨æ•´ä¸ªå‡½æ•°å†…å¯è§ï¼Œä¸å£°æ˜ä½ç½®æ— å…³ã€‚

```c++
int main() {
   goto Test2;
   cout << "testing" << endl;
   Test2:
      cerr << "At Test2 label." << endl;
}
```

>---
#### while

æ‰§è¡Œé›¶æ¬¡åˆ°å¤šæ¬¡ï¼›

```c++
while ( expression ) {
   // statement
};
```

>---
#### do-while

è‡³å°‘æ‰§è¡Œä¸€æ¬¡ï¼›

```c++
do{
    // statement
}while ( expression );
```

>---
#### for

é‡å¤æ‰§è¡Œè¯­å¥ï¼Œç›´åˆ°æ¡ä»¶å˜ä¸º `false`ã€‚`init-expr` å’Œ `loop-expr` å¯ä»¥åŒ…å«å¤šä¸ªè¯­å¥ã€‚

```c++
for (init-expr?; cond-expr?; loop-expr ) {
    statement
}

// for(;;) == while(true)
for (int a = 1, b = 10; a < b; a++, b--, cout << a * b << '\n')
	;
```

>---
#### for-range

```c++
for ( for-range-declaration : expression)
    statement
```

åŸºäºèŒƒå›´çš„ `for` å¾ªç¯ç”¨æ¥å¾ªç¯è®¿é—®æ•°ç»„å’ŒçŸ¢é‡ï¼š

```c++
int x[10]{ 1,2,3,4,5,6,7,8,9,0 };
for (auto e : x)
	cout << e << "\n";
```

æœ‰å…³åŸºäºèŒƒå›´çš„ `for` çš„æƒ…å†µï¼š
- è‡ªåŠ¨è¯†åˆ«æ•°ç»„ã€‚
- è¯†åˆ«æ‹¥æœ‰ `.begin()` å’Œ `.end()` çš„å®¹å™¨ã€‚
- å¯¹äºä»»ä½•å…¶ä»–å†…å®¹ï¼Œä½¿ç”¨ä¾èµ–äºè‡ªå˜é‡çš„æŸ¥æ‰¾ `begin()` å’Œ `end()`ã€‚

```c++
template <typename T>
class Iterator {  // è¿­ä»£å™¨
private:
	T* iter;
public:
	Iterator(T* para, size_t n) { iter = para + n; }
	T& operator *() { return *iter; }
	bool operator != (const Iterator& that) { return this->iter != that.iter; }
	Iterator& operator++ () { ++iter; return *this; }
};
template <typename T>
class docker {  // å®ç° begin å’Œ end
private:
	T* p;
	size_t size;
public :
	docker(size_t n, T arr[]) :size(n) { p = arr; }
	Iterator<T> begin() { return Iterator<T>(this->p, 0); }
	Iterator<T> end() { return Iterator<T>(this->p, size); }
};

int main(int argc, char* argv[])
{

	int x[10]{ 1,2,3,4,5,6,7,8,9,0 };
	docker<int> d(10, x);
	for (auto& i : d)
		cout << i << ", ";
}
```

>---
#### break, continue, return

`break` è¯­å¥å¯ç»ˆæ­¢æ‰§è¡Œæœ€è¿‘çš„å°é—­å¾ªç¯æˆ–å…¶æ‰€åœ¨æ¡ä»¶è¯­å¥ã€‚
`continue` è·³è¿‡åç»­è¯­å¥å¹¶å¼€å¯æœ€å°å°é—­ `do`ã€`for` æˆ– `while` çš„ä¸‹ä¸€æ¬¡è¿­ä»£ã€‚
`return` ç»ˆæ­¢å‡½æ•°çš„æ‰§è¡Œå¹¶è¿”å›åˆ°è°ƒç”¨æ–¹ã€‚

```c++
int f(int i)
{
	int c = 0;
	while (i--) {
		if (i > 100) break;
		if (i % 2 == 0) continue;
		cout << i << ",";
		++c;
	}
	cout << endl;
	return c;
}
int main() {
	auto c = f(10);    // 9,7,5,3,1
	printf("Iterate %d\n", c);  // 5
	c = f(1000);  // break
	printf("Iterate %d\n", c);  // 0
}
```

---
### Namespace

å‘½åç©ºé—´æ˜¯ä¸€ä¸ªå£°æ˜æ€§åŒºåŸŸï¼Œé€šè¿‡å•ä¸ªæ ‡è¯†ç¬¦çš„ `using` å£°æ˜ï¼ˆ`using std::string`ï¼‰æ¥è®¿é—®æˆå‘˜ `string`ï¼›æˆ– `using` æŒ‡ä»¤ ï¼ˆ`using namespace std`ï¼‰æ¥è®¿é—® `std` å‘½åç©ºé—´çš„æ‰€æœ‰æˆå‘˜ï¼›å¤´æ–‡ä»¶ä¸­çš„ä»£ç åº”å§‹ç»ˆä½¿ç”¨å®Œå…¨é™å®šçš„å‘½åç©ºé—´åç§°ã€‚

```c++
namespace ContosoData
{
    class ObjectManager
    {
    public:
        void DoSomething() {}
    };
    void Func(ObjectManager) {}
}

// ä½¿ç”¨å®Œå…¨é™å®šåç§°è®¿é—®ï¼š
ContosoData::ObjectManager mgr;
mgr.DoSomething();
ContosoData::Func(mgr);

// using å£°æ˜
using ContosoData::ObjectManager;
ObjectManager mgr;
mgr.DoSomething();

// using æŒ‡ä»¤
using namespace ContosoData;
ObjectManager mgr;
mgr.DoSomething();
Func(mgr);
```

å¦‚æœæœªåœ¨æ˜¾å¼å‘½åç©ºé—´ä¸­å£°æ˜æŸä¸ªæ ‡è¯†ç¬¦ï¼Œéšå¼å…¨å±€å‘½åç©ºé—´çš„ä¸€éƒ¨åˆ†ã€‚`main` å…¥å£å‡½æ•°å¿…é¡»åœ¨å…¨å±€å‘½åç©ºé—´ä¸­ã€‚æ‰€æœ‰ C++ æ ‡å‡†åº“ç±»å‹å’Œå‡½æ•°éƒ½åœ¨ `std` å‘½åç©ºé—´æˆ–åµŒå¥—åœ¨ `std` å†…çš„å‘½åç©ºé—´ä¸­è¿›è¡Œå£°æ˜ã€‚

æ™®é€šåµŒå¥—å‘½åç©ºé—´çš„æˆå‘˜ä»…å±äºåµŒå¥—ï¼Œçˆ¶çº§è®¿é—®åµŒå¥—ç©ºé—´æˆå‘˜éœ€è¦ä½¿ç”¨é™å®šåç§°ï¼›æ™®åµŒå¥—å‘½åç©ºé—´å…·æœ‰å¯¹å…¶çˆ¶çº§æˆå‘˜çš„éé™å®šè®¿é—®æƒé™ã€‚

```c++
namespace ContosoDataServer
{
    void Foo();
    namespace Details
    {
        int CountImpl;
        void Ban() { return Foo(); }  // éé™å®šè®¿é—®
    }
    int Bar(){...};
    int Baz(int i) { return Details::CountImpl; }  // é™å®šè®¿é—®
}
```

å†…è”å‘½åç©ºé—´çš„æˆå‘˜è¢«è§†ä¸ºçˆ¶çº§ç©ºé—´çš„æˆå‘˜ã€‚å¯ä»¥åœ¨å†…è”å‘½åç©ºé—´ä¸­å£°æ˜çš„æ¨¡æ¿ï¼Œç„¶ååœ¨çˆ¶å‘½åç©ºé—´ä¸­å£°æ˜ä¸“ç”¨åŒ–ï¼š

```c++
namespace Parent
{
    inline namespace new_ns
    {
         template <typename T>
         struct C
         {
             T member;
         };
    }
    template<>
    class C<int> {};
}
```

å¯ä»¥å°†å†…è”å‘½åç©ºé—´ç”¨ä½œç‰ˆæœ¬æ§åˆ¶æœºåˆ¶ï¼Œä»¥ç®¡ç†å¯¹åº“çš„å…¬å…±æ¥å£çš„æ›´æ”¹ã€‚

```c++
namespace Contoso
{
    namespace v_10   
    {
        template <typename T>
        class Funcs  // éå†…è”ï¼›æ— æ³•é€šè¿‡ Contoso::Funcs è®¿é—® v_10::Funcs
        {
        public:
            Funcs(void);            
            T Add(T a, T b);
            T Subtract(T a, T b);
            T Multiply(T a, T b);
            T Divide(T a, T b);  // åªèƒ½é€šè¿‡ Contoso::v_10::Funcs::Divide è®¿é—®
        };
    }
    inline namespace v_20
    {
        template <typename T>
        class Funcs  // å†…è”ï¼Œç›´æ¥é€šè¿‡ Contoso::Funcs è®¿é—®
        {
        public:
            Funcs(void);
            T Add(T a, T b);
            T Subtract(T a, T b);
            T Multiply(T a, T b);
            std::vector<double> Log(double);
            T Accumulate(std::vector<T> nums);
        };
    }
}
```

>---
#### å‘½åç©ºé—´åˆ«å

```c++
namespace a_very_long_namespace_name { class Foo {}; }
namespace AVLNN = a_very_long_namespace_name;
void Bar(AVLNN::Foo foo){ }
```

>---
#### åŒ¿åå‘½åç©ºé—´

åŒ¿åå‘½åç©ºé—´ä¸­çš„æˆå‘˜å¯¹å¤–ä¸å¯è§ï¼Œä»…å¯¹å…¶ç¿»è¯‘å•å…ƒèŒƒå›´å¯è§ï¼Œå¯¹å¤–éƒ¨æ–‡ä»¶ä¸å¯è§ï¼ˆç›¸å½“äºå†…éƒ¨é“¾æ¥ï¼‰ã€‚

```c++
// flieA.cpp
namespace Parent {
	namespace {
		void Myfunc() {
			std::cout << "Call Myfunc" << std::endl;
		}
	}
	void CallMyfunc() {
		Myfunc();  // å½“å‰ç¿»è¯‘å•å…ƒå¯è§
	}
}
// fileB.cpp
namespace Parent {
	void CallMyfuncOther() {
		// Parent::Myfunc åœ¨å½“å‰ç¿»è¯‘å•å…ƒä¸å¯è§
	}
}
int main() {
	Parent::CallMyfunc(); 
}
```

---
### Enum

æšä¸¾æ˜¯ç”¨æˆ·å®šä¹‰çš„ç±»å‹ï¼Œå…¶ä¸­åŒ…å«ä¸€ç»„ â€œæšä¸¾é¡¹â€ çš„å‘½åçš„æ•´å‹å¸¸é‡ã€‚æ²¡æœ‰ *integerType* æ—¶é»˜è®¤ä¸º `int`ã€‚ 

```c++
enum Identifier [: integerType ] { ... }       // éåŒºåˆ†èŒƒå›´æšä¸¾
enum class Identifier [: integerType ] {...}  // åŒºåˆ†èŒƒå›´æšä¸¾ç±»å‹

enum Week : unsigned char { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday };
enum class Suit { Diamonds, Hearts, Clubs, Spades };
```

åœ¨éåŒºåˆ†èŒƒå›´æšä¸¾å£°æ˜ä¸­ï¼Œéé™å®šæšä¸¾é¡¹åœ¨å£°æ˜ `enum` çš„æ•´ä¸ªèŒƒå›´ä¸­å¯è§ã€‚åœ¨åŒºåˆ†èŒƒå›´çš„æšä¸¾ä¸­ï¼Œæšä¸¾é¡¹åç§°å¿…é¡»ç”± `enum` ç±»å‹åç§°é™å®šã€‚éé™å®šæšä¸¾é¡¹å¯ä»¥éšå¼è½¬æ¢ä¸º `int`ï¼›é™å®šæšä¸¾é¡¹æ— æ³•ç›´æ¥éšå¼è½¬æ¢ï¼Œéœ€è¦ `static_cast` å¼ºåˆ¶è½¬æ¢ã€‚

```c++
int main() {
	Week day = Monday;
	Suit kind = Suit::Hearts;

	int tue = Tuesday;
	int clubs = static_cast<int>( Suit::Clubs);
}
```

> ç©ºæšä¸¾é¡¹çš„æšä¸¾

ä»…é€šè¿‡ä½¿ç”¨æ˜¾å¼åŸºç¡€ç±»å‹è€Œæ— éœ€å®šä¹‰æšä¸¾é¡¹çš„æšä¸¾ï¼Œå®é™…ä¸Šå¯ä»¥è§†ä¸ºä¸€ç§æ²¡æœ‰ä»»ä½•å…¶ä»–ç±»å‹éšå¼è½¬æ¢çš„æ–°æ•´å‹ç±»å‹ã€‚

```c++
// std::byte
enum class byte : unsigned char {};

byte operator|(const byte _Left, const byte _Right) noexcept {
	return static_cast<byte>(
		static_cast<unsigned char>(static_cast<unsigned int>(_Left) | static_cast<unsigned int>(_Right)));
}
byte operator&(const byte _Left, const byte _Right) noexcept {
	return static_cast<byte>(
		static_cast<unsigned char>(static_cast<unsigned int>(_Left) & static_cast<unsigned int>(_Right)));
}
byte operator^(const byte _Left, const byte _Right) noexcept {
	return static_cast<byte>(
		static_cast<unsigned char>(static_cast<unsigned int>(_Left) ^ static_cast<unsigned int>(_Right)));
}
byte operator~(const byte _Arg) noexcept {
	return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(_Arg)));
}
byte& operator|=(byte& _Left, const byte _Right) noexcept {
	return _Left = _Left | _Right;
}
byte& operator&=(byte& _Left, const byte _Right) noexcept {
	return _Left = _Left & _Right;
}
byte& operator^=(byte& _Left, const byte _Right) noexcept {
	return _Left = _Left ^ _Right;
}
int test() {
	byte b1{ 0 }, b2{ 1 };
	byte rt = b1 | b2;
	rt = b1 & b2;
	rt = b1 ^ b2;
	rt &= b1;
	rt |= b1;
	rt ^= b1;
}
```

---
### Union

è”åˆæ˜¯ä¸€ä¸ªç”¨æˆ·å®šä¹‰ç±»å‹ï¼Œå…¶ä¸­æ‰€æœ‰æˆå‘˜éƒ½å…±äº«åŒä¸€ä¸ªå†…å­˜ä½ç½®ã€‚å®ƒå§‹ç»ˆä»…ä½¿ç”¨è¶³ä»¥å­˜å‚¨æœ€å¤§æˆå‘˜çš„å†…å­˜ã€‚å¦‚æœä»»ä½•æˆå‘˜ç±»å‹å…·æœ‰ä¸å¸¸ç”¨çš„ constructorï¼ˆæ„é€ å‡½æ•°ï¼‰ï¼Œåˆ™å¿…é¡»ç¼–å†™ä»£ç æ¥æ˜¾å¼ constructï¼ˆæ„é€ ï¼‰å’Œé”€æ¯è¯¥æˆå‘˜ã€‚`union` æ— æ³•å­˜å‚¨å¼•ç”¨ã€‚`union` ä¹Ÿä¸æ”¯æŒç»§æ‰¿ã€‚ç›´æ¥åˆ†é…åˆå§‹åŒ–è¡¨è¾¾å¼æ—¶ï¼Œå°†è¯¥è¡¨è¾¾å¼çš„ç»“æœåˆ†é…ç»™ `union` çš„ç¬¬ä¸€ä¸ªå­—æ®µ

```c++

union RecordType    // Declare a simple union type
{
	char   ch;
	int    i;
	long   l;
	float  f;
	double d;
	int* int_ptr;
public:
	RecordType(char ch) :ch(ch) {}
	template <typename T>
	void print() {
		T* t = new T;
		memcpy(t, this, sizeof(T));
		std::cout << *t << std::endl;
	}
};
int main() {

	RecordType t1 = { 'A' };  // t2.ch = 'A';
	t1.print<char>();  // 'A'
	RecordType t2(0);
	t2.i = 5;    // t holds an int
	t2.print<int>();   // 5
	t2.f = 7.25; // t now holds a float
	t2.print<float>();   // 7.25
}
```

åŒ¿å `union` ä¸­å£°æ˜çš„åç§°å¯åœ¨å‘¨å›´èŒƒå›´ä¸­ç›´æ¥ä½¿ç”¨ï¼Œå°±åƒéæˆå‘˜å˜é‡ä¸€æ ·ã€‚è¿™æ„å‘³ç€åŒ¿å `union` ä¸­å£°æ˜çš„åç§°å¿…é¡»åœ¨å‘¨è¾¹èŒƒå›´ä¸­æ˜¯å”¯ä¸€çš„ã€‚åŒ¿å `union` å—ä»¥ä¸‹é™åˆ¶çš„çº¦æŸï¼š
- å¦‚æœæ˜¯åœ¨æ–‡ä»¶æˆ–å‘½åç©ºé—´èŒƒå›´å†…å£°æ˜çš„ï¼Œè¿˜å¿…é¡»å°†å…¶å£°æ˜ä¸º `static`ã€‚
- å®ƒåªèƒ½æœ‰ `public` æˆå‘˜ï¼›åœ¨ä¸€ä¸ªåŒ¿åçš„ `union` ä¸­æ‹¥æœ‰ `private` æˆå‘˜å’Œ `protected` æˆå‘˜ä¼šäº§ç”Ÿé”™è¯¯ã€‚
- å®ƒä¸èƒ½å…·æœ‰æˆå‘˜å‡½æ•°ã€‚

```c++
// æ–‡ä»¶èŒƒå›´æˆ–å‘½åç©ºé—´èŒƒå›´çš„åŒ¿å union
static union {
    short       iValue;
    long        lValue;
    double      dValue;
}

// ç»“æ„ä¸­çš„åŒ¿å union
struct Input
{
    WeatherDataType type;
    union
    {
        TempData temp;
        WindData wind;
    };
};
```

`union` å¯ä»¥åŒ…å«å…·æœ‰ `class` ç±»å‹çš„é `static` æ•°æ®æˆå‘˜ï¼›å¦‚æœåŒ…å«è¿™æ ·ä¸€ä¸ªæˆå‘˜ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å°†éç”¨æˆ·æä¾›çš„ä»»ä½•ç‰¹æ®Šæˆå‘˜å‡½æ•°æ ‡è®°ä¸º `delete`ã€‚å¦‚æœ `union` æ˜¯ `class` æˆ– `struct` ä¸­çš„åŒ¿åè”åˆï¼Œåˆ™ `class` æˆ– `struct` çš„éç”¨æˆ·æä¾›çš„ä»»ä½•ç‰¹æ®Šæˆå‘˜å‡½æ•°éƒ½ä¼šè¢«æ ‡è®°ä¸º `delete`ã€‚


---
### å‡½æ•°

å‡½æ•°æ˜¯æ‰§è¡ŒæŸç§æ“ä½œçš„ä»£ç å—ã€‚åœ¨ç±»èŒƒå›´ä¸­å®šä¹‰çš„å‡½æ•°ç§°ä¸ºæˆå‘˜å‡½æ•°ã€‚å‡½æ•°è¿˜å¯ä»¥åœ¨å‘½åç©ºé—´èŒƒå›´ä¸­å®šä¹‰ï¼ˆåŒ…æ‹¬éšå¼å…¨å±€å‘½åç©ºé—´ï¼‰ã€‚è¿™ç±»å‡½æ•°ç§°ä¸º *Free* å‡½æ•°æˆ–éæˆå‘˜å‡½æ•°ã€‚å‡½æ•°å¯ä»¥é‡è½½ã€‚

```c++
struct S{
    void foo();  // æˆå‘˜å‡½æ•°ï¼Œå£°æ˜
}
void S::foo() {} // å®šä¹‰, S::foo è°ƒç”¨

void foo(){}   // Free å‡½æ•°ï¼› ::foo() è°ƒç”¨
```



>---
#### å‡½æ•°å£°æ˜ä¿®é¥°ç¬¦

æœ€å¤šåªæœ‰ä¸€ä¸ªé“¾æ¥å±æ€§å£°æ˜ï¼Œå…¶ä»–å±æ€§å’Œä¿®é¥°å¯ä»¥ç»„åˆã€‚
- `constexpr` ä¿®é¥°å‡½æ•°è¿”å›å€¼ï¼Œè¡¨æ˜å‡½æ•°ç”Ÿæˆçš„å€¼å¯åœ¨ç¼–è¯‘æ—¶ç¡®å®šã€‚
- `extern "C"` or `extern "C++"` å£°æ˜å‡½æ•°é“¾æ¥è§„èŒƒã€‚
- `static` å£°æ˜å‡½æ•°çš„å†…éƒ¨é“¾æ¥ã€‚
- `extern` å¤–éƒ¨å¼•ç”¨å£°æ˜ï¼ˆéå®šä¹‰ï¼‰ï¼Œæˆ–å¤–éƒ¨é“¾æ¥å£°æ˜å®šä¹‰ã€‚ 
- `inline` å£°æ˜å†…è”å‡½æ•°ã€‚
- `noexcept` æŒ‡å®šå‡½æ•°æ˜¯å¦å¯ä»¥å¼•å‘å¼‚å¸¸ã€‚

```c++
extern "C" void CCall();
extern "C++" void CXXCall();
static void foo();
extern void foo(auto x);
static constexpr int Sum(const int x, const int y)  {
	return x + y;
}
static inline volatile int foo(int&);
extern "C" const int errHandler(int code) noexcept;
```

- `const` æˆ– `volatile` ä¿®é¥°å‚æ•°æˆ–è¿”å›ç±»å‹ã€‚ 

```c++
volatile auto Temp(const auto a, volatile auto b);
const int Sample::GetValue();
```


ä»…é™æˆå‘˜å‡½æ•°ï¼š
- `static` å£°æ˜é™æ€æˆå‘˜å‡½æ•°ï¼Œè¡¨æ˜å‡½æ•°ä¸ä¸ç±»çš„ä»»ä½•å¯¹è±¡å®ä¾‹å…³è”ï¼ˆæ— æ³•è°ƒç”¨ `this`ï¼‰ã€‚
- `const` or `volatile` å‡½æ•° cv é™å®šï¼Œä»…é™éé™æ€ï¼›åªæ˜¯å‡½æ•°ä»…ç”± `const` ç±»å‹è°ƒç”¨è¿˜æ˜¯ `volatile` ç±»å‹è°ƒç”¨ã€‚
- `virtual`ã€`override` æˆ– `final` æŒ‡å®šæˆå‘˜å‡½æ•°æ˜¯è™šå‡½æ•°ã€é‡å†™ç»§æ‰¿çš„è™šå‡½æ•°ã€è¿˜æ˜¯å¯†å°å‡½æ•°ï¼Œä»…é™éé™æ€ã€‚
- `&`ã€`&&` ref å¼•ç”¨é™å®šï¼Œä»…é™éé™æ€æˆå‘˜å‡½æ•°ï¼Œè¡¨æ˜éšå¼å¯¹è±¡å‚æ•° (`*this`) æ˜¯å³å€¼å¼•ç”¨æˆ–å·¦å€¼å¼•ç”¨æ—¶è¦é€‰æ‹©çš„å‡½æ•°é‡è½½ã€‚

```c++
class Base {
	virtual void OverrideFun() volatile;
	virtual void FinalFun() const;
	virtual void LRefFun()&;
	virtual void RRefFun()&&;
};
class Sample : Base {
	void ConstFun() const;
	void VolatileFun() volatile;
	static void StaticFun();
	virtual void VirtualFun();
	void OverrideFun() volatile override;
	void FinalFun() const final;
	void LRefFun() & override;
	void RRefFun() && override;
	void RRefFun() const&&;    // é‡è½½
	void RRefFun() volatile&&;
};
```

>---
#### å‡½æ•°åŸå‹ä¸å®šä¹‰å£°æ˜

å‡½æ•°åŸå‹å£°æ˜æ²¡æœ‰å‡½æ•°ä¸»ä½“ï¼Œæ˜¯æ²¡æœ‰å®Œæ•´å®šä¹‰çš„å‡½æ•°æ ·å¼å£°æ˜ï¼Œå¯ä»¥æ²¡æœ‰å‚æ•°åç§°ï¼Œå‡½æ•°çš„ä¸»ä½“åœ¨å…¶ä»–ä½ç½®å®šä¹‰ï¼›è°ƒç”¨æ²¡æœ‰å®šä¹‰çš„å‡½æ•°åŸå‹ä¼šå¼•å‘ç¼–è¯‘æ—¶é”™è¯¯ã€‚ä¸€èˆ¬åœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜å‡½æ•°åŸå‹ï¼›åœ¨æºæ–‡ä»¶ä¸­å£°æ˜å®šä¹‰ã€‚

å‡½æ•°å®šä¹‰å£°æ˜å¿…é¡»å’Œå‡½æ•°åŸå‹å…·æœ‰ç›¸åŒçš„ç­¾åï¼›

```c++
// header.h
void Foo(int);

// header.cpp
void Foo(int v){ ... }; 
```

åœ¨åŒ…å« `main` çš„ç¿»è¯‘å•å…ƒä¸­ `#include "header.cpp"` å¯èƒ½ä¼šå¯¼è‡´å¤šé‡å®šä¹‰å¯¼è‡´é“¾æ¥å¤±è´¥ã€‚ 

>---
#### å‡½æ•°è¿”å›ç±»å‹

å‡½æ•°ä¸èƒ½è¿”å›å¦ä¸€ä¸ªå‡½æ•°æˆ–å†…ç½®æ•°ç»„ï¼›ä½†æ˜¯å¯ä»¥è¿”å›è¿™äº›ç±»å‹çš„æŒ‡é’ˆï¼Œæˆ–ç”Ÿæˆå‡½æ•°å¯¹è±¡çš„ lambdaã€‚é™¤æ­¤ä¹‹å¤–å¯ä»¥è¿”å›èŒƒå›´å†…çš„ä»»ä½•ç±»å‹çš„å€¼æˆ– `void` æ— è¿”å›ã€‚å¯ä»¥ä½¿ç”¨ `auto` æŒ‡ç¤ºç¼–è¯‘å™¨ä»å‡½æ•°ä½“æ¨æ–­è¿”å›ç±»å‹ï¼Œè€Œä¸å¿…æä¾›ç»“å°¾è¿”å›çš„å…·ä½“ç±»å‹ï¼Œ`auto` å§‹ç»ˆæ¨å¯¼ä¸ºæŒ‰å€¼è¿”å›ï¼Œä¸”ä¸ä¼šä¿ç•™å®ƒæ¨åˆ°çš„ç±»å‹çš„å¸¸é‡æ€§ç­‰å±æ€§ã€‚

```c++
int getInt();
std::string getString();
void VoidReturn();
void* getBuffer(size_t size);

template<typename T> 
T* createArray(size_t size);

typedef void (*pf)();
pf getFunPtr();

template<typename Lhs, typename Rhs>
auto Add2(const Lhs& lhs, const Rhs& rhs)
{
    return lhs + rhs; // returns a non-const object by value
}
```

è¿”å›ç±»å‹å¯ä»¥æœ‰ `const` æˆ– `volatile` é™å®šï¼Œæˆ–æŒ‰å¼•ç”¨è¿”å›ï¼›`auto&`ã€`auto&&` æŒ‰å¼•ç”¨è¿”å›ï¼š

```c++
const char * hello = "hello world";
const char*& getString() { return hello; }

volatile class Time {};
volatile Time& timeNow();

auto&& getValue();
```

> *ç»“å°¾è¿”å›ç±»å‹*

ç»“å°¾è¿”å›ç±»å‹ä½äºç­¾åçš„æœ€å³ä¾§ï¼Œå¸¦æœ‰ `-> decltype( expr )`ï¼›å½“è¿”å›å€¼çš„ç±»å‹å–å†³äºæ¨¡æ¿å‚æ•°æ—¶ï¼Œç»“å°¾è¿”å›ç±»å‹åœ¨å‡½æ•°æ¨¡æ¿ä¸­å°¤å…¶æœ‰ç”¨ã€‚å½“ `auto` ä¸ç»“å°¾è¿”å›ç±»å‹ç»“åˆä½¿ç”¨æ—¶ï¼Œå®ƒå¯¹äº `decltype` è¡¨è¾¾å¼ç”Ÿæˆçš„ä»»ä½•å†…å®¹éƒ½åªç”¨ä½œå ä½ç¬¦ï¼Œæœ¬èº«ä¸æ‰§è¡Œç±»å‹æ¨å¯¼ã€‚

`decltype(auto)` ç±»å‹æ¨æ–­è§„åˆ™å°†ä¿ç•™æ‰€æœ‰ç±»å‹ä¿¡æ¯ã€‚

```c++
template<typename Lhs, typename Rhs>
auto Add(const Lhs& lhs, const Rhs& rhs) -> decltype(lhs + rhs)
{
    return lhs + rhs;
}
// ç­‰æ•ˆå†™æ³•
template<typename Lhs, typename Rhs>
decltype(auto) Add(const Lhs& lhs, const Rhs& rhs)
{
    return lhs + rhs;
}
```

> å¤šå€¼è¿”å›

å¯é€šè¿‡å¤šç§æ–¹å¼ä»å‡½æ•°è¿”å›å¤šä¸ªå€¼ï¼›
- å°†å€¼å°è£…åœ¨å‘½åç±»æˆ–ç»“æ„å¯¹è±¡ä¸­ã€‚è¦æ±‚ç±»æˆ–ç»“æ„å®šä¹‰å¯¹è°ƒç”¨æ–¹å¯è§ï¼›

```c++
struct S
{
    string name;
    int num;
};
S g(){ return {"name", 110 } };
```

- è¿”å› `std::tuple` æˆ– `std::pair` å¯¹è±¡ï¼›

```c++
std::tuple<int, string, double> f()
{
    int i{ 108 };
    string s{ "Some text" };
    double d{ .01 };
    return { i,s,d };
}
int main()
{
    auto t = f();
    cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;
    // --or--
    int myval;
    string myname;
    double mydecimal;
    tie(myval, myname, mydecimal) = f();
    cout << myval << " " << myname << " " << mydecimal << endl;
}
```

- ä½¿ç”¨ç»“æ„åŒ–ç»‘å®š `auto[v1,v2,...] = f()`ï¼›å­˜å‚¨è¿”å›å€¼çš„å˜é‡åœ¨å£°æ˜çš„åŒæ—¶è¢«åˆå§‹åŒ–ã€‚

```c++
auto[a, b] = g();    // init from POD struct S
auto[x, y, z] = f(); // init from tuple

cout << a << " " << b << endl;
cout << x << " " << y << " " << z << endl;
```

- ä½¿ç”¨ ref å¼•ç”¨ä¼ é€’çš„å‚æ•°è¿”å›ï¼›å‡½æ•°å¯ä»¥ä¿®æ”¹æˆ–åˆå§‹åŒ–è°ƒç”¨æ–¹æä¾›çš„å¼•ç”¨å¯¹è±¡çš„å€¼ï¼š

```c++
int foo(const int in, int& out) {
    out = in;
    return in;
}
```

>---
#### å‡½æ•°å½¢å‚å®å‚

å‡½æ•°å…·æœ‰é›¶ç§æˆ–å¤šç§ç±»å‹çš„é€—å·åˆ†éš”å‚æ•°åˆ—è¡¨ï¼Œå…¶ä¸­æ¯ä¸ªå‚æ•°éƒ½å…·æœ‰å¯ä»¥ç”¨äºåœ¨å‡½æ•°ä½“å†…è®¿é—®å®ƒçš„åç§°ã€‚å‡½æ•°æ¨¡æ¿å¯ä»¥æŒ‡å®šæ›´å¤šç±»å‹æˆ–å€¼å‚æ•°ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œå‚æ•°é€šè¿‡å€¼ä¼ é€’ç»™å‡½æ•°ï¼Œè¿™æ„å‘³ç€å‡½æ•°ä¼šæ”¶åˆ°æ‰€ä¼ é€’çš„å¯¹è±¡çš„å‰¯æœ¬ï¼š

```c++
void DoSomething(std::string input){...}
```

è‹¥ä¼ é€’çš„æ•°æ®ç±»å‹åˆ›å»ºå‰¯æœ¬çš„æˆæœ¬è¿‡é«˜ï¼Œå¯ä»¥æŒ‰å¼•ç”¨ä¼ é€’å‚æ•°ï¼š

```c++
void DoSomething(std::string& input){...}
```

è‹¥è¦æ˜¾å¼å¤„ç†é€šè¿‡å³å€¼å¼•ç”¨æˆ–é€šè¿‡å·¦å€¼å¼•ç”¨ä¼ é€’çš„è‡ªå˜é‡ï¼š

```c++
void DoSomething(std::string&& input){...}
```

å‚æ•°å¯ä»¥æœ‰ `const` æˆ– `volatile` é™å®šä¿®é¥°ï¼Œè¡¨æ˜å‚æ•°æ˜¯åªè¯»æˆ–æ˜“å˜å±æ€§ï¼š

```c++
void DoSomething(const std::string& input, volatile int msgCode){...}
```

æ— å‚æ—¶å¯é€‰ä½¿ç”¨ C é£æ ¼çš„ `void`ï¼š

```c++
void DoSomething( void ){...}
```

>---
#### éé™æ€æˆå‘˜å‡½æ•°çš„éšå¼ *this* å‚æ•° 

`static` å‡½æ•°æ²¡æœ‰æä¾› `this` æŒ‡é’ˆä½œä¸ºç¬¬ä¸€ä¸ªä¼ é€’çš„éšå¼å‚æ•°ï¼›éé™æ€çš„æˆå‘˜å‡½æ•°è¦æ±‚éšå¼ `this` æŒ‡é’ˆå–è°ƒç”¨è¯¥å‡½æ•°çš„å¯¹è±¡ç±»å‹ç›¸åŒ¹é…ï¼›
- å¸¸è§„å‡½æ•°ä¸­ `this` è¢«è§†ä¸º `class_name * const`ï¼›
- åœ¨ `const` é™å®šå‡½æ•°ä¸­ï¼Œ`this` æ˜¯ `const class_name * const`ï¼›
- åœ¨ `volatile` é™å®šå‡½æ•°ä¸­ï¼Œ`this` æ˜¯ `volatile class_name * const`ï¼›

`obj.name` çš„æˆå‘˜è¿ç®—ç¬¦å®é™…ä¸Šæ˜¯ `(&obj)->name`ï¼›éé™æ€æˆå‘˜å‡½æ•°çš„è°ƒç”¨ï¼Œå®é™…ä¸Šæ˜¯ `func(&obg, argu-list)`

```c++
class S {
public:
	// cv é™å®šåŒºåˆ†
	void foo() { cout << "normal foo\n"; }
	void foo() const { cout << "const foo\n"; }
	void foo() volatile { cout << "volatile foo\n"; }
};
int main()
{
	S s{};  	      s.foo();	// normal foo
	const S cs{};     cs.foo();	// const foo
	volatile S vs{};  vs.foo();	// volatile foo

}
```

å¼•ç”¨é™å®šç¬¦å¯ä»¥æ ¹æ® `this` æŒ‡å‘çš„å¯¹è±¡æ˜¯ `rvalue` è¿˜æ˜¯ `lvalue` æ¥é‡è½½æˆå‘˜å‡½æ•°ã€‚ä½†è¦æ±‚æ‰€æœ‰ç­¾åç›¸åŒçš„æˆå‘˜å‡½æ•°éƒ½å…·æœ‰æˆ–ä¸å…·æœ‰å¼•ç”¨é™å®šï¼š

```c++
class S {
public:
    // ref é™å®š
	void foo()& { cout << "& foo\n"; }
	void foo()const& { cout << "const& foo\n"; }
	void foo()volatile& { cout << "volatile& foo\n"; }
	void foo()&& { cout << "&& foo\n"; }
	void foo()const&& { cout << "const&& foo\n"; }
	void foo()volatile&& { cout << "volatile&& foo\n"; }
}
const S&& getRCS() { return S{}; }
volatile S&& getRVS() { return S{}; }
int main()
{
	S s{};			 s.foo();	// & foo
	const S cs{};	 cs.foo();	// const& foo
	volatile S vs{}; vs.foo();	// volatile& foo

	S& ls = s;			  ls.foo();	 // & foo
	const S& lcs{};		  lcs.foo(); // const& foo
	volatile S& lvs = s;  lvs.foo(); // volatile& foo

	/* rs */  (S{}).foo();	  // && foo
	/* rcs */ getRCS().foo(); // const&& foo
	/* rvs */ getRVS().foo(); // volatile&& foo
}
```




>---
#### é»˜è®¤å‚æ•°å€¼

å‡½æ•°ç­¾åä¸­çš„æœ€åä¸€ä¸ªæˆ–å‡ ä¸ªå‚æ•°å¯èƒ½ä¼šåˆ†é…æœ‰é»˜è®¤è‡ªå˜é‡ï¼Œè¿™æ„å‘³ç€è°ƒç”¨æ–¹å¯èƒ½ä¼šåœ¨è°ƒç”¨å‡½æ•°æ—¶çœç•¥è‡ªå˜é‡ã€‚å½“å‡½æ•°é‡è½½å†³åŒæ—¶åŒ¹é…å¸¸è§„å‡½æ•°å’Œå…·æœ‰é»˜è®¤å‚æ•°çš„å‡½æ•°æ—¶ï¼Œåˆ™ä¼šå¼•å‘äºŒä¹‰æ€§é”™è¯¯ã€‚

```c++
int print( double dvalue );                // Print a double.
int print( double dvalue, int prec);       // Print a double with a given precision.
// å¯ä»¥å°† `print double` è¿›è¡ŒåŠŸèƒ½åˆå¹¶ï¼Œå¹¶å¯¹ `prec` æä¾›é»˜è®¤å€¼ï¼š
int print( double dvalue, int prec=2 ); 
```

>---
#### å¯å˜å‚æ•°

å‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°å¯ä»¥æ˜¯å¯å˜å‚æ•° `...`ï¼Œè®¿é—®å¯å˜å‚æ•°ä½¿ç”¨å¤´æ–‡ä»¶ `stdarg.h` ä¸­çš„ `va_arg`ã€`va_copy`ã€`va_end`ã€`va_start`ã€‚`char` ä¼ é€’ç»™å¯å˜å‚æ•°æ—¶è½¬æ¢ä¸º `int`ï¼›`flaot` è½¬æ¢ä¸º `double`ï¼›å…¶ä»–ç±»å‹çš„å€¼å—å¸¸è§æ•´æ•°å’Œæµ®ç‚¹æ•°æ•°å€¼æå‡çš„é™åˆ¶ã€‚

```c++
#include <cstdarg>
// çº¦å®š f = float,c=char,s=char*,i=int
void ShowVar(const char* szTypes, ...);
int main() {
    ShowVar("fcsi", 32.4f, 'a', "Test string", 4);
}
void ShowVar(char* szTypes, ...) {  
    va_list vl;
    int i;
    va_start(vl, szTypes);
    for (i = 0; szTypes[i] != '\0'; ++i) {
        union Printable_t {
            int     i;
            float   f;
            char    c;
            char* s;
        } Printable;
        switch (szTypes[i]) {   // Type to expect.
        case 'i':
            Printable.i = va_arg(vl, int);
            printf_s("%i\n", Printable.i);
            break;
        case 'f':
            Printable.f = va_arg(vl, double);
            printf_s("%f\n", Printable.f);
            break;
        case 'c':
            Printable.c = va_arg(vl, char);
            printf_s("%c\n", Printable.c);
            break;
        case 's':
            Printable.s = va_arg(vl, char*);
            printf_s("%s\n", Printable.s);
            break;
        default:
            break;
        }
    }
    va_end(vl);
}
```

>---
#### å‡½æ•°é‡è½½

å…è®¸åœ¨åŒä¸€èŒƒå›´å†…æŒ‡å®šå¤šä¸ªåŒåå‡½æ•°ã€‚è¿™äº›å‡½æ•°ç§°ä¸ºé‡è½½å‡½æ•°æˆ–é‡è½½ã€‚å¯ä»¥æ ¹æ®å‚æ•°çš„ç±»å‹å’Œæ•°é‡ä¸ºå‡½æ•°æä¾›ä¸åŒçš„è¯­ä¹‰ã€‚æ— æ³•é€šè¿‡è¿”å›ç±»å‹çš„ä¸åŒå’Œ `noexcept` å¼‚å¸¸è§„èŒƒè¿›è¡Œé‡è½½ã€‚

å¯ä»¥é€šè¿‡å‚æ•°æ•°ç›®ã€ç±»å‹ã€æ˜¯å¦åŒ…å«å¯å˜å‚æ•°ã€`const` æˆ– `volatile` å‡½æ•°é™å®šã€`&` æˆ– `&&` é™å®šç­‰åŒºåˆ†ç”¨äºé‡è½½ï¼š

```c++
class S {
public:
	void foo() {}
	void foo(int, ...) {}    // å¯å˜å‚æ•°åŒºåˆ†
	void foo(int, float) {}  // å‚æ•°æ•°ç›®åŒºåˆ†

	// å‚æ•°ç±»åˆ«åŒºåˆ†
	// void foo(int) {} 
	void foo(long) {}
	void foo(int&) {}     // è°ƒç”¨ int a; foo(a) æ— æ³•åŒºåˆ† foo(int) ä¸ foo(int&)
	void foo(const int&) {}
	void foo(volatile int&) {}
	void foo(int&&) {}   // è°ƒç”¨ foo(10) æ— æ³•åŒºåˆ† foo(int) ä¸ foo(int&&)
	void foo(const int&&) {}
	void foo(volatile int&&) {}

	// cv é™å®šåŒºåˆ†
	void foo(int) const {}
	void foo(int) volatile {}

	// ref é™å®šåŒºåˆ†
	// ä»…é€šè¿‡å¼•ç”¨é™å®šè¿›è¡ŒåŒºåˆ†çš„é‡è½½éœ€è¦å…¨éƒ¨éƒ½å…·æœ‰å¼•ç”¨é™å®šæˆ–éƒ½ä¸å…·æœ‰
	void foo(float)& {}
	void foo(float)&& {}
	void foo(float)const& {}
	void foo(float)const&& {}
	void foo(float)volatile& {}
	void foo(float)volatile&& {}

	void foo(auto) {}
	// å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œä½†æ— æ³•é€šè¿‡å‡½æ•°å†³ç­–; å®ƒä»¬æ— æ³•è¿›è¡ŒåŒºåˆ†
    template<typename T>
	decltype(auto) foo(T t) { return t; }
	template<typename T>
	// auto foo(T t) { return t; }    
	// template<typename T>
	// auto foo(T t) -> decltype(t) { return t; }
};
```

ç¼–è¯‘å™¨æ ¹æ®å½“å‰èŒƒå›´å†…çš„å‡½æ•°å£°æ˜ä¸å‡½æ•°è°ƒç”¨ä¸­æä¾›çš„å‚æ•°çš„æœ€ä½³åŒ¹é…ï¼Œæ¥é€‰æ‹©è¦è°ƒç”¨çš„é‡è½½å‡½æ•°ã€‚å¦‚æœæ‰¾åˆ°åˆé€‚çš„å‡½æ•°ï¼Œåˆ™è°ƒç”¨è¯¥å‡½æ•°ã€‚ç¼–è¯‘å™¨ä¸ºæ¯ä¸ªè‡ªå˜é‡åˆ›å»ºä¸€ç»„å€™é€‰å‡½æ•°ã€‚å…¶ä¸­çš„å®é™…è‡ªå˜é‡å¯ä»¥è½¬æ¢ä¸ºå½¢å¼è‡ªå˜é‡çš„ç±»å‹ã€‚ä¸ºæ¯ä¸ªè‡ªå˜é‡ç”Ÿæˆä¸€ç»„ â€œæœ€ä½³åŒ¹é…å‡½æ•°â€ï¼Œå¹¶ä¸”æ‰€é€‰å‡½æ•°æ˜¯æ‰€æœ‰é›†çš„äº¤é›†ã€‚å¦‚æœäº¤é›†åŒ…å«å¤šä¸ªå‡½æ•°ï¼Œåˆ™é‡è½½æ˜¯ä¸æ˜ç¡®çš„å¹¶ä¼šç”Ÿæˆé”™è¯¯ã€‚

> *Microsoft ä¸“ç”¨:*

å¯ä»¥æ ¹æ®è¿”å›ç±»å‹é‡è½½ `operator new`ï¼Œç‰¹åˆ«æ˜¯æ ¹æ®æŒ‡å®šçš„å†…å­˜æ¨¡å‹ä¿®é¥°ç¬¦ã€‚

```c++
// Microsoft C++


```

> *å‚æ•°åŒ¹é…å’Œè½¬æ¢*

å½“ç¼–è¯‘å™¨å°è¯•æ ¹æ®å‡½æ•°å£°æ˜ä¸­çš„å‚æ•°åŒ¹é…å®é™…å‚æ•°æ—¶ï¼Œå¦‚æœæœªæ‰¾åˆ°ä»»ä½•ç¡®åˆ‡åŒ¹é…é¡¹ï¼Œå®ƒå¯ä»¥æä¾›æ ‡å‡†è½¬æ¢æˆ–ç”¨æˆ·å®šä¹‰çš„è½¬æ¢æ¥è·å–æ­£ç¡®ç±»å‹ã€‚ä¸è€ƒè™‘åŒ…å«å¤šä¸ªç”¨æˆ·å®šä¹‰è½¬æ¢çš„è½¬æ¢åºåˆ—ã€‚ä¹Ÿä¸è€ƒè™‘å¯é€šè¿‡åˆ é™¤ä¸­é—´è½¬æ¢æ¥ç¼©çŸ­çš„è½¬æ¢åºåˆ—ã€‚

å¸¸ç”¨è½¬æ¢æœ‰ï¼š

```c++
typename        to  	typename&
typename&	    to      typename
typename[]	    to      typename*
typename	    to      const typename
typename	    to      volatile typename
typename*	    to      const typename*
typename*	    to      volatile typename*
typename(argument-list)   to  	(*typename)(argument-list)
```

è¿˜åŒ…æ‹¬æ•°å€¼æå‡ï¼Œç®€å•ç±»å‹éšå¼è½¬æ¢ç­‰ã€‚æšä¸¾ç±»å‹æ˜¯ä¸åŒçš„ç±»å‹ï¼Œå¹¶ä¸”å¯ç”¨äºåŒºåˆ†é‡è½½å‡½æ•°ã€‚ç±»å‹ â€œarray ofâ€ å’Œ â€œpointer toâ€ æ˜¯ç­‰æ•ˆçš„ï¼Œé€‚ç”¨ä¸€ç»´æ•°ç»„ã€‚

ä»æŒ‡å‘æ´¾ç”Ÿç±»çš„æŒ‡é’ˆåˆ°æŒ‡å‘ç›´æ¥æˆ–é—´æ¥åŸºç±»çš„æŒ‡é’ˆçš„è½¬æ¢ä¼˜äºåˆ° `void *` æˆ– `const void *` çš„è½¬æ¢ã€‚ä»æŒ‡å‘æ´¾ç”Ÿç±»çš„æŒ‡é’ˆåˆ°æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆçš„è½¬æ¢ä¼šäº§ç”Ÿä¸€ä¸ªåˆ°ç›´æ¥åŸºç±»çš„æ›´å¥½åŒ¹é…ã€‚

å¦‚æœå†…ç½®æå‡æˆ–è½¬æ¢ä¸å­˜åœ¨ï¼Œåˆ™ç”¨æˆ·å®šä¹‰çš„è½¬æ¢å°†é€‚ç”¨ã€‚è¿™äº›è½¬æ¢æ˜¯æ ¹æ®è¦åŒ¹é…çš„å‚æ•°çš„ç±»å‹æ¥é€‰æ‹©çš„ã€‚

```c++
class UDC
{
public:
   operator int() { return 0;}
   operator long();
};
void Print( int i ) {};
void LogToFile( long l ){};
int main()
{
    UDC udc;
    Print( udc ); // use operator int() 
    
    LogToFile(udc); // check operator long()
    // ç”±äº UDC:operator long() æ²¡æœ‰å®šä¹‰ï¼Œå› æ­¤ç¼–è¯‘å™¨é¦–å…ˆä½¿ç”¨ int(), å†è¿›è¡Œæ•°å€¼æå‡ int to long çš„æ ‡å‡†è½¬æ¢  
}
```

å¦‚æœéœ€è¦ä»»ä½•ç”¨æˆ·å®šä¹‰çš„è½¬æ¢æ¥åŒ¹é…å‚æ•°ï¼Œåˆ™åœ¨è®¡ç®—æœ€ä½³åŒ¹é…æ—¶ä¸ä¼šä½¿ç”¨æ ‡å‡†è½¬æ¢ã€‚å³ä½¿å¤šä¸ªå€™é€‰å‡½æ•°éœ€è¦ç”¨æˆ·å®šä¹‰çš„è½¬æ¢ï¼Œè¿™äº›å‡½æ•°ä¹Ÿè¢«è®¤ä¸ºæ˜¯ç›¸ç­‰çš„ã€‚

```c++
class UDC1
{
public:
   UDC1( int );  // User-defined conversion from int.
};
class UDC2
{
public:
   UDC2( long ); // User-defined conversion from long.
};
void Func( UDC1 );
void Func( UDC2 );
int main()
{
   Func( 1 );   // äºŒä¹‰æ€§
}
```

> *é‡è½½ã€é‡å†™å’Œéšè—*

åœ¨åŸºç±»ä¸­å£°æ˜çš„å‡½æ•°ä¸åœ¨æ´¾ç”Ÿç±»ä¸­å£°æ˜çš„å‡½æ•°ä¸åœ¨åŒä¸€èŒƒå›´å†…ã€‚ å¦‚æœä½¿ç”¨ä¸åŸºç±»ä¸­çš„ `virtual` å‡½æ•°ç›¸åŒçš„åç§°å£°æ˜æ´¾ç”Ÿç±»ä¸­çš„å‡½æ•°ï¼Œåˆ™è¯¥æ´¾ç”Ÿç±»å‡½æ•°ä¼šé‡å†™åŸºç±»å‡½æ•°ã€‚å¦‚æœæ´¾ç”Ÿç±»å‡½æ•°æ²¡æœ‰ `virtual`ã€`override`ã€`final`ï¼Œåˆ™è§†ä¸ºè¯¥åŒååç§°çš„å‡½æ•°éšè—äº†åŸºç±»å‡½æ•°ã€‚

å—ä¸­å£°æ˜çš„æœ¬åœ°å‡½æ•°ï¼ˆå¼•ç”¨å¤–éƒ¨ï¼‰ä¸å¤–éƒ¨èŒƒå›´çš„å‡½æ•°æˆ–æˆå‘˜çš„åç§°ç›¸åŒï¼Œè§†ä¸ºéšè—ï¼Œä»…èƒ½é€šè¿‡å®Œå…¨é™å®šï¼ˆé™æ€ class_name::static_funcï¼‰ã€æˆ– `this->member` è®¿é—®è¢«éšè—çš„åç§°ã€‚ 

```c++
void Foo(int) {}
void Foo(const char*) {}
int main()
{
	extern void Foo(const char*);
	Foo("hello");
	Foo(1);    // err;  hidden
	::Foo(1);  // ok;
}
```

é€šè¿‡ `using` å£°æ˜å¼•å…¥åç§°å’Œ `extern` å¼•ç”¨å£°æ˜çš„åç§°ç›¸åŒæ—¶ï¼Œè‹¥æŒ‡å‘åŒä¸€ä¸ªå‡½æ•°å®šä¹‰åˆ™å°†å¼•å‘å†²çªï¼›

```c++
void Foo(int) {}
void Foo(const char*) {}
int main()
{
	extern void Foo(const char*);
    using ::Foo;  // å†²çª
}
```


>---
#### æ˜¾å¼ default å’Œ delete å‡½æ•°

`default` å‡½æ•°å’Œ `delete` å‡½æ•°å¯ä»¥æ˜¾å¼æ§åˆ¶æ˜¯å¦è‡ªåŠ¨ç”Ÿæˆç‰¹æ®Šæˆå‘˜å‡½æ•°ã€‚`delete` å‡½æ•°é˜²æ­¢æ‰€æœ‰ç±»å‹çš„å‡½æ•°ï¼ˆç‰¹æ®Šæˆå‘˜å‡½æ•°å’Œæ™®é€šæˆå‘˜å‡½æ•°ä»¥åŠéæˆå‘˜å‡½æ•°ï¼‰çš„è‡ªå˜é‡ä¸­å‡ºç°æœ‰é—®é¢˜çš„ç±»å‹æå‡ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æ„å¤–çš„å‡½æ•°è°ƒç”¨ã€‚

åœ¨ C++ ä¸­ï¼Œå¦‚æœæŸä¸ªç±»å‹æœªå£°æ˜å®ƒæœ¬èº«ï¼Œåˆ™ç¼–è¯‘å™¨å°†è‡ªåŠ¨ä¸ºè¯¥ç±»å‹ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°ã€å¤åˆ¶æ„é€ å‡½æ•°ã€å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦å’Œææ„å‡½æ•°ã€ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ã€‚è¿™äº›å‡½æ•°ç§°ä¸ºç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œå®ƒä»¬ä½¿ C++ ä¸­çš„ç®€å•ç”¨æˆ·å®šä¹‰ç±»å‹çš„è¡Œä¸ºå¦‚åŒ C ä¸­çš„ç»“æ„ã€‚å…¶ä¸­ï¼š
- æ˜¾å¼å£°æ˜äº†ä»»ä½•æ„é€ å‡½æ•°ï¼Œåˆ™ä¸ä¼šè‡ªåŠ¨ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°ã€‚
- æ˜¾å¼å£°æ˜äº†è™šæ‹Ÿææ„å‡½æ•°ï¼Œåˆ™ä¸ä¼šè‡ªåŠ¨ç”Ÿæˆé»˜è®¤ææ„å‡½æ•°ã€‚
- æ˜¾å¼å£°æ˜äº†ç§»åŠ¨æ„é€ å‡½æ•°æˆ–ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ï¼Œåˆ™ä¸è‡ªåŠ¨ç”Ÿæˆå¤åˆ¶æ„é€ å‡½æ•°å’Œæˆå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ã€‚
- æ˜¾å¼å£°æ˜äº†å¤åˆ¶æ„é€ å‡½æ•°ã€å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ã€ç§»åŠ¨æ„é€ å‡½æ•°ã€ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦æˆ–ææ„å‡½æ•°ï¼Œåˆ™ä¸è‡ªåŠ¨ç”Ÿæˆç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ã€‚
- æ˜¾å¼å£°æ˜äº†å¤åˆ¶æ„é€ å‡½æ•°æˆ–ææ„å‡½æ•°ï¼Œåˆ™å¼ƒç”¨å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦çš„è‡ªåŠ¨ç”Ÿæˆã€‚
- æ˜¾å¼å£°æ˜äº†å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦æˆ–ææ„å‡½æ•°ï¼Œåˆ™å¼ƒç”¨å¤åˆ¶æ„é€ å‡½æ•°çš„è‡ªåŠ¨ç”Ÿæˆã€‚

å¦‚æœåŸºç±»ä¸æ‹¥æœ‰å¯æ´¾ç”Ÿç±»è°ƒç”¨çš„é»˜è®¤æ„é€ å‡½æ•°ï¼Œä¾‹å¦‚æ²¡æœ‰ `public` æˆ– `protected` çš„é»˜è®¤æ„é€ å‡½æ•°ï¼Œé‚£ä¹ˆæ´¾ç”Ÿç±»æ— æ³•è‡ªåŠ¨ç”Ÿæˆå®ƒè‡ªå·±çš„é»˜è®¤æ„é€ å‡½æ•°ã€‚

è¿˜æœ‰ä¾‹å¦‚ï¼Œåœ¨ C++11 ä¹‹å‰ï¼Œé€šè¿‡ä»¥ç§æœ‰æ–¹å¼å£°æ˜å¤åˆ¶æ„é€ å‡½æ•°å’Œå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ï¼Œè€Œä¸å®šä¹‰å®ƒä»¬ï¼Œä½¿ç”¨æˆ·å®šä¹‰ç±»å‹ä¸å¯å¤åˆ¶ï¼š

```c++
struct noncopyable
{
  noncopyable() {};
private:
  noncopyable(const noncopyable&);
  noncopyable& operator=(const noncopyable&); 
};
```

ä½†æ˜¯å®ƒå­˜åœ¨å‡ ä¸ªé—®é¢˜ï¼š
- ç§æœ‰æ–¹å¼å£°æ˜çš„å¤åˆ¶æ„é€ å‡½æ•°æ˜¯æ˜¾å¼å®Œå…¨å£°æ˜çš„ï¼›å› æ­¤ä¼šé˜»æ­¢è‡ªåŠ¨ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°ï¼›
- å°½ç®¡æ˜¾å¼å®šä¹‰çš„èµ‹å€¼æ„é€ å‡½æ•°ä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œç¼–è¯‘å™¨ä¹Ÿä¼šå°†å®ƒè§†ä¸ºé‡è¦å†…å®¹ï¼Œå…¶æ•ˆç‡ä½äºè‡ªåŠ¨ç”Ÿæˆçš„é»˜è®¤æ„é€ å‡½æ•°ï¼›å¹¶ä¸” `noncopyable` æ— æ³•ç§°ä¸º POD ç±»å‹ã€‚
- æˆå‘˜å‡½æ•°å’Œ `noncopyable` çš„å‹å…ƒä»å¯ä»¥è°ƒç”¨å®ƒä»¬ï¼ˆåä¹‰ä¸Šæ˜¯éšè—ï¼‰ï¼›æœªå®šä¹‰æ—¶è°ƒç”¨å®ƒä»¬ä¼šå¯¼è‡´é“¾æ¥å™¨é”™è¯¯ï¼›

ä¸å¯å¤åˆ¶çš„ä¹ è¯­å¯é€šè¿‡æ›´ç›´æ¥çš„æ–¹æ³•å®ç°ï¼š

```c++
struct noncopyable
{
  noncopyable() =default;   // è‡ªåŠ¨ç”Ÿæˆ
  noncopyable(const noncopyable&) =delete; 
  noncopyable& operator=(const noncopyable&) =delete;
};
```

- ä»å¯é€šè¿‡å£°æ˜å¤åˆ¶æ„é€ å‡½æ•°æ¥é˜»æ­¢ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°ï¼Œä½†å¯é€šè¿‡å°†å…¶æ˜¾å¼è®¾ç½®ä¸º `default` è¿›è¡Œæ¢å¤ã€‚
- æ˜¾å¼è®¾ç½®çš„é»˜è®¤ç‰¹æ®Šæˆå‘˜å‡½æ•°ä»è¢«è§†ä¸ºä¸é‡è¦ï¼Œå› æ­¤æ€§èƒ½ä¸ä¼šä¸‹é™ï¼Œå¹¶ä¸”ä¸ä¼šé˜»æ­¢ `noncopyable` æˆä¸º POD ç±»å‹ï¼›
- å¤åˆ¶æ„é€ å‡½æ•°å’Œå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦æ˜¯å…¬å…±çš„ï¼Œä½†æ˜¯å·²åˆ é™¤ã€‚å®šä¹‰æˆ–è°ƒç”¨å·²åˆ é™¤å‡½æ•°æ˜¯ç¼–è¯‘æ—¶é”™è¯¯ã€‚

å¯¹äºåˆ›å»ºä¸å¯ç§»åŠ¨ã€åªèƒ½åŠ¨æ€åˆ†é…æˆ–æ— æ³•åŠ¨æ€åˆ†é…çš„ç”¨æˆ·å®šä¹‰ç±»å‹ï¼›å¯ä»¥é€šè¿‡ `default` å’Œ `delete` æ–¹å¼è¿›è¡Œè®¾å®šã€‚

> *defualt* *ç‰¹æ®Šæˆå‘˜å‡½æ•°*

å¯ä»¥é»˜è®¤è®¾ç½®ä»»ä½•ç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œä»¥æ˜¾å¼å£°æ˜ç‰¹æ®Šæˆå‘˜å‡½æ•°ä½¿ç”¨é»˜è®¤å®ç°ã€å®šä¹‰å…·æœ‰éå…¬å…±è®¿é—®é™å®šç¬¦çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°æˆ–æ¢å¤å…¶ä»–æƒ…å†µä¸‹è¢«é˜»æ­¢å…¶è‡ªåŠ¨ç”Ÿæˆçš„ç‰¹æ®Šæˆå‘˜å‡½æ•°ã€‚é€šè¿‡å¯¹å¯å†…è”çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°è®¾ç½®ä¸º `default` è€Œä¸æ˜¯ç©ºå‡½æ•°ä½“è¿›è¡Œå®ç°ï¼š

```c++
struct widget
{
  widget()=default;
  inline widget& operator=(const widget&);
};
inline widget& widget::operator=(const widget&) =default;
```

> *delete*

å¯ä»¥åˆ é™¤ç‰¹æ®Šæˆå‘˜å‡½æ•°å’Œæ™®é€šæˆå‘˜å‡½æ•°ä»¥åŠéæˆå‘˜å‡½æ•°ï¼Œä»¥é˜»æ­¢å®šä¹‰æˆ–è°ƒç”¨å®ƒä»¬ã€‚åˆ é™¤ç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œå¯ä»¥é˜»æ­¢ç¼–è¯‘å™¨ç”Ÿæˆä¸éœ€è¦çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°ã€‚

```c++
struct widget
{
    // deleted operator new prevents widget from being dynamically allocated.
    void* operator new(std::size_t) = delete;
    widget* operator &() = delete;   // address-of è¢«åˆ é™¤
};
widget w{};
widget* pw = new widget;  // ERR; æ— æ³•è°ƒç”¨åˆ é™¤çš„å‡½æ•°ï¼›ä½†æ˜¯å¯ä»¥è°ƒç”¨å…¨å±€ new ï¼›
widget* pw = ::new widget;  // ok
widget* pw = &w  // ERR; address-of è¢«åˆ é™¤
```

åˆ é™¤æ™®é€šæˆå‘˜å‡½æ•°æˆ–éæˆå‘˜å‡½æ•°å¯é˜»æ­¢æœ‰é—®é¢˜çš„ç±»å‹æå‡å¯¼è‡´è°ƒç”¨æ„å¤–å‡½æ•°ã€‚è¿™å¯å‘æŒ¥ä½œç”¨çš„åŸå› æ˜¯ï¼Œå·²åˆ é™¤çš„å‡½æ•°ä»å‚ä¸é‡è½½å†³ç­–ï¼Œå¹¶æä¾›æ¯”æå‡ç±»å‹ä¹‹åå¯èƒ½è°ƒç”¨çš„å‡½æ•°æ›´å¥½çš„åŒ¹é…ã€‚å‡½æ•°è°ƒç”¨å°†è§£æä¸ºæ›´å…·ä½“çš„ä½†å¯åˆ é™¤çš„å‡½æ•°ï¼Œå¹¶ä¼šå¯¼è‡´ç¼–è¯‘å™¨é”™è¯¯ã€‚

```c++
// deleted overload prevents call through type promotion of float to double from succeeding.
void call_with_true_double_only(float) =delete;
void call_with_true_double_only(double param) { return; }

call_with_true_double_only(3.14f);  // err
call_with_true_double_only(100);  // ok; int cast to double 
```

è‹¥è¦é™åˆ¶å‘ç”Ÿéšå¼ç±»å‹è½¬æ¢ï¼Œç¡®ä¿ä»…å‘ç”Ÿå¯¹ `double` ç±»å‹çš„å‚æ•°è¿›è¡Œè°ƒç”¨ï¼Œå¯å£°æ˜ä¸€ä¸ªæ¨¡æ¿çš„å·²åˆ é™¤ç‰ˆæœ¬ï¼š

```c++
template < typename T >
void call_with_true_double_only(T) =delete; //prevent call through type promotion of any T to double from succeeding.
void call_with_true_double_only(double param) { return; } // also define for const double, double&, etc. as needed.

call_with_true_double_only(3.1415);  // just only double
```


>---
#### å†…è”å‡½æ•°

å‡½æ•°çš„å†…è”å£°æ˜ `inline` è¡¨æ˜å»ºè®®ç¼–è¯‘å™¨ä½¿ç”¨å‡½æ•°å®šä¹‰ä¸­çš„ä»£ç æ›¿æ¢å¯¹è¯¥å‡½æ•°çš„æ¯æ¬¡è°ƒç”¨ã€‚è°ƒç”¨å‡½æ•°éœ€è¦å°†è¿”å›åœ°å€æ¨é€åˆ°å †æ ˆã€å°†å‚æ•°æ¨é€åˆ°å †æ ˆã€è·³è½¬åˆ°å‡½æ•°ä½“ï¼Œç„¶ååœ¨å‡½æ•°å®Œæˆæ—¶æ‰§è¡Œè¿”å›æŒ‡ä»¤ã€‚é€šè¿‡å†…è”å‡½æ•°å¯ä»¥æ¶ˆé™¤æ­¤è¿‡ç¨‹ã€‚å†…è”å‡½æ•°çš„ä¸€ä¸ªç¼ºç‚¹æ˜¯ç¨‹åºçš„æ•´ä½“å¤§å°å¯èƒ½ä¼šå¢åŠ ã€‚

ç±»å£°æ˜çš„ä¸»ä½“ä¸­å®šä¹‰çš„å‡½æ•°æ˜¯éšå¼å†…è”å‡½æ•°ã€‚æˆå‘˜å‡½æ•°åœ¨å¤–éƒ¨å®šä¹‰å¯ä»¥æ˜¾å¼å£°æ˜ä¸º `inline` å‡½æ•°ï¼š

```c++
struct widget
{
	widget();  
	void inlinefoo();
	void* operator new(std::size_t) = delete;  // implicit inline
	widget* operator &() = delete;  // implicit inline
};
widget::widget() {}  // not inline
inline void widget::inlinefoo() {};  // explicit inline
```

ç»™å®šçš„å†…è”æˆå‘˜å‡½æ•°åœ¨æ¯ä¸ªç¼–è¯‘å•å…ƒä¸­å¿…é¡»ä»¥ç›¸åŒçš„æ–¹å¼è¿›è¡Œå£°æ˜ã€‚å†…è”å‡½æ•°å¿…é¡»åªæœ‰ä¸€ä¸ªå®šä¹‰ã€‚é™¤éè¯¥å‡½æ•°çš„å®šä¹‰åŒ…å« `inline` è¯´æ˜ç¬¦ï¼Œå¦åˆ™ç±»æˆå‘˜å‡½æ•°é»˜è®¤ä¸ºå¤–éƒ¨é“¾æ¥ã€‚ 

`inline` å’Œ `__inline` è¯´æ˜ç¬¦å»ºè®®ç¼–è¯‘å™¨å°†å‡½æ•°ä½“çš„å‰¯æœ¬æ’å…¥åˆ°è°ƒç”¨å‡½æ•°çš„æ¯ä¸ªä½ç½®ã€‚æœ‰ç¼–è¯‘å™¨æ ¹æ®è‡ªå·±çš„æˆæœ¬æ”¶ç›Šåˆ†æå†³å®šæ˜¯å¦è¿›è¡Œå†…è”å±•å¼€ï¼›`__forceinline` å…³é”®å­—ä¼šé‡å†™æˆæœ¬æ”¶ç›Šåˆ†æï¼Œæ”¹ä¸ºä¾èµ–äºç¨‹åºå‘˜çš„åˆ¤æ–­ã€‚

ç¼–è¯‘å™¨å°†å†…è”æ‰©å±•é€‰é¡¹å’Œå…³é”®å­—è§†ä¸ºå»ºè®®ã€‚ä¸ä¿è¯ä¼šå¯¹å‡½æ•°è¿›è¡Œå†…è”ã€‚æ— æ³•å¼ºåˆ¶ç¼–è¯‘å™¨å¯¹ç‰¹å®šå‡½æ•°è¿›è¡Œå†…è”ï¼›

> *å®å‡½æ•°å’Œå†…è”å‡½æ•°*

å®ä¸ inline å‡½æ•°ä¹‹é—´æœ‰ä¸€äº›å…±åŒä¹‹å¤„ã€‚ä½†æ˜¯ï¼š
- å®å§‹ç»ˆæ˜¯å†…è”æ‰©å±•çš„ã€‚
- å®å¯èƒ½ä¼šå¯¼è‡´æ„å¤–è¡Œä¸ºï¼Œä»è€Œå¯¼è‡´å¾®å°çš„ bugï¼›
- å†…è”å‡½æ•°å—ç¼–è¯‘å™¨çš„è¯­ä¹‰å¤„ç†çº¦æŸï¼Œè€Œé¢„å¤„ç†å™¨ä¼šæ‰©å±•å®ã€‚å®ä¸æ˜¯ç±»å‹å®‰å…¨çš„ï¼Œè€Œå‡½æ•°æ˜¯ï¼›
- è®¡ç®—ä¸€æ¬¡ä½œä¸ºå†…è”å‡½æ•°çš„å‚æ•°ä¼ é€’çš„è¡¨è¾¾å¼ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œä½œä¸ºå®çš„è‡ªå˜é‡ä¼ é€’çš„è¡¨è¾¾å¼å¯è®¡ç®—å¤šæ¬¡ã€‚

```c++
#define sqr(a) ((a) * (a))
int increment(int& number) { return number++; }
inline int square(int a) { return a * a; }

int main()
{
	int c = 5;
	std::cout << sqr(increment(c)) << std::endl; // outputs 30; 5 * 6
	std::cout << c << std::endl; // outputs 7

	c = 5;
	std::cout << square(increment(c)) << std::endl; // outputs 25
	std::cout << c; // outputs 6
}
```

>---
#### å‡½æ•°ç±»å‹ä¸å‡½æ•°æŒ‡é’ˆ

C++ é€šè¿‡ä¸ C è¯­è¨€ç›¸åŒçš„æ–¹å¼æ”¯æŒå‡½æ•°æŒ‡é’ˆã€‚ä½†æ˜¯æ›´åŠ ç±»å‹å®‰å…¨çš„æ›¿ä»£æ–¹æ³•é€šå¸¸æ˜¯ä½¿ç”¨å‡½æ•°å¯¹è±¡ã€‚ä½¿ç”¨ `typedef` å£°æ˜å‡½æ•°æŒ‡é’ˆç±»å‹çš„åˆ«åï¼š

```c++
int (*myFunction(char* s))(int);  // è¿”å› int(*)(int) å‡½æ•°æŒ‡é’ˆçš„å‡½æ•°

typedef int (*fp)(int);  
fp myFunction(char* s); // ç­‰æ•ˆå£°æ˜
```

`typedef` å¯ä»¥å£°æ˜ä¸€ä¸ªå‡½æ•°ç±»å‹ï¼›å‡½æ•°å‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ç±»å‹æ—¶ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°ç±»å‹æŒ‡é’ˆï¼Œå¯ä»¥å°†å‡½æ•°æŒ‡é’ˆå¯¹è±¡ä½œä¸ºå‚æ•°ä¼ é€’ã€‚

```c++
typedef int (*fptr)(int);
typedef int (ftype)(int);  // ç­¾åä¸º `int (int)` çš„å‡½æ•°ç±»å‹ ftype

// è¢«è§†ä¸º  myFunction(ftype*, int); 
// å› æ­¤æ— æ³•ä¸ myFunction(fptr, int) é‡è½½ï¼Œå®ƒä»¬æ˜¯ç­‰ä»·çš„ã€‚
// ä½†æ˜¯å‡½æ•°æ— æ³•è¿”å› ftype, å¯ä»¥è¿”å› fptr
int myFunction(ftype s, int v) {   
    return s(v);
}
int foo(int i) { return i; }
int main()
{
    fptr fp = foo; // or &foo
    ftype* ft = foo;
    myFunction(fp, 1);   // ok; fp  to (ftype s)
    myFunction(ft, 1);   // ok; ft  to (ftype s)
    myFunction(*ft, 1);  // ok; *fp to (ftype s)
    myFunction(*ft, 1);  // ok; *ft to (ftype s)
    myFunction(foo, 1);  // ok; foo to (ftype s)
}
```

---
### è¿ç®—ç¬¦é‡è½½

å¯ä»¥åœ¨å…¨å±€æˆ–ä¸ºå„ä¸ªç±»é‡æ–°å®šä¹‰å¤§å¤šæ•°å†…ç½®è¿ç®—ç¬¦çš„å‡½æ•°ã€‚é‡è½½è¿ç®—ç¬¦ä½œä¸ºå‡½æ•°æ¥å®ç°ã€‚å¯é‡è½½çš„è¿ç®—ç¬¦æœ‰ï¼š

```c++
a() /* å‡½æ•°è°ƒç”¨ */
a[] /* æ•°ç»„ä¸‹æ ‡ */
delete /* å†…å­˜é‡Šæ”¾ */
new    /* åˆ†é…å†…å­˜ */ 
explicit  // æ˜¾å¼ç”¨æˆ·å®šä¹‰è½¬æ¢
 :    // éšå¼è½¬æ¢

// ä¸€å…ƒ
!a,  &a, a() /* è½¬æ¢è¿ç®—ç¬¦ */
+a, -a, ++a, a++, --a, a--,
~a,

// äºŒå…ƒ
a -> b, a ->*b, (a, b), 
a + b,  a - b,  a * b,  a / b,  a % b, 
a += b, a -= b, a *= b, a /= b, a %= b, 
a < b,  a > b,  a <= b, a >= b,
a != b, a == b,
a && b, a || b, 
a & b,  a | b,  a ^ b,
a &= b, a |= b, a ^= b,
a << b, a >> b, a <<= b, a >>= b
```

`.`, `.*`, `::`, `? :`, `#`, `##` ä¸å¯é‡å®šä¹‰ã€‚

é‡è½½è¿ç®—ç¬¦å¿…é¡»æ˜¯éé™æ€ç±»æˆå‘˜å‡½æ•°æˆ–å…¨å±€å‡½æ•°ã€‚ éœ€è¦è®¿é—®ç§æœ‰æˆ–å—ä¿æŠ¤çš„ç±»æˆå‘˜çš„å…¨å±€å‡½æ•°å¿…é¡»å£°æ˜ä¸ºè¯¥ç±»çš„å‹å…ƒ `friend`ã€‚å…¨å±€å‡½æ•°å¿…é¡»è‡³å°‘é‡‡ç”¨ä¸€ä¸ªç±»ç±»å‹æˆ–æšä¸¾ç±»å‹çš„è‡ªå˜é‡æˆ–å…¶å¼•ç”¨ã€‚

å£°æ˜ä¸ºæˆå‘˜å‡½æ•°çš„ä¸€å…ƒè¿ç®—ç¬¦æ²¡æœ‰è‡ªå˜é‡ï¼ˆä½¿ç”¨éšå¼ `this`ï¼‰ï¼›å£°æ˜ä¸ºå…¨å±€å‡½æ•°ä½¿ç”¨ä¸€ä¸ªè‡ªå˜é‡ï¼›å£°æ˜ä¸ºæˆå‘˜å‡½æ•°çš„äºŒå…ƒè¿ç®—ç¬¦æœ‰ä¸€ä¸ªè‡ªå˜é‡ï¼›å£°æ˜ä¸ºå…¨å±€å‡½æ•°æœ‰ä¸¤ä¸ªè‡ªå˜é‡ã€‚é™¤èµ‹å€¼ (`operator=`) ä¹‹å¤–çš„æ‰€æœ‰é‡è½½è¿ç®—ç¬¦éƒ½å¯ç”±æ´¾ç”Ÿç±»ç»§æ‰¿ã€‚`[]` ä¸‹æ ‡çš„ç±»å‹å¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œå¯ä»¥å®ç°è‡ªå®šä¹‰ç´¢å¼•ã€‚

é»˜è®¤ â€œ`operator=`â€ å‡½æ•°å¯ç”±ç±»ç±»å‹çš„ç¼–è¯‘å™¨ç”Ÿæˆï¼›å®šä¹‰å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦çš„ç±»è¿˜åº”æ˜¾å¼å®šä¹‰å¤åˆ¶æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ï¼Œä»¥åŠç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ã€‚


```c++
// ä¸€å…ƒ
<return-type> operator op ();  // æˆå‘˜å‡½æ•°
<return-type> operator op ( <class-type> );  //éæˆå‘˜å‡½æ•°

// äºŒå…ƒ
<return-type> operator op( arg );  // æˆå‘˜å‡½æ•°
<return-type> operator op( <class-type>, arg );  // éæˆå‘˜å‡½æ•°
<return-type> operator op( arg, <class-type> );  // or

// é€’å¢é€’å‡
<class-type>& operator++();       // ++i; æˆå‘˜å‡½æ•°
<class-type> operator++(int);     // i++
<class-type>& operator--();       // --i
<class-type> operator--(int);     // i--

friend Point& operator++( Point& );      // ++i; ç±»ä¸­å®šä¹‰å‹å…ƒ; å…¨å±€èŒƒå›´
friend Point operator++( Point&, int );  // i++
friend Point& operator--( Point& );      // --i
friend Point operator--( Point&, int );  // i--
```

>---
#### ä¸€å…ƒé‡è½½ä¸¾ä¾‹

```c++
struct S {
	bool operator ==(S& s) { return s == *this; };    // å®šä¹‰ç›¸ç­‰è¯­æ³•
	bool operator !() { return this == nullptr; };    // æ”¹å˜è¯­ä¹‰ä¸ºæ£€æŸ¥ this æ˜¯å¦ä¸º nullptr
	S& operator &() { return *this; };				  // æ”¹å˜è¯­ä¹‰è¿”å› this çš„å¼•ç”¨
	bool operator ()(S& s) { return s == *this; };    // æ”¹å˜è¯­ä¹‰ä¸ºæ¯”è¾ƒå€¼æ˜¯å¦ç›¸ç­‰
	S* operator ()() { return this; };				  // æ”¹å˜è¯­ä¹‰è¿”å› this æœ¬èº«
	void* operator new (size_t size) {				  // æ”¹å˜è¯­ä¹‰å£°æ˜ä¸€ä¸ª nullptr åˆå§‹åŒ–çš„ç©ºæŒ‡é’ˆ
		return nullptr;
	}
};
int main()
{
	S s = S();
	S& rs = &s;
	S* ps = new S;
	while (!ps) {
		cout << "rs is nullptr " << endl;
		ps = rs();  // åˆå§‹åŒ–
	}
}
```

---
### ç±»å’Œç»“æ„

ç±»å’Œç»“æ„åœ¨ C++ ä¸­æ˜¯ç›¸åŒçš„ï¼Œåœ¨ç»“æ„ä¸­ï¼Œé»˜è®¤å¯è®¿é—®æ€§æ˜¯ `public`ï¼Œè€Œåœ¨ç±»ä¸­æ˜¯ `private`ã€‚`union` æ˜¯ C++ ç±»ç±»å‹çš„ä¸€ç§ï¼Œæˆå‘˜é»˜è®¤æ˜¯ `public`ï¼Œä½†æ²¡æœ‰ç»§æ‰¿è¯­ä¹‰ã€‚

>---
#### ç±»æˆå‘˜

`class` æˆ– `struct` ç”±å…¶æˆå‘˜ç»„æˆã€‚ç±»çš„å·¥ä½œç”±å…¶æˆå‘˜å‡½æ•°æ‰§è¡Œï¼Œå®ƒæ‰€ç»´æŒçš„çŠ¶æ€å­˜å‚¨åœ¨å…¶æ•°æ®æˆå‘˜ä¸­ã€‚æˆå‘˜çš„åˆå§‹åŒ–ç”±æ„é€ å‡½æ•°å®Œæˆï¼Œé‡Šæ”¾å†…å­˜å’Œé‡Šæ”¾èµ„æºç­‰æ¸…ç†å·¥ä½œç”±ææ„å‡½æ•°å®Œæˆã€‚

ç±»çš„æˆå‘˜æœ‰ï¼šç‰¹æ®Šæˆå‘˜å‡½æ•°ã€æˆå‘˜å‡½æ•°ï¼ˆé™æ€å’Œéé™æ€ï¼‰ã€å¯å˜å’Œé™æ€æ•°æ®æˆå‘˜ã€è¿ç®—ç¬¦ã€åµŒå¥—ç±»å£°æ˜ã€æšä¸¾ã€ä½åŸŸã€åˆ«åå’Œ *type-def*ï¼›å‹å…ƒåŒ…å«åœ¨ç±»å£°æ˜ä¸­ï¼Œä½†å±äºå…¶å‘¨å›´èŒƒå›´ã€‚

å¯å°†æ•°æ®æˆå‘˜å£°æ˜ä¸ºé™æ€ï¼Œè¿™è¡¨ç¤ºç±»çš„æ‰€æœ‰å¯¹è±¡éƒ½æœ‰æƒè®¿é—®å®ƒçš„åŒä¸€å‰¯æœ¬ã€‚å¯å°†æˆå‘˜å‡½æ•°å£°æ˜ä¸ºé™æ€ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹å®ƒåªèƒ½è®¿é—®ç±»çš„é™æ€æ•°æ®æˆå‘˜ï¼ˆä¸”ä¸å…·æœ‰ `this` æŒ‡é’ˆï¼‰ã€‚é™æ€æ•°æ®æˆå‘˜ä¸€èˆ¬éœ€è¦åœ¨å£°æ˜æ—¶ä¸ºåˆå§‹å€¼è®¾å®šé¡¹ã€‚ç±»çš„å¯¹è±¡ã€æŒ‡é’ˆã€å¼•ç”¨å¯ä»¥ä½¿ç”¨æˆå‘˜é€‰æ‹©ï¼ˆ`.` å’Œ `->`ï¼‰è¿ç®—ç¬¦è®¿é—®é™æ€æˆå‘˜ã€‚

å¦‚æœæœªåœ¨ç±»å®šä¹‰ä¸­æŒ‡å®šç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨è‡ªåŠ¨æä¾›çš„å‡½æ•°åˆ™ä¸ºç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼šé»˜è®¤æ„é€ å‡½æ•°ã€å¤åˆ¶æ„é€ å‡½æ•°ã€ç§»åŠ¨æ„é€ å‡½æ•°ã€å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ã€ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ã€ææ„å‡½æ•°ã€‚

```c++

class TestRun
{
    // Start member list.
    // The class interface accessible to all callers.
public:
    TestRun() = default; // Use compiler-generated default constructor
    TestRun(const TestRun&) = delete; // Don't generate a copy constructor
    TestRun(std::string name);
    void DoSomething();
    int Calculate(int a, double d);
    virtual ~TestRun();  // virtual destructor
    enum class State { Active, Suspended };  // enum class;

    // Accessible to this class and derived classes only.
protected:
    virtual void Initialize();
    virtual void Suspend();
    State GetState();

    // Accessible to this class only.
private:
    State _state{ State::Suspended };  // Default brace-initialization of instance members
    std::string _testName{ "" };
    int _index{ 0 };

    // Non-const static member:
    static int _instances;
};

// Define and initialize static member.
int TestRun::_instances{ 0 };
```

éé™æ€æ•°æ®æˆå‘˜å£°æ˜ç¬¦å¯ä»¥åŒ…å«åˆå§‹å€¼è®¾å®šé¡¹ï¼›é™æ€æ•°æ®æˆå‘˜å¿…é¡»æ˜¯å¸¸é‡ (`constexpr`) æ‰èƒ½åŒ…å«åˆå§‹å€¼è®¾å®šé¡¹ï¼Œå¦åˆ™å¿…é¡»åœ¨æ–‡ä»¶èŒƒå›´å†…å®šä¹‰é™æ€æ•°æ®æˆå‘˜å¹¶åœ¨æ­¤èŒƒå›´å†…å°†å…¶åˆå§‹åŒ–ï¼›é™æ€æˆå‘˜å…·æœ‰å¤–éƒ¨é“¾æ¥ä½†å¯ä»¥æ·»åŠ å¯è®¿é—®æ€§ã€‚æˆå‘˜å‡½æ•°å¯ä»¥åœ¨ç±»ä¸»ä½“ä¸­å£°æ˜å®šä¹‰æˆ–åœ¨å¤–éƒ¨å®šä¹‰ï¼Œå†…éƒ¨å®šä¹‰ä½†ä¼šéšå¼å£°æ˜ä¸º `inline`ã€‚

```c++
class Stat {};
class S {
public :
	S() = default;
	static const S& Instance();
	static Stat GetStat(S&);
private:
	static S* s_instance;
	Stat s_stat{};
};
Stat S::GetStat(S& s) { return s.s_stat; };
const S& S::Instance() { return *s_instance; };
S* S::s_instance = new S{};
```

>---
#### æˆå‘˜è®¿é—®æ§åˆ¶

é€šè¿‡è®¿é—®æ§åˆ¶ï¼Œå¯ä»¥å°†ç±»çš„ `public` æ¥å£ä¸ `private` å†…éƒ¨å®ç°å’Œä»…ä¾›æ´¾ç”Ÿç±»ä½¿ç”¨çš„ `protected` æˆå‘˜åˆ†ç¦»å¼€æ¥ã€‚`class` æˆå‘˜é»˜è®¤ä¸º `private`ï¼›`struct` ä¸º `public`ï¼›`union` ä¸º `public` ä½†æ²¡æœ‰ `protected`ã€‚ 

```c++
class Point
{
public:
    Point( int, int ) // Declare public constructor.;
    Point();// Declare public default constructor.
    int &x( int ); // Declare public accessor.
    int &y( int ); // Declare public accessor.

private:                 // Declare private state variables.
    int _x;
    int _y;

protected:      // Declare protected function for derived classes only.
    Point ToWindowCoords();
};
```

åŸºç±»æˆå‘˜åœ¨æ´¾ç”Ÿç±»ä¸­çš„å¯è®¿é—®æ€§å—åŸºç±»æˆå‘˜è‡ªèº«çš„è®¿é—®è¯´æ˜ç¬¦ï¼Œå’Œæ´¾ç”Ÿå£°æ˜åŸºç±»æ—¶ä½¿ç”¨çš„è®¿é—®è¯´æ˜ç¬¦çš„äº¤é›†å†³å®šï¼š
- `private` æ´¾ç”Ÿï¼ŒåŸºç±»çš„æ‰€æœ‰æˆå‘˜éƒ½æ— æ³•è®¿é—®ï¼›
- `protected` æ´¾ç”Ÿï¼ŒåŸºç±»çš„ `protected` å’Œ `public` æˆå‘˜åœ¨æ´¾ç”Ÿç±»ä¸­æ˜¯ `protected`ï¼›
- `public` æ´¾ç”Ÿï¼ŒåŸºç±»çš„ `protected` æˆå‘˜åœ¨æ´¾ç”Ÿç±»ä¸­ä¸º `protected`ï¼ŒåŸºç±»çš„ `public` æˆå‘˜åœ¨æ´¾ç”Ÿç±»ä¸­ä¸º `public`ã€‚
æ´¾ç”Ÿç±»ä¸ä½¿ç”¨è®¿é—®è¯´æ˜ç¬¦æ—¶ï¼Œ`class` æ´¾ç”Ÿç±»å‹ä½¿ç”¨çš„åŸºç±»æ˜¯ `private`ï¼Œ`struct` æ´¾ç”Ÿç±»ä½¿ç”¨çš„åŸºç±»æ˜¯ `public`ï¼š

```c++
class Base{};
struct SDerived: Base {}  // ç›¸å½“äº struct SDerived: public Base 
class CDerived: Base {}   // ç›¸å½“äº class CDerived: private Base 
```

å‹å…ƒç±»æˆå‘˜çš„è®¿é—®ä¸å—è®¿é—®è¯´æ˜ç¬¦çš„é™åˆ¶ï¼Œå®ƒå±äºå£°æ˜ç±»çš„èŒƒå›´çš„æˆå‘˜ã€‚

åœ¨å°†åŸºç±»æŒ‡å®šä¸º `private` æ—¶ï¼Œå®ƒåªå½±å“éé™æ€æˆå‘˜ã€‚åœ¨æ´¾ç”Ÿç±»ä¸­ï¼Œå…¬å…±é™æ€æˆå‘˜ä»æ˜¯å¯è®¿é—®çš„ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½¿ç”¨æŒ‡é’ˆã€å¼•ç”¨æˆ–å¯¹è±¡è®¿é—®åŸºç±»çš„é™æ€æˆå‘˜ä»éœ€è¦è®¿é—®æ§åˆ¶è½¬æ¢ï¼Œ`private` åŸºç±»æ— æ³•é€šè¿‡æ´¾ç”Ÿçš„å¯¹è±¡ç›´æ¥è®¿é—®ï¼Œåªèƒ½é€šè¿‡é™å®šæ–¹å¼ `base::static_member`ã€‚

> *å¯¹è™šå‡½æ•°çš„è®¿é—®*

å¯¹ `virtual` å‡½æ•°çš„è®¿é—®æ§åˆ¶æ˜¯ç”±ç”¨äºè¿›è¡Œå‡½æ•°è°ƒç”¨çš„ç±»å‹å†³å®šçš„ã€‚é‡å†™å‡½æ•°çš„å£°æ˜ä¸ä¼šå½±å“ç»™å®šç±»å‹çš„è®¿é—®æ§åˆ¶ã€‚

```c++
// access_to_virtual_functions.cpp
class VFuncBase
{
public:
    virtual int GetState() { return _state; }
protected:
    int _state;
};
class VFuncDerived : public VFuncBase
{
private:
    int GetState() { return _state; }
};

int main()
{
   VFuncDerived vfd;             // Object of derived type.
   VFuncBase *pvfb = &vfd;       // Pointer to base type.
   VFuncDerived *pvfd = &vfd;    // Pointer to derived type.
   int State;

   State = pvfb->GetState();     // GetState is public.
   State = pvfd->GetState();     // C2248 error expected; GetState is private;
}
```

å¯ä»¥ä½¿ç”¨æŒ‡å‘åŸºç±» `GetState` çš„æŒ‡é’ˆè°ƒç”¨è™šå‡½æ•° `VFuncBase`ã€‚ è¿™å¹¶ä¸æ„å‘³ç€è°ƒç”¨çš„å‡½æ•°æ˜¯è¯¥å‡½æ•°çš„åŸºç±»ç‰ˆæœ¬ï¼Œå®ƒå¯èƒ½åœ¨æ´¾ç”Ÿç±»ä¸­è¿›è¡Œçš„é‡å†™ `override`ï¼Œæˆ–å¤šé‡ç»§æ‰¿ä¸­çš„æŸä¸ªä¸­é—´æ´¾ç”Ÿç±»çš„é‡å†™æ–¹æ³•ã€‚

>---
#### ç±»åˆå§‹åŒ–

æ²¡æœ‰æ„é€ ç±»å‹çš„ç±»ç±»å‹çš„å¯¹è±¡å¯ä»¥ç›´æ¥å£°æ˜æˆ–ä½¿ç”¨åˆå§‹åŒ–å™¨ï¼ˆæˆ–ç©ºå¤§æ‹¬å·ï¼‰ï¼ŒæŒ‰ç±»ä¸­å£°æ˜çš„æˆå‘˜çš„é¡ºåºæä¾›åˆ—è¡¨å…ƒç´ ã€‚

```c++
struct TempData
{
	int StationId;
	time_t timeSet;
	double current;
};

int main()
{
	TempData t0;   // æœªåˆå§‹åŒ–çš„å¯¹è±¡
    // è°ƒç”¨è‡ªåŠ¨ç”Ÿæˆçš„é»˜è®¤æ„é€ ï¼Œæ•°æ®æˆå‘˜é›¶åˆå§‹åŒ–
	TempData t1{};

    // timeSet åé¢çš„å…ƒç´ é›¶åˆå§‹åŒ–
	TempData t2{ 1, 1000 };  
	TempData t3(1, 100);     
    
    // å…¨éƒ¨åˆ—å‡º
    TempData t4{ 1, 100, 0 };  
	TempData t5(1, 100, 0);

	TempData t();  // å«ä¹‰ä¸æ˜ç¡®ï¼Œå£°æ˜è¿”å› TempData çš„å‡½æ•° t4
}
```

å…·æœ‰éé»˜è®¤æ„é€ å‡½æ•°ï¼Œåˆ™ç±»æˆå‘˜æ˜¾ç¤ºé¡ºåºæ˜¯å¯¹åº”å‚æ•°åœ¨æ„é€ å‡½æ•°ä¸­çš„æ˜¾ç¤ºé¡ºåºã€‚

```c++
struct TempData
{
	int StationId;
	time_t timeSet;
	double current;
public:
	TempData() = default;
	TempData(int stationid, time_t tmset) :StationId{ stationid }, timeSet{ tmset } {
		current = 0;
	}
};

int main()
{
	// è°ƒç”¨é»˜è®¤æ„é€ 
	TempData t0;    
	TempData t1{};  

	// è°ƒç”¨ TempData(int, time_t)
	TempData t2{ 1, 1000 };  
	TempData t3(1, 100);    

	TempData t();  // å«ä¹‰ä¸æ˜ç¡®ï¼Œå£°æ˜è¿”å› TempData çš„å‡½æ•° t4
}
```

`initializer_list` ç±»è¡¨ç¤ºå¯ä»¥åœ¨æ„é€ å‡½æ•°å’Œå…¶ä»–ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨çš„æŒ‡å®šç±»å‹çš„å¯¹è±¡çš„åˆ—è¡¨ã€‚ 

```C++
#include<initializer_list>

initializer_list<int> ilist1{ 5, 6, 7 };
```

æ ‡å‡†åº“å®¹å™¨ç±»ä»¥åŠ `string`ã€`wstring` å’Œ `regex` å…·æœ‰ `initializer_list` æ„é€ å‡½æ•°

```c++
vector<int> v1{ 9, 10, 11 };
map<int, string> m1{ {1, "a"}, {2, "b"} };
string s{ 'a', 'b', 'c' };
regex rgx{ 'x', 'y', 'z' };
```

>---
#### å¯¹è±¡ç”Ÿå­˜æœŸå’Œèµ„æºç®¡ç†

C++ æ²¡æœ‰è‡ªåŠ¨å›æ”¶åƒåœ¾ï¼Œ ç¨‹åºè´Ÿè´£å°†æ‰€æœ‰å·²è·å–çš„èµ„æºè¿”å›åˆ°æ“ä½œç³»ç»Ÿã€‚æœªè¢«é‡Šæ”¾æœªä½¿ç”¨çš„èµ„æºæ˜¯èµ„æºæ³„éœ²ï¼ˆ*leak*ï¼‰ã€‚ç°ä»£ C++ é€šè¿‡å£°æ˜å †æ ˆä¸Šçš„å¯¹è±¡ï¼Œå°½å¯èƒ½é¿å…ä½¿ç”¨å †å†…å­˜ã€‚

å½“å¯¹è±¡åˆå§‹åŒ–æ—¶ï¼Œå®ƒä¼šè·å–å®ƒæ‹¥æœ‰çš„èµ„æºï¼Œå¹¶ä¸”è¯¥å¯¹è±¡è´Ÿè´£åœ¨å…¶ææ„å‡½æ•°ä¸­é‡Šæ”¾èµ„æºã€‚åœ¨å †æ ˆä¸Šå£°æ˜æ‹¥æœ‰èµ„æºçš„å¯¹è±¡æœ¬èº«ã€‚å¯¹è±¡æ‹¥æœ‰èµ„æºçš„åŸåˆ™ä¹Ÿç§°ä¸º â€œèµ„æºè·å–å³åˆå§‹åŒ–â€ (RAII)ã€‚å½“æ‹¥æœ‰èµ„æºçš„å †æ ˆå¯¹è±¡è¶…å‡ºèŒƒå›´æ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨å…¶ææ„å‡½æ•°ã€‚C++ ä¸­çš„åƒåœ¾å›æ”¶ä¸å¯¹è±¡ç”Ÿå­˜æœŸå¯†åˆ‡ç›¸å…³ï¼Œæ˜¯ç¡®å®šæ€§çš„ã€‚èµ„æºå§‹ç»ˆåœ¨ç¨‹åºä¸­çš„å·²çŸ¥ç‚¹é‡Šæ”¾ã€‚

```c++
struct buffer {
	friend void print(buffer&);
private:
	char* buf;
	size_t size;
public:
	buffer(size_t size);
	int writeString(string str);
	~buffer();
};
buffer::buffer(size_t size) :size{ size } {
	buf = new char[size];
}
buffer::~buffer() {
	cout << "delete buffer" << endl;
	delete[] buf;
}
int buffer::writeString(string str) {
	int n = 0;
	try {
		for (char c : str) {
			if (n >= size - 1)
				break;
			buf[n++] = c;
		}
	}
	catch (exception e) {
		return -1;
	}
	buf[n] = '\0';
	return n;
}
void print(buffer& buf) {
	printf("%s\n", buf.buf);
}

void WriteToBuffer(std::string& str) {
	buffer b(512);
	int	n = b.writeString(str);
	if (n > 0)
		print(b);
}

int main()
{
	string s{ "Hello World" };
	WriteToBuffer(s);
}
// Hello World
// delete buffer
```

C++ çš„è®¾è®¡å¯ç¡®ä¿å¯¹è±¡åœ¨è¶…å‡ºèŒƒå›´æ—¶è¢«é”€æ¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬åœ¨å—è¢«é€€å‡ºæ—¶ä»¥ä¸æ„é€ ç›¸åçš„é¡ºåºè¢«æ‘§æ¯ã€‚é”€æ¯å¯¹è±¡æ—¶ï¼Œå°†æŒ‰ç‰¹å®šé¡ºåºé”€æ¯å…¶åŸºé¡¹å’Œæˆå‘˜ã€‚ åœ¨å…¨å±€èŒƒå›´å†…åœ¨ä»»ä½•å—ä¹‹å¤–å£°æ˜çš„å¯¹è±¡å¯èƒ½ä¼šå¯¼è‡´é—®é¢˜ã€‚

å¯ä»¥ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆå¤„ç†å¯¹è±¡æ‰€éœ€å†…å­˜èµ„æºçš„åˆ†é…å’Œåˆ é™¤ã€‚ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆå°†ä¸éœ€è¦åœ¨ç±»ä¸­æ˜¾å¼å®šä¹‰ææ„å‡½æ•°ã€‚ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆè¿›è¡Œå†…å­˜åˆ†é…ï¼Œå¯ä»¥æ¶ˆé™¤å†…å­˜æ³„æ¼çš„å¯èƒ½æ€§ã€‚æ­¤æ¨¡å‹é€‚ç”¨äºå…¶ä»–èµ„æºï¼Œä¾‹å¦‚æ–‡ä»¶å¥æŸ„æˆ–å¥—æ¥å­—ã€‚


```c++
#include <memory>
class widget
{
private:
    std::unique_ptr<int[]> data;
public:
    widget(const int size) { data = std::make_unique<int[]>(size); }
    void do_something() {}
};

void usingWidget() {
    widget w(1000000);  // lifetime automatically tied to enclosing scope
                        // constructs w, including the w.data gadget member
    w.do_something();
} // automatic destruction and deallocation for w and w.data
```

>---
#### å‹å…ƒ

ç±»å‘ä¸å±äºç±»æˆå‘˜çš„å‡½æ•°æˆ–å•ç‹¬ç±»ä¸­çš„æ‰€æœ‰æˆå‘˜æˆäºˆæˆå‘˜çº§è®¿é—®æƒé™éå¸¸æœ‰ç”¨ã€‚è¿™äº› *Free* å‡½æ•°å’Œç±»ç§°ä¸º â€œå‹å…ƒâ€ï¼Œç”± `friend` æ ‡è®°ã€‚

å¦‚æœå£°æ˜ä»¥å‰æœªå£°æ˜çš„ `friend` å‡½æ•°ï¼Œåˆ™è¯¥å‡½æ•°å°†è¢«å¯¼å‡ºåˆ°å°é—­éç±»èŒƒå›´ã€‚`friend` å‡½æ•°è¢«è§†ä¸º `extern` å£°æ˜ã€‚

å°½ç®¡å…·æœ‰å…¨å±€èŒƒå›´çš„å‡½æ•°å¯ä»¥åœ¨å…¶åŸå‹ä¹‹å‰å£°æ˜ä¸º `friend` å‡½æ•°ï¼Œä½†æ˜¯æˆå‘˜å‡½æ•°åœ¨å®ƒä»¬çš„å®Œæ•´ç±»å£°æ˜å‡ºç°å‰ä¸èƒ½å£°æ˜ä¸º `friend` å‡½æ•°ã€‚

```c++
class ForwardDeclared;   // Class name is known.
class HasFriends
{
    friend int ForwardDeclared::IsAFriend();   // C2039 error expected
};
```

åœ¨ç±»ä¸­å£°æ˜çš„å‹å…ƒç±»å¯ä»¥æ˜¯ `friend class F` æˆ– `friend F`ï¼›åŒºåˆ«æ˜¯ `class F` å¼•å…¥æ–°çš„ç±»ä½†æ²¡æœ‰å®šä¹‰ï¼Œç¨åå®šä¹‰ï¼›è€Œ `friend F` æ˜¯å¼•ç”¨å¤–éƒ¨èŒƒå›´çš„å·²å£°æ˜ç±»ï¼š

```c++
class F{};
class S {
    friend F;
    friend class NF;
};
// ç¨åå®šä¹‰
class NF{ };
```

ä½¿ç”¨ `friend F` å°†æ¨¡æ¿å‚æ•°æˆ– `typedef` å£°æ˜ä¸ºå‹å…ƒï¼š

```c++
typedef Foo F;
template <typename T>
class my_class
{
    friend T;
    friend F;
    //...
};
```

`friend` å‡½æ•°æ˜¯ä¸€ä¸ªä¸ä¸ºç±»æˆå‘˜çš„å‡½æ•°ï¼›å®ƒå¯ä»¥æ˜¯æ–°å£°æ˜çš„å±äºå¤–éƒ¨èŒƒå›´çš„ *Free* å‡½æ•°ï¼Œæˆ–å¤–éƒ¨èŒƒå›´å·²å£°æ˜çš„å‡½æ•°åŸå‹ï¼ˆæœªå®šä¹‰ï¼Œåœ¨å½“å‰ç±»å£°æ˜ä¹‹åå®šä¹‰ï¼‰ã€‚

```c++
class Point
{
    friend void ChangePrivate( Point & );  // å£°æ˜åŸå‹
public:
    Point( void ) : m_i(0) {}
    void PrintPrivate( void ){cout << m_i << endl; }

private:
    int m_i;
};
void ChangePrivate ( Point &i ) { i.m_i++; }  // å£°æ˜å®šä¹‰
```

ç±»æˆå‘˜å‡½æ•°å¯ä»¥å£°æ˜ä¸ºå…¶ä»–ç±»ä¸­çš„å‹å…ƒã€‚å‹å…ƒå…³ç³»ä¸æ˜¯ç›¸äº’çš„ï¼Œä¾‹å¦‚ `A` å’Œ `B` äº’ä¸ºå‹å…ƒï¼Œä½†æ˜¯ç¼–è¯‘å™¨å¿…é¡»å°†æ•´ä¸ªç¬¬äºŒä¸ªç±»æŒ‡å®šä¸ºç¬¬ä¸€ä¸ªç±»çš„å‹å…ƒï¼›ä½†æ˜¯å¯ä»¥é€‰æ‹©å°†ç¬¬ä¸€ä¸ªç±»ä¸­çš„å“ªäº›å‡½æ•°ä½œä¸ºç¬¬äºŒä¸ªç±»çš„å‹å…ƒã€‚åä¹‹ä¸å¯ã€‚å‹å…ƒå…³ç³»ä¸èƒ½ç»§æ‰¿ï¼Œä¸å¯ä¼ é€’ã€‚

```c++
class A {
	friend class B;
public:
	void fooA(B& b);
};
class B {
	friend A;
	friend void A::fooA(B& b);
private:
	int _v;
};
void A::fooA(B& b) {
	b._v = 110;
}
```

å¯ä»¥åœ¨ç±»å£°æ˜ä¸­å®šä¹‰å‹å…ƒå‡½æ•°ï¼ˆç»™å®šå‡½æ•°ä¸»ä½“ï¼‰ã€‚è¿™äº›å‡½æ•°æ˜¯å†…è”å‡½æ•°ï¼Œç±»ä¼¼äºæˆå‘˜å†…è”å‡½æ•°ã€‚ç±»å£°æ˜ä¸­å®šä¹‰çš„å‹å…ƒå‡½æ•°åœ¨å°é—­ç±»çš„èŒƒå›´å†…ã€‚

```c++
class S {
private:
	int _v;
	friend S&& initS(S&& s) {
		s._v = 110;
	}
};
int main()
{
	S s = initS(S{});  // inline S&& initS
}
```

>---
#### æ„é€ å‡½æ•°

åˆ›å»ºç±»æ—¶åˆå§‹åŒ–å…¶æˆå‘˜æˆ–è°ƒç”¨æˆå‘˜å‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨æ„é€ å‡½æ•°ï¼›å¯ä»¥å£°æ˜ `inline`ã€`explicit`ã€`friend` æˆ– `constexpr`ã€‚æ„é€ å‡½æ•°å¯ä»¥åˆå§‹åŒ–ä¸€ä¸ª `const`ã€`volatile` æˆ– `const volatile` çš„å¯¹è±¡ã€‚

æ„é€ å‡½æ•°å¯ä»¥é€‰æ‹©å…·æœ‰æˆå‘˜åˆå§‹åŒ–è¡¨è¾¾å¼åˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨ä¼šåœ¨æ„é€ å‡½æ•°ä¸»ä½“è¿è¡Œä¹‹å‰åˆå§‹åŒ–ç±»æˆå‘˜ã€‚`const` æˆå‘˜å’Œå¼•ç”¨ç±»å‹çš„æˆå‘˜å¿…é¡»åœ¨æˆå‘˜åˆå§‹åŒ–è¡¨è¾¾å¼åˆ—è¡¨ä¸­è¿›è¡Œåˆå§‹åŒ–ã€‚

```c++
struct Point {
	constexpr Point() :x{}, y{} {};  // å¸¦æœ‰æˆå‘˜åˆå§‹åŒ–è¡¨è¾¾å¼çš„é»˜è®¤æ„é€ å‡½æ•°
	explicit Point(int x, int y) :x(x), y(y) {}; // é‡è½½ 
	int x, y;
};

class Axis {
	Axis() = delete;   // åˆ é™¤é»˜è®¤æ„é€ å‡½æ•°
public:
	Axis(Point p) {}
};

int main() {
	Point p1; // æœªåˆå§‹åŒ–å¯¹è±¡
	const Point origin{};
	Point p2{ 1,1 };

	// æ— æ³•åˆ›å»º
	Axis a{};
	Axis as[6];
	// å¯ä»¥æ˜¯
	Axis a0{ Point{1,1} };
	Axis as0[3]{ Point{0,0}, Point{1,1}, Point{-1,-1} };
}
```

> *å§”æ‰˜æ„é€ å‡½æ•°*

è®¸å¤šç±»å…·æœ‰æ‰§è¡Œç±»ä¼¼æ“ä½œï¼ˆä¾‹å¦‚ï¼ŒéªŒè¯å‚æ•°ï¼‰çš„å¤šä¸ªæ„é€ å‡½æ•°ï¼›å¯ä»¥ä½¿ç”¨å§”æ‰˜æ„é€ å‡½æ•°å‡å°‘ä»£ç é‡å¤æ€§ï¼š

```c++
struct Point {
	Point(int x, int y, int z) :x{ x }, y{ y }, z{ z } {};
	Point(int x, int y) : Point(x, y, 0) {};
	Point() : Point(0, 0, 0) {};
	int x, y, z;
};
```

åº”é¿å…è°ƒç”¨å¾ªç¯å¯¼è‡´å †æ ˆæº¢å‡ºã€‚

> *å¤åˆ¶æ„é€ å‡½æ•°*

å¤åˆ¶æ„é€ å‡½æ•°é€šè¿‡ä»ç›¸åŒç±»å‹çš„å¯¹è±¡å¤åˆ¶æˆå‘˜å€¼æ¥åˆå§‹åŒ–å¯¹è±¡ã€‚ä¸€èˆ¬ç®€å•ç±»å‹å¯ä»¥ä½¿ç”¨è‡ªåŠ¨ç”Ÿæˆçš„å¤åˆ¶æ„é€ å‡½æ•°ï¼Œä½†æˆå‘˜å­˜åœ¨æŒ‡é’ˆæ—¶ï¼Œè‡ªåŠ¨ç”Ÿæˆå¤åˆ¶æ„é€ åªä¼šå¤åˆ¶æŒ‡é’ˆå€¼ï¼Œå› æ­¤éœ€è¦è‡ªå®šä¹‰å£°æ˜ä»¥åˆ†é…æŒ‡é’ˆå†…å­˜ï¼›å…¶ç­¾åå¯ä»¥æ˜¯ï¼š

```c++
Point(Point& other);   // Avoid if possible--allows modification of other.
Point(const Point& other);
Point(volatile Point& other);
Point(volatile const Point& other);
```

å®šä¹‰å¤åˆ¶æ„é€ å‡½æ•°è¿˜éœ€è¦å®šä¹‰ç›¸åº”çš„å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ï¼š

```c++
Point& operator=(Point& other);
Point& operator=(const Point& other);
Point& operator=(volatile Point& other);
Point& operator=(volatile const Point& other);
```

å¯ä»¥åˆ é™¤èµ‹å€¼æ„é€ ä»¥é˜»æ­¢å¯¹è±¡è¢«å¤åˆ¶ï¼š

```c++
Point (const Point&) = delete;
```

ä¸‹é¢æ˜¯ä¸€ä¸ªå¯å¤åˆ¶ *buffer*ï¼š

```c++
struct buffer {
// ...
	buffer(buffer&& other) noexcept :size(0), index{ 0 }, buf(nullptr) {
		cout << "move buffer" << endl;
		*this = std::move(other);
	};

	buffer& operator = (buffer&& other)noexcept {
		if (this != &other) {
			delete[] buf;
			size = other.size;
			index = other.index;
			buf = other.buf;
			other.buf = nullptr;
		}
		return *this;
	}
// ...
}
int main()
{
	buffer b{ 512 };
	b.Write("Hello World!");
	buffer b2 = std::move(b);
	b2.Write("JimryYchao");
	Println(b2);
}
/*
	create a new buffer
	move buffer
	Hello World!JimryYchao
	delete buffer
*/
```


---
### å¼‚å¸¸å¤„ç†

å¼‚å¸¸æ˜¯ä¸€ä¸ªå¯èƒ½è¶…å‡ºç¨‹åºçš„æ§åˆ¶èŒƒå›´çš„é”™è¯¯æ¡ä»¶ï¼Œå®ƒä¼šé˜»æ­¢ç¨‹åºç»§ç»­æ²¿å…¶å¸¸è§„æ‰§è¡Œè·¯å¾„æ‰§è¡Œã€‚ç¨‹åºé”™è¯¯é€šå¸¸åˆ†ä¸ºä¸¤ç±»ï¼š
- ç¼–ç¨‹é”™è¯¯å¯¼è‡´çš„é€»è¾‘é”™è¯¯ã€‚ä¾‹å¦‚ï¼Œâ€œç´¢å¼•è¶…å‡ºèŒƒå›´â€ é”™è¯¯ã€‚
- è¶…å‡ºç¨‹åºå‘˜æ§åˆ¶çš„è¿è¡Œæ—¶é”™è¯¯ã€‚ä¾‹å¦‚ï¼Œâ€œç½‘ç»œæœåŠ¡ä¸å¯ç”¨â€ é”™è¯¯ã€‚

åœ¨ C æ ·å¼çš„ç¼–ç¨‹å’Œ COM ä¸­ï¼Œé”™è¯¯æŠ¥å‘Šçš„ç®¡ç†æ–¹å¼æ˜¯è¿”å›ä¸€ä¸ªè¡¨ç¤ºé”™è¯¯ä»£ç æˆ–ç‰¹å®šå‡½æ•°çš„çŠ¶æ€ä»£ç çš„å€¼ï¼Œæˆ–è€…è®¾ç½®ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œè°ƒç”¨æ–¹å¯ä»¥åœ¨æ¯æ¬¡æ‰§è¡Œå‡½æ•°è°ƒç”¨åé€‰æ‹©æ€§åœ°æ£€ç´¢è¯¥å˜é‡æ¥æŸ¥çœ‹æ˜¯å¦æŠ¥å‘Šäº†é”™è¯¯ã€‚ä¾‹å¦‚ C `errno`ã€‚

```c++
template <typename T>
T Index(T arr[10], int i) {
	if (i < 0 || i >= 10)
		throw std::out_of_range("index is out of range");
	return arr[i];
}
int main() {
	int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };
	
	try {
		auto v = Index(arr, -1);
	}
	catch (out_of_range& e) {
		cout << e.what() << endl;
		return -1;
	}
}
```

åœ¨ `try` å—ä¸­ï¼Œå¦‚æœå¼•å‘æŸä¸ªå¼‚å¸¸ï¼Œç±»å‹ä¸è¯¥å¼‚å¸¸çš„ç±»å‹åŒ¹é…çš„ç¬¬ä¸€ä¸ªå…³è” `catch` å—å°†æ•è·è¯¥å¼‚å¸¸ã€‚ æ¢è¨€ä¹‹ï¼Œæ‰§è¡Œå°†ä» `throw` è¯­å¥è·³è½¬åˆ° `catch` è¯­å¥ã€‚å¦‚æœæœªæ‰¾åˆ°å¯ç”¨çš„ `catch` å—ï¼Œåˆ™è°ƒç”¨ `std::terminate` å¹¶ä¸”ç¨‹åºä¼šé€€å‡ºã€‚

åœ¨ C++ ä¸­å¯ä»¥å¼•å‘ä»»ä½•ç±»å‹ï¼›ä½†æ˜¯å»ºè®®å¼•å‘ç›´æ¥æˆ–é—´æ¥æ´¾ç”Ÿè‡ª `std::exception` çš„ç±»å‹ã€‚C++ ä¸­ä¸æä¾› *finally* çš„è¯­ä¹‰ã€‚

> *åŸºæœ¬å‡†åˆ™*

- ä½¿ç”¨æ–­è¨€æ£€æŸ¥åº”å§‹ç»ˆä¸º `true` æˆ–å§‹ç»ˆä¸º `false` çš„æ¡ä»¶ã€‚ä½¿ç”¨å¼‚å¸¸æ¥æ£€æŸ¥å¯èƒ½å‘ç”Ÿçš„é”™è¯¯ï¼Œä¾‹å¦‚å…¬å…±å‡½æ•°å‚æ•°çš„è¾“å…¥éªŒè¯é”™è¯¯ã€‚
- å½“å¤„ç†é”™è¯¯çš„ä»£ç ä¸é€šè¿‡ä¸€ä¸ªæˆ–å¤šä¸ªä¸­é—´å‡½æ•°è°ƒç”¨æ£€æµ‹é”™è¯¯çš„ä»£ç åˆ†ç¦»æ—¶ï¼Œè¯·ä½¿ç”¨å¼‚å¸¸ã€‚å½“å¤„ç†é”™è¯¯çš„ä»£ç ä¸æ£€æµ‹é”™è¯¯çš„ä»£ç ç´§å¯†è€¦åˆæ—¶ï¼Œè¯·è€ƒè™‘æ˜¯å¦åœ¨æ€§èƒ½å…³é”®å‹å¾ªç¯ä¸­ä½¿ç”¨é”™è¯¯ä»£ç ã€‚
- å¯¹äºæ¯ä¸ªå¯èƒ½å¼•å‘æˆ–ä¼ æ’­å¼‚å¸¸çš„å‡½æ•°ï¼Œè¯·æä¾›ä¸‰é¡¹å¼‚å¸¸ä¿è¯ä¹‹ä¸€ï¼šå¼ºä¿è¯ã€åŸºæœ¬ä¿è¯æˆ– nothrow (noexcept) ä¿è¯
- é€šè¿‡å€¼å¼•å‘å¼‚å¸¸ï¼Œé€šè¿‡å¼•ç”¨æ•è·å¼‚å¸¸ã€‚ ä¸è¦æ•è·æ— æ³•å¤„ç†çš„å¼‚å¸¸ã€‚
- ä¸è¦å…è®¸å¼‚å¸¸ä»ææ„å‡½æ•°æˆ–å†…å­˜è§£é™¤åˆ†é…å‡½æ•°ä¸­é€ƒé€¸ã€‚
- ä½¿ç”¨é€‚ç”¨çš„æ ‡å‡†åº“å¼‚å¸¸ç±»å‹ã€‚ä»¥åŠä» exception ç±»å±‚æ¬¡ç»“æ„æ´¾ç”Ÿè‡ªå®šä¹‰çš„å¼‚å¸¸ç±»å‹ã€‚

---
### é¢„å¤„ç†æŒ‡ä»¤

```c++
// æ¡ä»¶åŒ…å«
defined                       // æ¡ä»¶ç¼–è¯‘ç¬¦å·æµ‹è¯•
__has_include (C++17)         // æºæ–‡ä»¶åŒ…å«æµ‹è¯•
__has_cpp_attribute (C++20)   // å±æ€§æµ‹è¯•
// æ¡ä»¶æ§åˆ¶
#if
#elif
#else
#endif
#ifdef
#ifndef
#elifdef (C++23)
#elifndef (C++23)
// å®å®šä¹‰ä¸å–æ¶ˆå®å®šä¹‰
#define
#undef
// æºæ–‡ä»¶åŒ…å«
#include
import (C++20)
// æ–‡ä»¶åå’Œè¡Œä¿¡æ¯
#line
// è¯Šæ–­æŒ‡ä»¤
#error
#warning (C++23)
// å®ç°å®šä¹‰è¡Œä¸ºæ§åˆ¶
#pragma
_Pragma

export (C++20)
module (C++20)
```

>---
#### æ¡ä»¶åŒ…å«

```c++
defined ( identifier )               // æ¡ä»¶ç¼–è¯‘ç¬¦å·æµ‹è¯•
__has_include ( heeder-name )        // æºæ–‡ä»¶åŒ…å«æµ‹è¯•
__has_cpp_attribute ( pre-tokens )   // å±æ€§æµ‹è¯•
```

æ§åˆ¶æ¡ä»¶åŒ…å«çš„è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªæ•´æ•°å¸¸é‡è¡¨è¾¾å¼ï¼Œå®ƒå¯èƒ½åŒ…å«é›¶ä¸ªæˆ–å¤šä¸ª `defined()`, `__has_include()`, `__has_cpp_attribute()` ä¸€å…ƒè¿ç®—ç¬¦è¡¨è¾¾å¼ã€‚

å·²å­˜åœ¨å®šä¹‰çš„å®åç§°ï¼Œ`defined(id)` è¿”å› 1ï¼Œè¿™æ ·çš„å®åç§°ç”± `#define` å®šä¹‰ä¸”åœ¨æ¡ä»¶åŒ…å«çš„è°ƒç”¨ç‚¹ä¹‹å‰æ²¡æœ‰ `#undef` å–æ¶ˆã€‚

`__has_include( header )` æ£€ç´¢ `header` æ˜¯å¦ç”± `#include` å¯¼å…¥ï¼›åœ¨ `__has_cpp_attribute( attr-pp-token )` ä¸­ï¼Œå¦‚æœå®ç°æ”¯æŒé€šè¿‡å±•å¼€å¹¶è§£é‡Š `pp-token` æŒ‡å®šåç§°çš„å±æ€§ï¼Œåˆ™æ¯ä¸ªåŒ…å«è¡¨è¾¾ç¤ºéƒ½å°†æ›¿æ¢ä¸ºç›¸åº”çš„ `pp-token` çš„æ•´æ•°å½¢å¼ã€‚

```c++
#define assume              202207L
#define carries_dependency  200809L
#define deprecated          201309L
#define fallthrough         201603L
#define likely              201803L
#define maybe_unused        201603L
#define no_unique_address   201803L
#define nodiscard           201907L
#define noreturn            200809L
#define unlikely            201803L
```

>---
#### æ¡ä»¶æ§åˆ¶æŒ‡ä»¤

```c++
#if constant-expr
#elif constant-expr
#ifdef identifier      // #if defined identifier
#ifndef identifier     // #if !defined identifier 
#elifdef identifier    // #elif defined identifier 
#elifndef identifier   // #elif !defined identifier 
#else
#endif
```

`#ifdef`ã€`#ifndef`ã€`#elifdef` å’Œ `#elifndef` æŒ‡ä»¤ä»¥åŠ `defined` æ¡ä»¶åŒ…å«è¿ç®—ç¬¦åº”å°† `__has_include` å’Œ `__has_cpp_attribute` è§†ä¸ºå®šä¹‰å®çš„åç§°ã€‚

è¿™äº›é¢„å¤„ç†æŒ‡ä»¤æ£€æŸ¥æ§åˆ¶è¡¨è¾¾å¼çš„è®¡ç®—ç»“æœæ˜¯å¦ä¸ºéé›¶ï¼›æ ¹æ®ç»“æœæ¥é€‰æ‹©æ€§çš„è·³è¿‡ç»“æœä¸º `false`ï¼ˆé›¶ï¼‰çš„ç»„ï¼›ç»„ä¸­çš„ä»£ç å’ŒåµŒå¥—é¢„å¤„ç†æŒ‡ä»¤è¢«å¿½ç•¥ã€‚

```c++
#if __has_include(<optional>)
# include <optional>
# if __cpp_lib_optional >= 201603
# define have_optional 1
# endif
#elif __has_include(<experimental/optional>)
# include <experimental/optional>
# if __cpp_lib_experimental_optional >= 201411
# define have_optional 1
# define experimental_optional 1
# endif
#endif
#ifndef have_optional
# define have_optional 0
#endif

#if __has_cpp_attribute(acme::deprecated)
# define ATTR_DEPRECATED(msg) [[acme::deprecated(msg)]]
#else
# define ATTR_DEPRECATED(msg) [[deprecated(msg)]]
#endif
ATTR_DEPRECATED("This function is deprecated") void anvil();
```

>---
#### æºæ–‡ä»¶åŒ…å«

```c++
#include <header-name> 
#include "header-name" 
#include "source-name" 
```

`#include` æŒ‡ä»¤ä»¥å®ç°å®šä¹‰çš„æ–¹å¼æœç´¢å‘½åæºæ–‡ä»¶ï¼Œå¹¶å°†è¯¥ä½ç½®æ›¿æ¢ä¸ºæºæ–‡ä»¶çš„å…¨éƒ¨å†…å®¹ã€‚å¦‚æœ *header-name* æ ‡è¯†ä¸€ä¸ªå¯å¯¼å…¥çš„å¤´æ–‡ä»¶ï¼Œåˆ™ç”±å®ç°å®šä¹‰æ˜¯å¦å°† `#include` é¢„å¤„ç†æŒ‡ä»¤æ›¿æ¢ä¸º `import header-name;`ã€‚

```c++
#if VERSION == 1
#define INCFILE "vers1.h"
#elif VERSION == 2
#define INCFILE "vers2.h" // and so on
#else
#define INCFILE "versN.h"
#endif
#include INCFILE
```

>---
#### æ¨¡å—æŒ‡ä»¤

```c++

```

æ¨¡å—æŒ‡ä»¤ä¸­æ¨¡å—é¢„å¤„ç†ä»¤ç‰Œä¹‹åçš„ä»»ä½•é¢„å¤„ç†ä»¤ç‰Œçš„å¤„ç†æ–¹å¼ä¸æ™®é€šæ–‡æœ¬ç›¸åŒã€‚

