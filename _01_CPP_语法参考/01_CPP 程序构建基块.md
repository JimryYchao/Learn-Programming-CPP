## C++ ç¨‹åºæ„å»ºåŸºå—

- [ ] [ç”¨æˆ·å®šä¹‰æ–‡æœ¬](#ç”¨æˆ·å®šä¹‰æ–‡æœ¬-todo)


---
### è¯æ³•å…ƒç´ 

#### å­—ç¬¦é›†

C++ æŒ‡å®šå¯ç”¨äºæºæ–‡ä»¶çš„åŸºæœ¬æºå­—ç¬¦é›†å’Œé€šç”¨å­—ç¬¦é›†ï¼š

```c++
' ', '\t', '\v', '\f', '\n',
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '
```

é€šç”¨å­—ç¬¦åç§°æ˜¯å½¢å¦‚ `\u hhhh` æˆ– `\U HHHHHHHH` è¡¨ç¤ºçš„ Unicode ç ä½çš„å­—ç¬¦åºåˆ—ã€‚ç”¨äºæ ‡è¯†æ ‡è¯†ç¬¦ã€å­—ç¬¦ä¸²æˆ–å­—ç¬¦æ–‡æœ¬ã€‚

æ‰§è¡Œå­—ç¬¦é›†è¡¨ç¤ºç¼–è¯‘ç¨‹åºä¸­å¯æ˜¾ç¤ºçš„å­—ç¬¦å’Œå­—ç¬¦ä¸²ã€‚è¿™äº›å­—ç¬¦é›†åŒ…å«æºæ–‡ä»¶ä¸­å…è®¸çš„æ‰€æœ‰å­—ç¬¦ï¼Œä»¥åŠè¡¨ç¤º `\a`ã€`\b`ã€`\r` å’Œ `\0` çš„æ§åˆ¶å­—ç¬¦ã€‚æ‰§è¡Œå­—ç¬¦é›†å…·æœ‰ç‰¹å®šäºåŒºåŸŸè®¾ç½®çš„è¡¨ç¤ºå½¢å¼ã€‚

>---
#### æ ‡è®°

æ ‡è®°æœ‰äº”ç§ï¼šæ ‡è¯†ç¬¦ã€å…³é”®å­—ã€æ–‡æœ¬ã€è¿ç®—ç¬¦å’Œå…¶ä»–åˆ†éš”ç¬¦ï¼›ç©ºç™½å­—ç¬¦åŒ…æ‹¬æœ‰ç©ºæ ¼ ```' '```ã€æ°´å¹³åˆ¶è¡¨ç¬¦ ```'\t'```ã€æ¢è¡Œç¬¦ ```'\n'```ã€å›è½¦ç¬¦ ```'\r'```ã€æ¢é¡µç¬¦ ```'\f'``` å’Œå‚ç›´åˆ¶è¡¨ç¬¦ ```'\v'```ã€‚æ ‡è®°ç”±ç©ºç™½ç¬¦å’Œå…¶ä»–æ ‡è®°åˆ†éš”ï¼ˆåˆ’åˆ†è¾¹ç•Œï¼‰ï¼Œåœ¨åˆ†æä»£ç æ—¶ï¼Œç¼–è¯‘å™¨å°†å¿½ç•¥ç©ºç™½å­—ç¬¦ã€‚

æ ‡è¯†ç¬¦ä¸ºç¨‹åºä¸­çš„å¯¹è±¡ã€å˜é‡ã€ç±»å‹ã€ç±»å‹æˆå‘˜ã€å‡½æ•°ã€ç±»å‹å®šä¹‰ã€å®å®šä¹‰ã€å®å‚æ•°å‚æ•°å’Œæ ‡ç­¾æä¾›åç§°ï¼Œåç§°åœ¨æ‹¼å†™å’Œå¤§å°å†™ä¸Šå¿…é¡»ä¸ä»»ä½•å…³é”®å­—éƒ½ä¸åŒã€‚æ ‡è¯†ç¬¦çš„é¦–å­—ç¬¦ä¸å¯ä»¥æ˜¯æ•°å­—å­—ç¬¦ã€‚

```cpp
/* æœ‰æ•ˆæ ‡è¯†ç¬¦ */  // æ³¨é‡Š
_Identifier
Identifier
Identifier123
```

`final`ã€`import`ã€`module`ã€`override` ä¿ç•™å…³é”®å­—ç”± C++ ç¼–è¯‘å™¨ä½¿ç”¨ã€‚

>---
#### Keywords

| keyword | description |
| :------ | :---------- |
`alignas`
`alignof`
`asm`
`auto`
`bool`
`break`
`case`
`catch`
`char`
`char8_t`
`char16_t`
`char32_t`
`class`
`concept`
`const`
`consteval`
`constexpr`
`constinit`
`const_cast`
`continue`
`co_await`
`co_return`
`co_yield`
`decltype`
`default`
`delete`
`do`
`double`
`dynamic_cast`
`else`
`enum`
`explicit`
`export`
`extern`
`false`
`float`
`for`
`friend`
`goto`
`if`
`inline`
`int`
`long`
`mutable`
`namespace`
`new`
`noexcept`
`nullptr`
`operator`
`private`
`protected`
`public`
`register`
`reinterpret_cast`
`requires`
`return`
`short`
`signed`
`sizeof`
`static`
`static_assert`
`static_cast`
`struct`
`switch`
`template`
`this`
`thread_local`
`throw`
`true`
`try`
`typedef`
`typeid`
`typename`
`union`
`unsigned`
`using`
`virtual`
`void`
`volatile`
`wchar_t`
`while`


>---
#### Operators & Punctuation

```cpp
{ } [ ] ( )
<: :> <% %> ; : ...
? :: . .* -> ->* ~
! + - * / % ^ & |
= += -= *= /= %= ^= &= |=
== != < > <= >= <=> && ||
<< >> <<= >>= ++ -- ,
and or xor not bitand bitor compl
and_eq or_eq xor_eq not_eq
```

> æ›¿ç”¨æ ‡å¿—ï¼Œä¿ç•™

```cpp
// Alternative/Primary
    <%           {   
    %>           }    
    <:           [    
    :>           ]    
    %:           #    
    %:%:         ##   
    and          &&    
    or           ||  
    not          !  
    xor          ^     
    bitand       &    
    bitor        | 
    compl        ~     
    not_eq       !=  
    xor_eq       ^= 
    and_eq       &= 
    or_eq        |=  
```

>---
#### Number, Boolean, Pointer Literal

æ–‡æœ¬æ˜¯ä¸€ç§ç›´æ¥è¡¨ç¤ºå€¼çš„ç¨‹åºå…ƒç´ ã€‚åŒ…å«ç”±æ•´æ•°ã€æµ®ç‚¹ã€å¸ƒå°”ã€æŒ‡é’ˆã€å­—ç¬¦ã€å­—ç¬¦ä¸²ç±»å‹çš„æ–‡æœ¬ä»¥åŠç”¨æˆ·å®šä¹‰çš„æ–‡æœ¬ã€‚

æ•´æ•°æ–‡æœ¬å¯ä»¥æ˜¯äºŒè¿›åˆ¶ã€å…«è¿›åˆ¶ã€åè¿›åˆ¶æˆ–åå…­è¿›åˆ¶çš„æ•°å­—åºåˆ—ï¼š

```cpp
long b = 0b1011'0101;      // b-binary
long o = 013245670;        // 0-octal
long i = 1234567890LL;     // decimal
long long h = 0x1234'5678'90ab'cdfLL;  // x-hexadecimal

unsigned ui = 110u;
unsigned long long uh = 0XFFFFULL; //x-hexadecimal
size_t z = -10010z;
ssize_t uz = 10086uz;
```

æµ®ç‚¹æ–‡æœ¬æ˜¯åè¿›åˆ¶æˆ–åå…­è¿›åˆ¶ï¼ˆ`0x` or `0X` å‰ç¼€ï¼‰è¡¨ç¤ºçš„æ•°å­—åºåˆ—ã€‚*E* æŒ‡æ•°è¡¨ç¤ºæ³•ï¼ˆä»¥ 10 ä¸ºåŸºæ•°ï¼‰ç”¨äºåè¿›åˆ¶ï¼›*P* æŒ‡æ•°è¡¨ç¤ºæ³•ï¼ˆä»¥ 2 ä¸ºåŸºæ•°ï¼‰ç”¨äºåå…­è¿›åˆ¶ã€‚

```c++
float f = 3.1415F;
double d = 3.1415;
long double ld = 3.1415L;
float16_t f16 = 3.1415f16;
float32_t f32 = 3.1415f32;
float64_t d2 = 3.1415f64;
float128_t f64 = 3.1415f128;
bfloat16_t bf16 = 3.1415bf16;  // BF
// decimal
double e1 = 1.234e-2; 
double e2 = 1.234E2;
// hexadecimal
double p1 = 0x1p-2;	  // == 0.25
double p2 = 0x2.p10;  // == 2048.0
```

å¸ƒå°”æ–‡æœ¬æ˜¯å…³é”®å­— `false` å’Œ `true`ã€‚æ­¤ç±»æ–‡æœ¬çš„ç±»å‹ä¸º `bool`ã€‚

æŒ‡é’ˆæ–‡æœ¬æ˜¯å…³é”®å­— `nullptr`ã€‚å®ƒçš„ç±»å‹ä¸º `std::nullptr_t`ã€‚`nullptr` ç”¨æ¥åˆå§‹åŒ–é›¶å€¼æŒ‡é’ˆã€‚



>---
#### Character, String Literal

å­—ç¬¦æ–‡æœ¬è¡¨ç¤ºä¸€ä¸ªæˆ–å¤šä¸ªå¤šå­—èŠ‚å­—ç¬¦çš„åºåˆ—ã€‚`wchar_t`ã€`char16_t`ã€`char32_t` å­—ç¬¦ç§°ä¸ºå®½å­—ç¬¦ï¼Œ`char8_t` å’Œæ™®é€šå­—ç¬¦ä¸ºçª„å­—ç¬¦ã€‚åºåˆ—å…ƒç´ æ˜¯æºå­—ç¬¦é›†çš„ä»»ä½•æˆå‘˜ï¼›å®ƒä»¬ä»¥å®ç°å®šä¹‰çš„æ–¹å¼æ˜ å°„åˆ°æ‰§è¡Œå­—ç¬¦é›†çš„æˆå‘˜ã€‚

```c++
// Character literals
auto c0 =   'A';  // char; æ™®é€šå­—ç¬¦
auto c1 = u8'A';  // char; UTF-8
auto c2 =  L'A';  // wchar_t; å®½å­—ç¬¦
auto c3 =  u'A';  // char16_t; UTF-16
auto c4 =  U'A';  // char32_t; UTF-32
auto m0 = 'abcd'; // int, value 0x61626364; å¤šå­—èŠ‚

// å…«è¿›åˆ¶ã€åå…­è¿›åˆ¶è½¬ä¹‰åºåˆ—å’Œé€šç”¨å­—ç¬¦åºåˆ—
char u1 = 'A';          // 'A'
char u2 = '\101';       // octal, 'A'; 1-3 ä½å…«è¿›åˆ¶ï¼Œæœ€å¤§ \377
char u3 = '\x41';       // hexadecimal, 'A'
char u4 = '\u0041';     // \u UCN 'A'
char u5 = '\U00000041'; // \U UCN 'A'

// è½¬ä¹‰å­—ç¬¦
'\'' '\"' '\?' '\\' '\a' '\b' '\f' '\n' '\r' '\t' '\v'
```

å­—ç¬¦ä¸²æ–‡æœ¬çš„ç§ç±»ã€ç±»å‹åŠå…¶å…³è”çš„å­—ç¬¦ç¼–ç ç”±å…¶ç¼–ç å‰ç¼€å’Œå­—ç¬¦åºåˆ—å†³å®šã€‚å¸¸è§„å­—ç¬¦ä¸²æ–‡æœ¬å’Œ UTF-8 å­—ç¬¦ä¸²æ–‡æœ¬ç§°ä¸ºçª„å­—ç¬¦ä¸²æ–‡æœ¬ã€‚

```c++
auto s0 =   "hello"; // const char*
auto s1 = u8"hello"; // const char8_t* 
auto s2 =  L"hello"; // const wchar_t*
auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16
auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32
const char32_t* s5 = U"ğŸ˜ = \U0001F60E is B-)";
```

å‰ç¼€ä¸­å¸¦æœ‰ R çš„å­—ç¬¦ä¸²æ–‡æœ¬æ˜¯åŸå§‹å­—ç¬¦ä¸²æ–‡æœ¬ã€‚`R"delimiter( char-sequence )delimiter"` ä¸­ `delimiter` æœ€å¤šåŒ…å« 16 ä¸ªå­—ç¬¦ï¼›`R"((a|b))"` ç­‰ä»·äº `"(a|b)"`ã€‚

```c++
auto R0 =   R"("Hello \ world")"; // const char*
auto R1 = u8R"("Hello \ world")"; // const char8_t*
auto R2 =  LR"("Hello \ world")"; // const wchar_t*
auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16
auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32
```

`s` åç¼€è¡¨ç¤ºæ˜ å°„åˆ° `std::string` ç±»å‹çš„é™æ€å€¼ã€‚

```c++
auto S0 =   "hello"s; // std::string
auto S1 = u8"hello"s; // std::u8string in C++20
auto S2 =  L"hello"s; // std::wstring
auto S3 =  u"hello"s; // std::u16string
auto S4 =  U"hello"s; // std::u32string

auto S5 =   R"("Hello \ world")"s; // std::string from a raw const char*
auto S6 = u8R"("Hello \ world")"s; // std::u8string from a raw const char* 
auto S7 =  LR"("Hello \ world")"s; // std::wstring from a raw const wchar_t*
auto S8 =  uR"("Hello \ world")"s; // std::u16string from a raw const char16_t*, encoded as UTF-16
auto S9 =  UR"("Hello \ world")"s; // std::u32string from a raw const char32_t*, encoded as UTF-32
```

ç›¸é‚»å­—ç¬¦ä¸²æ–‡æœ¬åºåˆ—çš„å…¬å…±ç¼–ç å‰ç¼€è¦ä¹ˆç›¸åŒï¼Œè¦ä¹ˆå…¶ä¸­ä¸€ä¸ªæ²¡æœ‰ç¼–ç å‰ç¼€ï¼›ä»»ä½•å…¶ä»–ç»„åˆéƒ½æ˜¯æ ¼å¼ä¸æ­£ç¡®çš„ã€‚è®¡ç®—å­—ç¬¦ä¸²æ–‡æœ¬ä¼šç”Ÿæˆå…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å­—ç¬¦ä¸²æ–‡æœ¬å¯¹è±¡ã€‚

```c++
char str[] = "12" "34";  // "1234"
auto hi = u8"hello" " " "world"s;
auto err = U"hello" " " L"world"; // disagree on prefix
```

>---
#### User Defined Literal

ç”¨æˆ·å®šä¹‰æ–‡æœ¬å¯ä»¥æ˜¯æ•´æ•°ã€æµ®ç‚¹æ•°ã€å­—ç¬¦æˆ–å­—ç¬¦ä¸²ç”¨æˆ·å®šä¹‰ï¼Œç”¨æˆ·å®šä¹‰æ–‡æœ¬ç”±ä¸€ä¸ªç”¨æˆ·å®šä¹‰åç¼€æ ‡è¯†ã€‚ç”¨æˆ·å®šä¹‰æ–‡æœ¬è¢«è§†ä¸ºå¯¹æ–‡æœ¬è¿ç®—ç¬¦æˆ–æ–‡æœ¬è¿ç®—ç¬¦æ¨¡æ¿çš„è°ƒç”¨ã€‚

```c++
using namespace std;
long double operator""_w(long double);
string operator""_w(const char16_t *, size_t);
unsigned operator""_w(const char *);
int main()
{
	1.2_w;	  // calls operator ""_w(1.2L)
	u"one"_w; // calls operator ""_w(u"one", 3)
	12_w;	  // calls operator ""_w("12")
	"two"_w; // error: no applicable literal operator
}
```

é€šè¿‡ä»¥ä¸‹å½¢å¼ä¹‹ä¸€åœ¨å‘½åç©ºé—´èŒƒå›´å®šä¹‰ `operator""` æ¥å®ç°ç”¨æˆ·å®šä¹‰æ–‡æœ¬ï¼Œè¿™äº›å‡½æ•°éƒ½å¯å®šä¹‰ä¸º `constexpr`ï¼š

```c++
ReturnType operator "" _a(unsigned long long int);   // user-defined INTEGRAL literal
ReturnType operator "" _b(long double);              // user-defined FLOATING literal
ReturnType operator "" _c(char);                     // user-defined CHARACTER literal
ReturnType operator "" _d(wchar_t);                  // user-defined CHARACTER literal
ReturnType operator "" _e(char16_t);                 // user-defined CHARACTER literal
ReturnType operator "" _f(char32_t);                 // user-defined CHARACTER literal
ReturnType operator "" _g(const char*, size_t);      // user-defined STRING literal
ReturnType operator "" _h(const wchar_t*, size_t);   // user-defined STRING literal
ReturnType operator "" _i(const char16_t*, size_t);  // user-defined STRING literal
ReturnType operator "" _g(const char32_t*, size_t);  // user-defined STRING literal
ReturnType operator "" _r(const char*);              // Raw literal operator
template<char...> ReturnType operator "" _t();       // Literal operator template
```

---
### åŸºæœ¬æ¦‚å¿µ
#### ç¿»è¯‘é˜¶æ®µ

æºæ–‡ä»¶ä»¥åŠé€šè¿‡é¢„å¤„ç†æŒ‡ä»¤ `#include` åŒ…å«çš„æ‰€æœ‰å¤´æ–‡ä»¶å’Œæºæ–‡ä»¶ï¼Œå»æ‰ä»»ä½•è¢«æ¡ä»¶ç¼–è¯‘ `#if` è·³è¿‡çš„éƒ¨åˆ†ï¼Œä»¥åŠç”±ä»»ä½•æ¡ä»¶æ”¯æŒçš„æŒ‡ä»¤å’Œç¼–è¯‘æŒ‡ç¤ºçš„å®ç°å®šä¹‰è¡Œä¸ºä¿®æ”¹ï¼Œè¢«ç§°ä¸ºé¢„å¤„ç†ç¿»è¯‘å•å…ƒã€‚

æºæ–‡ä»¶ä¸éœ€è¦å…¨éƒ¨åŒæ—¶ç¿»è¯‘ï¼Œç¿»è¯‘å•å…ƒå’Œå®ä¾‹åŒ–å•å…ƒå¯ä»¥å•ç‹¬ä¿å­˜æˆ–ä¿å­˜åœ¨åº“ä¸­ï¼Œç¨‹åºçš„å•ç‹¬ç¿»è¯‘å•å…ƒé€šè¿‡è°ƒç”¨å…·æœ‰å¤–éƒ¨é“¾æ¥æˆ–æ¨¡å—é“¾æ¥çš„å‡½æ•°ã€å¯¹è±¡ç­‰çš„æ ‡è¯†ç¬¦ã€æˆ–æ“ä½œæ•°æ®æ–‡ä»¶è¿›è¡Œé€šä¿¡ã€‚ç¿»è¯‘å•å…ƒå¯ä»¥å•ç‹¬ç¿»è¯‘ï¼Œç„¶åé“¾æ¥å…¶ä»–å•å…ƒä»¥ç”Ÿæˆå¯æ‰§è¡Œç¨‹åºã€‚

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯èƒ½éœ€è¦åœ¨ .cpp æ–‡ä»¶ä¸­å£°æ˜å…¨å±€å˜é‡æˆ–ç±»ã€‚ åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œä½ éœ€è¦ä¸€ç§æ–¹æ³•æ¥å‘ŠçŸ¥ç¼–è¯‘å™¨å’Œé“¾æ¥å™¨åç§°æ‰€å…·æœ‰çš„é“¾æ¥ç±»å‹ã€‚ é“¾æ¥çš„ç±»å‹æŒ‡å®šå¯¹è±¡çš„åç§°æ˜¯ä»…åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­å¯è§ï¼Œè¿˜æ˜¯åœ¨æ‰€æœ‰æ–‡ä»¶ä¸­å¯è§ã€‚ é“¾æ¥çš„æ¦‚å¿µä»…é€‚ç”¨äºå…¨å±€åç§°ã€‚ é“¾æ¥çš„æ¦‚å¿µä¸é€‚ç”¨äºåœ¨ä¸€å®šèŒƒå›´å†…å£°æ˜çš„åç§°ã€‚ èŒƒå›´æ˜¯ç”±ä¸€ç»„å°é—­çš„å¤§æ‹¬å·æŒ‡å®šçš„ï¼Œä¾‹å¦‚åœ¨å‡½æ•°æˆ–ç±»çš„å®šä¹‰ä¸­ã€‚

1. å­—ç¬¦æ˜ å°„ï¼šæºæ–‡ä»¶ä¸­çš„å­—ç¬¦å°†æ˜ å°„åˆ°å†…éƒ¨æºè¡¨ç¤ºå½¢å¼ã€‚
2. è¡Œæ‹¼æ¥ï¼šä»¥åæ–œæ  (`\`) ç»“æŸä¸”åè·Ÿæ¢è¡Œç¬¦çš„æ‰€æœ‰è¡Œå°†ä¸æºæ–‡ä»¶ä¸­ä»ç‰©ç†è¡Œå½¢æˆé€»è¾‘è¡Œçš„ä¸‹ä¸€è¡Œè”æ¥ã€‚
3. ä»¤ç‰ŒåŒ–ï¼šæºæ–‡ä»¶åˆ†ä¸ºé¢„å¤„ç†æ ‡è®°å’Œç©ºç™½å­—ç¬¦ã€‚ æºæ–‡ä»¶ä¸­çš„æ³¨é‡Šå°†é€ä¸€æ›¿æ¢ä¸ºç©ºç™½å­—ç¬¦ã€‚ æ¢è¡Œç¬¦å°†ä¿ç•™ã€‚
4. é¢„å¤„ç†ï¼šæ‰§è¡Œé¢„å¤„ç†æŒ‡ä»¤ï¼Œæ‰©å±•å®è°ƒç”¨ï¼Œå¹¶æ‰§è¡Œ `_Pragma` è¡¨è¾¾å¼ã€‚`#include` è¯­å¥æŒ‰ç¬¬ 1 ~ 4 é˜¶æ®µé€’å½’å¤„ç†ã€‚ç„¶ååˆ é™¤æ‰€æœ‰é¢„å¤„ç†æŒ‡ä»¤ã€‚
5. å­—ç¬¦é›†æ˜ å°„ï¼šæ‰€æœ‰æºå­—ç¬¦é›†æˆå‘˜å’Œè½¬ä¹‰åºåˆ—å°†è½¬æ¢ä¸ºæ‰§è¡Œå­—ç¬¦é›†ä¸­çš„ç­‰æ•ˆé¡¹ã€‚
6. å­—ç¬¦ä¸²ä¸²è”ï¼šä¸²è”ç›¸é‚»çš„å­—ç¬¦ä¸²æ–‡å­—ä»¤ç‰Œã€‚
7. ç¿»è¯‘ï¼šå°†ä»è¯­æ³•å’Œè¯­ä¹‰ä¸Šåˆ†ææ‰€æœ‰ä»¤ç‰Œï¼›å¹¶å°†å®ƒä»¬è½¬æ¢ä¸ºå¯¹è±¡ä»£ç ã€‚
8. å®ä¾‹åŒ–å•å…ƒï¼šæ£€æŸ¥æ¯ä¸ªç¿»è¯‘çš„ç¿»è¯‘å•å…ƒï¼Œä»¥ç”Ÿæˆæ‰€éœ€å®ä¾‹åŒ–çš„åˆ—è¡¨ã€‚æ‰¾åˆ°æ‰€éœ€æ¨¡æ¿çš„å®šä¹‰ã€‚
9. é“¾æ¥ï¼šè§£ææ‰€æœ‰å¤–éƒ¨å¼•ç”¨ä»¥åˆ›å»ºå¯æ‰§è¡Œç¨‹åºæˆ–åŠ¨æ€é“¾æ¥åº“ã€‚

>---
#### ç¨‹åºå¯åŠ¨

ç¨‹åºå¯åŠ¨éœ€è¦å…¥å£å‡½æ•° `main`ï¼ŒåŠ¨æ€é“¾æ¥åº“å’Œé™æ€åº“æ²¡æœ‰ `main` å‡½æ•°ã€‚ç¨‹åºè¿›å…¥ `main` å‡½æ•°ä¹‹å‰ï¼Œæ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ `static` ç±»æˆå‘˜é›¶åˆå§‹åŒ–ã€‚

```c++
int main(); // æˆ–
int main(int argc, char *argv[]);
```

`argc` å’Œ `argv` çš„ç±»å‹ç”±è¯­è¨€å®šä¹‰ã€‚`argc` åŒ…å« `argv` å‚æ•°çš„è®¡æ•°ï¼Œ`argv` è‡³å°‘åŒ…å«ç¨‹åºåç§°çš„ `argv[0]`ã€‚`argv[1]` æ˜¯ç¬¬ä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•°ã€‚ å‘½ä»¤è¡Œçš„æœ€åä¸€ä¸ªå‚æ•°æ˜¯ `argv[argc - 1]`ï¼Œå¹¶ä¸” `argv[argc]` å§‹ç»ˆä¸º `NULL`ã€‚

```c++
#include <iostream>

using namespace std;
int main( int argc,      // Number of strings in array argv
          char *argv[])   // Array of command-line argument strings
{
    int count;
    // Display each command-line argument.
    cout << "\nCommand-line arguments:\n";
    for( count = 0; count < argc; count++ )
         cout << "  argv[" << count << "]   "
                << argv[count] << "\n";
}
```


>---
#### ç¨‹åºç»ˆæ­¢

åœ¨ C++ ä¸­ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼é€€å‡ºç¨‹åºï¼š

- è°ƒç”¨ `exit` å‡½æ•°ï¼Œç»ˆæ­¢ç¨‹åºå¹¶æ‰§è¡Œæ¸…ç†ï¼ˆå¦‚è°ƒç”¨å…¨å±€å¯¹è±¡ææ„å‡½æ•°ï¼‰ã€‚
- è°ƒç”¨ `abort` å‡½æ•°ã€‚ç«‹å³ç»ˆæ­¢ç¨‹åºï¼Œè·³è¿‡ `atexit` æœºåˆ¶ã€‚
- ä» `main` æ‰§è¡Œ `return` è¯­å¥ã€‚

```c++
#include <cstdlib>

int main() {
    if (cond1){
        exit(EXIT_SUCCESS);  // or EXIT_FAILURE 
    }else if (cond2) {
        abort();
    }else 
        return 0;
}
```

`atexit` ç”¨äºåœ¨ç¨‹åºç»ˆæ­¢ä¹‹å‰æ‰§è¡Œçš„æ“ä½œï¼Œåœ¨æ­¤ä¹‹å‰ä¸ä¼šé”€æ¯ä»»ä½•åˆå§‹åŒ–çš„å…¨å±€é™æ€å¯¹è±¡ã€‚

ä½¿ç”¨ `return` è¯­å¥å¯ä»¥ä» `main` æŒ‡å®šä¸€ä¸ªè¿”å›å€¼ï¼Œä»»ä½•è‡ªåŠ¨å˜é‡éƒ½å°†è¢«é”€æ¯ã€‚ ç„¶åï¼Œ`main` ä»¥è¿”å›å€¼ä½œä¸ºå‚æ•°è°ƒç”¨ `exit`ã€‚ç›´æ¥è°ƒç”¨ `exit` ä¸ä¼šé”€æ¯è‡ªåŠ¨å˜é‡ã€‚

> çº¿ç¨‹å’Œé™æ€å¯¹è±¡çš„é”€æ¯

ç›´æ¥è°ƒç”¨ `exit` æ—¶ï¼ˆæˆ–åœ¨ `main` çš„ `return` è¯­å¥ä¹‹åè°ƒç”¨å®ƒæ—¶ï¼‰ï¼Œå°†é”€æ¯ä¸å½“å‰çº¿ç¨‹å…³è”çš„çº¿ç¨‹å¯¹è±¡ã€‚ç„¶åæŒ‰ä¸åˆå§‹åŒ–ç›¸åçš„é¡ºåºé”€æ¯é™æ€å¯¹è±¡ï¼ˆåœ¨è°ƒç”¨æŒ‡å®šç»™ `atexit` çš„å‡½æ•°ï¼ˆå¦‚æœæœ‰ï¼‰ä¹‹åï¼‰ã€‚ 

```c++
#include <cstdio>
class ShowData {
public:
	ShowData(const char* szDev) {
		errno_t err;
		err = fopen_s(&OutputDev, szDev, "w");
	}

	~ShowData() { fclose(OutputDev); }
	void Disp(const char* szData) {
		fputs(szData, OutputDev);
	}
private:
	FILE* OutputDev;
};
//  Define a static object of type ShowData. The output device
//   selected is "CON" -- the standard output device.
ShowData sd1 = "CON";
ShowData sd2 = "CON";

int main() {
	sd1.Disp("hello sd1\n");
	sd2.Disp("hello sd2\n");  // ç›¸åé¡ºåºé”€æ¯å¹¶è°ƒç”¨ ~ShowData()
}
// hello sd2  
// hello sd1
```

>---
#### ç±»å‹ç³»ç»Ÿ

æ ‡é‡ç±»å‹ï¼šåŒ…å«å®šä¹‰èŒƒå›´çš„å•ä¸ªå€¼çš„ç±»å‹ã€‚æ ‡é‡åŒ…æ‹¬ç®—æœ¯ç±»å‹ï¼ˆæ•´å‹æˆ–æµ®ç‚¹å€¼ï¼‰ã€æšä¸¾ç±»å‹æˆå‘˜ã€æŒ‡é’ˆç±»å‹ã€æŒ‡é’ˆåˆ°æˆå‘˜ç±»å‹ä»¥åŠ std::nullptr_tã€‚åŸºæœ¬ç±»å‹é€šå¸¸æ˜¯æ ‡é‡ç±»å‹ã€‚

å¤åˆç±»å‹ï¼šå¤åˆç±»å‹åŒ…æ‹¬æ•°ç»„ç±»å‹ã€å‡½æ•°ç±»å‹ã€ç±»ï¼ˆæˆ–ç»“æ„ï¼‰ç±»å‹ã€è”åˆç±»å‹ã€æšä¸¾ã€å¼•ç”¨å’ŒæŒ‡å‘éé™æ€ç±»æˆå‘˜çš„æŒ‡é’ˆã€‚

å˜é‡ï¼šæ•°æ®é‡çš„ç¬¦å·åç§°ã€‚è¯¥åç§°å¯ç”¨äºè®¿é—®å®ƒåœ¨æ•´ä¸ªå®šä¹‰ä»£ç èŒƒå›´å†…å¼•ç”¨çš„æ•°æ®ã€‚å˜é‡é€šå¸¸æŒ‡æ ‡é‡å®ä¾‹ï¼Œå…¶ä»–ç±»çš„å®ä¾‹ä¸ºå¯¹è±¡ã€‚

å¯¹è±¡ï¼šè¡¨ç¤ºç±»æˆ–ç»“æ„çš„å®ä¾‹ã€‚åœ¨ä¸€èˆ¬æ„ä¹‰ä¸ŠåŒ…æ‹¬æ‰€æœ‰ç±»å‹ã€‚

POD ç±»å‹ï¼ˆçº¯æ—§æ•°æ®ï¼‰ï¼šC++ ä¸­æ­¤ç±»éæ­£å¼æ•°æ®ç±»å‹ç±»åˆ«æ˜¯æŒ‡ä½œä¸ºæ ‡é‡çš„ç±»å‹æˆ– POD ç±»ã€‚POD ç±»æ²¡æœ‰é POD çš„é™æ€æ•°æ®æˆå‘˜ï¼Œæ²¡æœ‰ç”¨æˆ·å®šä¹‰æ„é€ å‡½æ•°ã€ç”¨æˆ·å®šä¹‰ææ„å‡½æ•°æˆ–ç”¨æˆ·å®šä¹‰èµ‹å€¼è¿ç®—ç¬¦ã€‚POD ç±»æ— è™šå‡½æ•°ã€åŸºç±»ã€ç§æœ‰æˆ–å—ä¿æŠ¤çš„éé™æ€æ•°æ®æˆå‘˜ã€‚é€šå¸¸ç”¨äºå¤–éƒ¨æ•°æ®äº¤æ¢ï¼Œä¾‹å¦‚ä¸ç”¨ C è¯­è¨€ç¼–å†™çš„æ¨¡å—ï¼ˆä»…å…·æœ‰ POD ç±»å‹ï¼‰è¿›è¡Œæ•°æ®äº¤æ¢ã€‚

C++ æ˜¯å¼ºç±»å‹çš„é™æ€ç±»å‹è¯­è¨€ï¼Œæ¯ä¸ªå¯¹è±¡éƒ½æœ‰ä¸€ä¸ªç±»å‹ã€‚C++ ä¸­ä¸å­˜åœ¨æ´¾ç”Ÿæ‰€æœ‰å…¶ä»–ç±»å‹çš„é€šç”¨åŸºç±»å‹ã€‚C++ çš„å†…ç½®ç±»å‹åŒ…æ‹¬æ•°å€¼ç±»å‹ï¼ˆ`int`ã€`double`ã€`long`ã€`bool` ä»¥åŠåˆ†åˆ«é’ˆå¯¹ ASCII å’Œ UNICODE å­—ç¬¦çš„ `char` å’Œ `wchar_t` ç±»å‹ç­‰ï¼‰ã€‚C++ æ²¡æœ‰å†…ç½®å­—ç¬¦ä¸²ç±»å‹ï¼Œå®ƒæ˜¯ C æ ·å¼å­—ç¬¦ä¸²ã€‚


ä»»ä½•å†…ç½®æˆ–ç”¨æˆ·å®šä¹‰ç±»å‹éƒ½å¯ç”± `const` é™å®šã€‚ æˆå‘˜å‡½æ•°å¯å—åˆ° `const` é™å®šï¼Œä¹Ÿå¯ä»¥é‡è½½ `const`ã€‚`const` ç±»å‹çš„å€¼åˆå§‹åŒ–åæ— æ³•ä¿®æ”¹ã€‚ç”¨æˆ·å®šä¹‰ç±»å‹åŒ…å« `class`ã€`struct`ã€`union`ã€`enum`ã€‚

åœ¨ C++ ä¸­ï¼ŒåŸå§‹æŒ‡é’ˆå˜é‡å£°æ˜åªåˆ†é…è¶³å¤Ÿçš„å†…å­˜æ¥å­˜å‚¨åœ°å€ï¼Œä¸åŒ…å«å­˜å‚¨æ•°æ®å€¼æ‰€éœ€çš„å†…å­˜ï¼›ç”¨æˆ·å®šä¹‰ç±»å‹å¯ä»¥é€šè¿‡ `new` è¡¨è¾¾å¼åœ¨å †ä¸­åŠ¨æ€åˆ†é…å†…å­˜ï¼Œå¹¶åœ¨å¿…è¦æ—¶ç”±ç›¸åº”çš„ `delete` åˆ é™¤ï¼ˆCï¼š`malloc` > `free`ï¼‰ã€‚

>---
#### èŒƒå›´, é“¾æ¥å’Œå­˜å‚¨æœŸ

ç¨‹åºä¸­çš„å£°æ˜å¯ä»¥å‡ºç°åœ¨å¾ˆå¤šèŒƒå›´ï¼ˆ*scope*ï¼Œä½œç”¨åŸŸï¼‰ä¸­ã€‚å…¨å±€èŒƒå›´åŒ…å«æ•´ä¸ªç¨‹åºã€‚åç§°å¯è§çš„ä¸Šä¸‹æ–‡ç§°ä¸ºå…¶ç›®æ ‡èŒƒå›´ã€‚æœ‰å…­ç§èŒƒå›´ï¼š

- å…¨å±€èŒƒå›´ï¼šå…¨å±€åç§°æ˜¯åœ¨ä»»ä½•ç±»ã€å‡½æ•°æˆ–å‘½åç©ºé—´ä¹‹å¤–å£°æ˜çš„åç§°ã€‚å…¨å±€åç§°çš„èŒƒå›´ä»å£°æ˜ç‚¹æ‰©å±•åˆ°å£°æ˜æ–‡ä»¶æœ«å°¾ã€‚

+ å‘½åç©ºé—´èŒƒå›´ï¼šåœ¨å‘½åç©ºé—´ä¸­å£°æ˜çš„åç§°ï¼ˆåœ¨ä»»ä½•ç±»ã€æšä¸¾å®šä¹‰ã€æˆ–å‡½æ•°å—ä¹‹å¤–ï¼‰ä»å…¶å£°æ˜ç‚¹åˆ°å‘½åç©ºé—´æœ«å°¾å¯è§ã€‚å‘½åç©ºé—´å¯ä»¥åœ¨è·¨ä¸åŒæ–‡ä»¶çš„å¤šä¸ªå—ä¸­å®šä¹‰ã€‚

- å±€éƒ¨èŒƒå›´ï¼šåœ¨å‡½æ•°æˆ– lambda ä¸­å£°æ˜çš„åç§°ï¼ˆåŒ…æ‹¬å‚æ•°åç§°ï¼‰å…·æœ‰å±€éƒ¨èŒƒå›´ã€‚å±€éƒ¨å˜é‡ä»…ä»å£°æ˜ç‚¹åˆ°å‡½æ•°æˆ– lambda æ­£æ–‡çš„æœ«å°¾å¯è§ã€‚å±€éƒ¨èŒƒå›´æ˜¯ä¸€ç§å—èŒƒå›´ã€‚

+ ç±»èŒƒå›´ï¼šç±»æˆå‘˜çš„åç§°å…·æœ‰ç±»èŒƒå›´ï¼Œè¯¥èŒƒå›´åœ¨æ•´ä¸ªç±»å®šä¹‰ä¸­æ‰©å±•ï¼Œä¸å£°æ˜ç‚¹æ— å…³ã€‚ç±»æˆå‘˜å¯è®¿é—®æ€§ç”± `public`ã€`private` å’Œ `protected` å…³é”®å­—è¿›ä¸€æ­¥æ§åˆ¶ã€‚

- è¯­å¥èŒƒå›´ï¼šåœ¨ `for`ã€`if`ã€`while` æˆ– `switch` ã€`case` è¯­å¥ä¸­å£°æ˜çš„åç§°åœ¨è¯­å¥å—ç»“æŸä¹‹å‰å¯è§ã€‚

+ æ ‡ç­¾èŒƒå›´ï¼šæ ‡ç­¾å…·æœ‰å‡½æ•°èŒƒå›´ï¼Œè¿™æ„å‘³ç€å®ƒåœ¨æ•´ä¸ªå‡½æ•°æ­£æ–‡ä¸­ç”šè‡³åœ¨å£°æ˜ç‚¹ä¹‹å‰éƒ½æ˜¯å¯è§çš„ã€‚

ä¸€ä¸ª *symbol*ï¼ˆä¾‹å¦‚å˜é‡æˆ–å‡½æ•°åç§°ï¼‰å¯ä»¥åœ¨å…¶èŒƒå›´å†…è¿›è¡Œä»»æ„æ¬¡æ•°çš„å£°æ˜ã€‚ä½†ä¸€ä¸ªç¬¦å·åªèƒ½è¢«å®šä¹‰ä¸€æ¬¡ï¼ˆå•ä¸€å®šä¹‰åŸåˆ™ï¼ŒODRï¼‰ã€‚å£°æ˜åœ¨ç¨‹åºä¸­ï¼ˆé‡æ–°ï¼‰å¼•å…¥ä¸€ä¸ªåç§°å’Œè¶³å¤Ÿçš„ç±»å‹ä¿¡æ¯ï¼Œå®šä¹‰å¼•å…¥ä¸€ä¸ªåç§°å¹¶åˆ›å»ºå®ƒæ‰€éœ€çš„å…¨éƒ¨ä¿¡æ¯ã€‚åç§°è¡¨ç¤ºå˜é‡ï¼Œå®šä¹‰ä¼šæ˜¾å¼åˆ›å»ºå­˜å‚¨å¹¶è¿›è¡Œåˆå§‹åŒ–ã€‚å‡½æ•°å®šä¹‰ç”±ç­¾åå’Œå‡½æ•°ä½“ç»„æˆã€‚ç±»å®šä¹‰ç”±ç±»åå’Œåˆ—å‡ºçš„æ‰€æœ‰ç±»æˆå‘˜å’Œæˆå‘˜å‡½æ•°ç»„æˆã€‚ 

ä¸€ä¸ªç¨‹åºåŒ…æ‹¬ä¸€ä¸ªæˆ–å¤šä¸ªç¿»è¯‘å•å…ƒã€‚ä¸€ä¸ªç¿»è¯‘å•å…ƒç”±ä¸€ä¸ªå®ç°æ–‡ä»¶åŠå…¶ç›´æ¥æˆ–é—´æ¥åŒ…å«çš„æ‰€æœ‰æ ‡å¤´ç»„æˆã€‚ å®ç°æ–‡ä»¶é€šå¸¸å…·æœ‰ `.cpp` æˆ– `.cxx`ã€‚å¤´æ–‡ä»¶é€šå¸¸å…·æœ‰ `.h` æˆ– `.hpp`ã€‚ æ¯ä¸ªç¿»è¯‘å•å…ƒç”±ç¼–è¯‘å™¨ç‹¬ç«‹ç¼–è¯‘ã€‚ç¼–è¯‘å®Œæˆåï¼Œé“¾æ¥å™¨ä¼šå°†ç¼–è¯‘åçš„ç¿»è¯‘å•å…ƒåˆå¹¶åˆ°å•ä¸ªç¨‹åºä¸­ã€‚ODR è§„åˆ™çš„å†²çªé€šå¸¸æ˜¾ç¤ºä¸ºé“¾æ¥å™¨é”™è¯¯ã€‚åœ¨å¤šä¸ªç¿»è¯‘å•å…ƒä¸­å®šä¹‰åŒä¸€åç§°æ—¶ï¼Œå°†å‘ç”Ÿé“¾æ¥å™¨é”™è¯¯ã€‚

é€šå¸¸ï¼Œä½¿å˜é‡åœ¨å¤šä¸ªæ–‡ä»¶ä¸­å¯è§çš„æœ€ä½³æ–¹å¼æ˜¯åœ¨å¤´æ–‡ä»¶ä¸­å£°æ˜å®ƒã€‚ç„¶åï¼Œåœ¨éœ€è¦å£°æ˜çš„æ¯ä¸ª `.cpp` æ–‡ä»¶ä¸­æ·»åŠ ä¸€ä¸ª `#include` æŒ‡ä»¤ã€‚é€šè¿‡åœ¨æ ‡å¤´å†…å®¹å‘¨å›´æ·»åŠ  `include` é˜²å«ï¼Œå¯ä»¥ç¡®ä¿æ ‡å¤´å£°æ˜çš„åç§°å¯¹æ¯ä¸ªç¿»è¯‘å•å…ƒåªå£°æ˜ä¸€æ¬¡ã€‚ä»…åœ¨ä¸€ä¸ªå®ç°æ–‡ä»¶ä¸­å®šä¹‰åç§°ã€‚

```c++
#ifndef HEADER_H
#  define HEADER_H
   // ... code in header.h
#endif
```

åœ¨ C++20 ä¸­ï¼Œæ¨¡å—ä½œä¸ºå¤´æ–‡ä»¶çš„æ”¹è¿›æ›¿ä»£æ–¹æ³•å¼•å…¥ã€‚

```c++
import std.compat;
int main()
{
    printf("Hello World");
}
```

é“¾æ¥çš„ç±»å‹æŒ‡å®šå¯¹è±¡çš„åç§°æ˜¯ä»…åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­å¯è§ï¼Œè¿˜æ˜¯åœ¨æ‰€æœ‰æ–‡ä»¶ä¸­å¯è§ã€‚*Free* å‡½æ•°æ˜¯åœ¨å…¨å±€èŒƒå›´æˆ–å‘½åç©ºé—´èŒƒå›´å†…å®šä¹‰çš„å‡½æ•°ã€‚éå¸¸é‡å…¨å±€å˜é‡å’Œ *Free* å‡½æ•°é€šå¸¸å…·æœ‰å¤–éƒ¨é“¾æ¥ï¼›å®ƒä»¬åœ¨ç¨‹åºä¸­çš„ä»»ä½•ç¿»è¯‘å•å…ƒå†…å¯è§ã€‚å¯ä»¥å°†ä¸€ä¸ªå…¨å±€åç§°å£°æ˜ä¸º `static`ï¼›å£°æ˜ä¸º `const`, `constexpr`, `typedef`, å…¨å±€èŒƒå›´çš„ `static` å¯¹è±¡å…·æœ‰å†…éƒ¨é“¾æ¥ï¼›`extern` æ˜¾å¼å£°æ˜å¤–éƒ¨é“¾æ¥ã€‚

```c++
constexpr int czero = 0;
const struct S { int v; };
typedef struct S S;
static S Max{ INT_MAX };

extern const S Zero { 0 };  // å¤–éƒ¨é“¾æ¥
```

>---
#### åç§°æŸ¥æ‰¾

åç§°æŸ¥æ‰¾è§„åˆ™ç»Ÿä¸€åœ°åº”ç”¨äºæ‰€æœ‰åç§°ï¼ˆåŒ…æ‹¬ *typedef-names*ï¼Œ*namespace-names* å’Œ *class-names*ï¼‰ã€‚åç§°æŸ¥æ‰¾å°†åç§°çš„ä½¿ç”¨ä¸è¯¥åç§°çš„ä¸€ç»„å£°æ˜ç›¸å…³è”ã€‚å¦‚æœé€šè¿‡åç§°æŸ¥æ‰¾æ‰¾åˆ°çš„å£°æ˜éƒ½è¡¨ç¤ºå‡½æ•°æˆ–å‡½æ•°æ¨¡æ¿ï¼Œåˆ™è¿™äº›å£°æ˜è¢«æ„æˆå‡½æ•°çš„é‡è½½é›†ã€‚

å¦åˆ™ï¼Œå¦‚æœé€šè¿‡åç§°æŸ¥æ‰¾æ‰¾åˆ°çš„å£°æ˜ä¸è¡¨ç¤ºç›¸åŒçš„å®ä½“ï¼Œåˆ™å®ƒä»¬å…·æœ‰äºŒä¹‰æ€§ã€‚é‡è½½å†³ç­–å‘ç”Ÿåœ¨åç§°æŸ¥æ‰¾æˆåŠŸåã€‚åªæœ‰åœ¨åç§°æŸ¥æ‰¾å’Œå‡½æ•°é‡è½½å†³ç­–æˆåŠŸåï¼Œæ‰ä¼šè€ƒè™‘å¯è®¿é—®æ€§è§„åˆ™ã€‚åªæœ‰åœ¨åç§°æŸ¥æ‰¾ã€å‡½æ•°é‡è½½å†³ç­–å’Œè®¿é—®æ£€æŸ¥æˆåŠŸä¹‹åï¼Œæ‰èƒ½åœ¨è¿›ä¸€æ­¥çš„å¤„ç†ä¸­ä½¿ç”¨å£°æ˜å¼•å…¥çš„è¯­ä¹‰å±æ€§ã€‚

å¦‚æœä¸€ä¸ªå¯¹è±¡æœ‰å¤šä¸ª `T` ç±»å‹çš„åŸºç±»å­å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥æ˜ç¡®åœ°æ‰¾åˆ°åŸºç±» `T` ä¸­å®šä¹‰çš„é™æ€æˆå‘˜ã€åµŒå¥—ç±»å‹æˆ–æšä¸¾æ•°ã€‚ä¸¤ä¸ªåŸºç±»å­å¯¹è±¡å…±äº«å…¶å…¬å…±è™šåŸºç±»çš„éé™æ€æˆå‘˜å­å¯¹è±¡ã€‚

```c++
struct V {
    int v;
};
struct A {
    int a;
    static int s;
    enum { e };
};
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };
void f(D* pd) {
    pd->v++;       // OK, only one v (virtual)
    pd->s++;       // OK, only one s (static)
    int i = pd->e; // OK, only one e (enumerator)
    pd->a++;       // error: ambiguous: two as in D
   	pd->B::a++;	   // OK: B::a
	pd->C::a++;	   // OK: C::a
}
```

ä»æŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡çš„æŒ‡é’ˆæˆ–æŒ‡å®šæ´¾ç”Ÿç±»å¯¹è±¡çš„è¡¨è¾¾å¼åˆ°æŒ‡å‘å…¶åŸºç±»ä¹‹ä¸€çš„æŒ‡é’ˆæˆ–å¼•ç”¨çš„æ˜¾å¼æˆ–éšå¼è½¬æ¢ï¼Œåº”æ˜ç¡®å¼•ç”¨è¡¨ç¤ºåŸºç±»çš„å”¯ä¸€å¯¹è±¡ã€‚

```c++
struct V { };
struct A { };
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };
void g() {
    D d;
    B* pb = &d;
    A* pa = &d; // error: ambiguous: Câ€™s A or Bâ€™s A?
    V* pv = &d; // OK, only one V subobject
}
```


>---
#### Lvalues å’Œ Rvalues

æ¯ä¸ª C++ è¡¨è¾¾å¼éƒ½æœ‰ä¸€ä¸ªç±»å‹ï¼Œå±äºå€¼ç±»åˆ«ã€‚å€¼ç±»åˆ«æ˜¯ç¼–è¯‘å™¨åœ¨è¡¨è¾¾å¼è®¡ç®—æœŸé—´åˆ›å»ºã€å¤åˆ¶å’Œç§»åŠ¨ä¸´æ—¶å¯¹è±¡æ—¶å¿…é¡»éµå¾ªçš„è§„åˆ™çš„åŸºç¡€ã€‚
-*glvalue* æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒçš„è®¡ç®—å¯ä»¥ç¡®å®šå¯¹è±¡ã€ä½åŸŸæˆ–å‡½æ•°çš„æ ‡è¯†ã€‚
- *prvalue* æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒçš„è®¡ç®—å¯ä»¥åˆå§‹åŒ–å¯¹è±¡æˆ–ä½åŸŸï¼Œæˆ–è®¡ç®—è¿ç®—ç¬¦çš„æ“ä½œæ•°å€¼ï¼Œç”±å®ƒå‡ºç°çš„ä¸Šä¸‹æ–‡æ‰€æŒ‡å®šçš„ã€‚
- *xvalue* æ˜¯ä¸€ä¸ª *glvalue*ï¼Œè¡¨ç¤ºä¸€ä¸ªå¯¹è±¡æˆ–ä½åŸŸï¼Œè¯¥å¯¹è±¡æˆ–ä½åŸŸçš„èµ„æºå¯é‡å¤ä½¿ç”¨ï¼ˆé€šå¸¸æ˜¯å› ä¸ºå®ƒæ¥è¿‘å…¶ç”Ÿå­˜æœŸçš„æœ«å°¾ï¼‰ã€‚æŸäº›æ¶‰åŠ *rvalue* å¼•ç”¨çš„ç±»å‹çš„è¡¨è¾¾å¼ä¼šç”Ÿæˆ *xvalue*ï¼Œä¾‹å¦‚å¯¹è¿”å›ç±»å‹ä¸º *rvalue* å¼•ç”¨æˆ–å¼ºåˆ¶è½¬æ¢ä¸º *rvalue* å¼•ç”¨ç±»å‹çš„å‡½æ•°çš„è°ƒç”¨ã€‚
- *lvalue* ä¸ºé *xvalue* çš„ *glvalue*ã€‚
- *rvalue* æ˜¯ä¸€ä¸ª *prvalue* æˆ– *xvalue*ã€‚

> *å„ç±»åˆ«ä¹‹é—´çš„å…³ç³»*
<pre>
                          lvalue
                glvalue â€”|
   expression â€”|         xvalue
                rvalue  â€”|
                          prvalue  
</pre>

*lvalue* å…·æœ‰ç¨‹åºå¯è®¿é—®çš„åœ°å€ã€‚*lvalue* è¡¨è¾¾å¼åŒ…æ‹¬å˜é‡åç§°ï¼Œä¾‹å¦‚ `const` å˜é‡ã€æ•°ç»„å…ƒç´ ã€è¿”å› *lvalue* å¼•ç”¨çš„å‡½æ•°è°ƒç”¨ã€ä½åŸŸã€è”åˆå’Œç±»æˆå‘˜ã€‚

*prvalue* è¡¨è¾¾å¼æ²¡æœ‰å¯ä¾›ç¨‹åºè®¿é—®çš„åœ°å€ã€‚ä¾‹å¦‚ï¼Œ*prvalue* è¡¨è¾¾å¼åŒ…æ‹¬æ–‡æœ¬ã€å¯è¿”å›éå¼•ç”¨ç±»å‹çš„å‡½æ•°è°ƒç”¨ï¼Œä»¥åŠåœ¨è¡¨è¾¾å¼è®¡ç®—æœŸé—´åˆ›å»ºä¸”ç”±ç¼–è¯‘å™¨è®¿é—®çš„ä¸´æ—¶å¯¹è±¡ã€‚

*xvalue* è¡¨è¾¾å¼æœ‰ä¸€ä¸ªåœ°å€ï¼Œè¯¥åœ°å€ä¸å†å¯ä¾›ç¨‹åºè®¿é—®ï¼Œä½†å¯ç”¨äºåˆå§‹åŒ– *rvalue* å¼•ç”¨ï¼Œä»¥æä¾›å¯¹è¡¨è¾¾å¼çš„è®¿é—®ã€‚ä¾‹å¦‚ï¼Œå®ƒåŒ…æ‹¬å¯è¿”å› *rvalue* å¼•ç”¨çš„å‡½æ•°è°ƒç”¨ï¼Œä»¥åŠæ•°ç»„ä¸‹æ ‡ã€æˆå‘˜å’ŒæŒ‡å‘å…¶ä¸­æ•°ç»„æˆ–å¯¹è±¡æ˜¯ *rvalue* å¼•ç”¨çš„æˆå‘˜è¡¨è¾¾å¼çš„æŒ‡é’ˆã€‚

>---
#### å¯¹é½æ–¹å¼

C++ çš„ä½çº§åŠŸèƒ½ä¹‹ä¸€æ˜¯èƒ½å¤ŸæŒ‡å®šå†…å­˜ä¸­å¯¹è±¡çš„ç²¾ç¡®å¯¹é½æ–¹å¼ï¼Œä»¥æœ€å¤§é™åº¦åˆ©ç”¨ç‰¹å®šçš„ç¡¬ä»¶ä½“ç³»ç»“æ„ã€‚é»˜è®¤æƒ…å†µä¸‹ã€ç¼–è¯‘å™¨ä¼šæ ¹æ®ç±»æˆ–ç»“æ„æˆå‘˜çš„å€¼çš„å¤§å°è¿›è¡Œå¯¹é½ï¼š`bool` å’Œ `char` åœ¨ 1 å­—èŠ‚è¾¹ç•Œä¸Šå¯¹é½ï¼Œ`short` åœ¨ 2 å­—èŠ‚è¾¹ç•Œä¸Šå¯¹é½ï¼Œ`int`ã€`long` å’Œ `float` åœ¨ 4 å­—èŠ‚è¾¹ç•Œä¸Šå¯¹é½ï¼Œ`long long`ã€`double` å’Œ `long double` åœ¨ 8 å­—èŠ‚è¾¹ç•Œä¸Šå¯¹é½ã€‚

å¯ä»¥ä½¿ç”¨ `alignof` å’Œ `alignas` æ¥è·å–æˆ–æŒ‡å®šå¯¹è±¡çš„å¯¹é½æ–¹å¼ï¼›å¯¹é½æ–¹å¼æ˜¯å†…å­˜åœ°å€çš„ä¸€ä¸ªå±æ€§ï¼Œè¡¨ç¤ºä¸ºæ•°å­—åœ°å€å¯¹ 2 çš„å¹‚æ¬¡æ–¹å–æ¨¡ï¼Œä¾‹å¦‚ï¼Œåœ°å€ 0x0001103F å¯¹ 4 å–æ¨¡ä¸º 3ï¼Œè¯¥åœ°å€å¯¹é½åˆ° 4n+3ã€‚

CPU æ‰§è¡Œä½œç”¨äºå†…å­˜ä¸­æ‰€å­˜å‚¨æ•°æ®çš„æŒ‡ä»¤ã€‚æ•°æ®åœ¨å†…å­˜ä¸­ç”¨åœ°å€æ ‡è¯†ã€‚å•ä¸ªåŸºå‡†ä¹Ÿå…·æœ‰å¤§å°ã€‚å¦‚æœä¸€ä¸ªåŸºå‡†çš„åœ°å€å¯¹é½åˆ°å…¶å¤§å°ï¼Œåˆ™ç§°å®ƒä¸ºè‡ªç„¶å¯¹é½ã€‚

ä¸€èˆ¬è€Œè¨€ï¼Œç¼–è¯‘å™¨ä¼šä»¥è‡ªç„¶å¯¹é½ç»“æ„çš„æ¯ä¸€ä¸ªå…ƒç´ çš„æ–¹å¼å¡«å……ç»“æ„ã€‚ä¾‹å¦‚ï¼š

```c++
struct x_
{
   char a;     // 1 byte
   // char _pad0[3];     // padding to put 'b' on 4-byte boundary
   int b;      // 4 bytes
   short c;    // 2 bytes
   char d;     // 1 byte
   // char _pad1[1];    // padding to make sizeof(x_) multiple of 4
} bar[3];
```

>---
#### å¸ƒå±€ä¸ POD

å¸ƒå±€æ˜¯æŒ‡ç±»ã€ç»“æ„æˆ–è”åˆç±»å‹å¯¹è±¡çš„æˆå‘˜åœ¨å†…å­˜ä¸­çš„æ’åˆ—æ–¹å¼ã€‚å¸ƒå±€ä¸€èˆ¬ç”±è¯­è¨€è§„èŒƒæ˜ç¡®å®šä¹‰ã€‚

å¦‚æœå½“ç±»æˆ–ç»“æ„åŒ…å«æŸäº› C++ è¯­è¨€åŠŸèƒ½ï¼ˆå¦‚è™šæ‹ŸåŸºç±»ã€è™šæ‹Ÿå‡½æ•°ã€å…·æœ‰ä¸åŒè®¿é—®æ§åˆ¶çš„æˆå‘˜ï¼‰æ—¶ï¼Œç¼–è¯‘å™¨å¯ä»¥è‡ªç”±é€‰æ‹©å¸ƒå±€ã€‚è¯¥å¸ƒå±€å¯èƒ½ä¼šå› ç¼–è¯‘å™¨çš„ä¼˜åŒ–æœ‰æ‰€ä¸åŒï¼Œå¯¹è±¡ç”šè‡³å¯èƒ½ä¸ä¼šå ç”¨è¿ç»­å†…å­˜åŒºåŸŸã€‚ä¾‹å¦‚ï¼Œå¦‚æœæŸä¸ªç±»å…·æœ‰è™šæ‹Ÿå‡½æ•°ï¼Œåˆ™è¯¥ç±»çš„æ‰€æœ‰å®ä¾‹å¯èƒ½ä¼šå…±äº«å•ä¸ªè™šæ‹Ÿå‡½æ•°è¡¨ã€‚ 

ç”±äºå¸ƒå±€æœªå®šä¹‰ï¼Œå› æ­¤æ— æ³•å°†å…¶ä¼ é€’åˆ°ä½¿ç”¨å…¶ä»–è¯­è¨€ï¼ˆä¾‹å¦‚ Cï¼‰ç¼–å†™çš„ç¨‹åºï¼Œå¹¶ä¸”ç”±äºå®ƒä»¬å¯èƒ½æ˜¯éè¿ç»­çš„ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨å¿«é€Ÿä½çº§å‡½æ•°ï¼ˆä¾‹å¦‚ `memcopy`ï¼‰å¯¹å…¶è¿›è¡Œå¯é å¤åˆ¶ï¼Œæˆ–è€…é€šè¿‡ç½‘ç»œå¯¹å…¶è¿›è¡Œåºåˆ—åŒ–ã€‚

> *Trivial* ç±»å‹

å½“ C++ ä¸­çš„ç±»æˆ–ç»“æ„å…·æœ‰ç¼–è¯‘å™¨æä¾›çš„æˆ–æ˜¾å¼é»˜è®¤è®¾ç½®çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°æ—¶ï¼Œè¯¥ç±»æˆ–ç»“æ„ä¸ºæ™®é€šç±»å‹ã€‚å®ƒå ç”¨è¿ç»­å†…å­˜åŒºåŸŸã€‚

æ™®é€šç±»å‹å…·æœ‰æ™®é€šé»˜è®¤æ„é€ å‡½æ•°ã€æ™®é€šå¤åˆ¶æ„é€ å‡½æ•°ã€æ™®é€šå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦å’Œæ™®é€šææ„å‡½æ•°ã€‚ åœ¨å„ç§æƒ…å†µä¸‹ï¼Œâ€œæ™®é€šâ€ æ„å‘³ç€æ„é€ å‡½æ•° / è¿ç®—ç¬¦ / ææ„å‡½æ•°å¹¶éç”¨æˆ·æä¾›ï¼Œå¹¶ä¸”å±äºå­˜åœ¨ä»¥ä¸‹æƒ…å†µçš„ç±»ï¼š
- æ²¡æœ‰è™šæ‹Ÿå‡½æ•°æˆ–è™šæ‹ŸåŸºç±»ï¼Œ
- æ²¡æœ‰å…·æœ‰ç›¸åº”éæ™®é€šæ„é€ å‡½æ•° / è¿ç®—ç¬¦ / ææ„å‡½æ•°çš„åŸºç±»
- æ²¡æœ‰å…·æœ‰ç›¸åº”éæ™®é€šæ„é€ å‡½æ•° / è¿ç®—ç¬¦ / ææ„å‡½æ•°çš„ç±»ç±»å‹çš„æ•°æ®æˆå‘˜

```c++
struct Trivial
{
   int i;
private:
   int j;
};

struct Trivial2
{
   int i;
   Trivial2(int a, int b) : i(a), j(b) {}
   Trivial2() = default;
private:
   int j;   // Different access control
};
```

> *standard-layout* ç±»å‹

å½“ç±»æˆ–ç»“æ„ä¸åŒ…å«æŸäº› C++ è¯­è¨€åŠŸèƒ½ï¼ˆä¾‹å¦‚æ— æ³•åœ¨ C è¯­è¨€ä¸­æ‰¾åˆ°çš„è™šæ‹Ÿå‡½æ•°ï¼‰ï¼Œå¹¶ä¸”æ‰€æœ‰æˆå‘˜éƒ½å…·æœ‰ç›¸åŒçš„è®¿é—®æ§åˆ¶æ—¶ï¼Œè¯¥ç±»æˆ–ç»“æ„ä¸ºæ ‡å‡†å¸ƒå±€ç±»å‹ã€‚å¯ä»¥åœ¨å†…å­˜ä¸­å¯¹å…¶è¿›è¡Œå¤åˆ¶ï¼Œå¯ä»¥ç”± C ç¨‹åºä½¿ç”¨ã€‚æ ‡å‡†å¸ƒå±€ç±»å‹å¯ä»¥å…·æœ‰ç”¨æˆ·å®šä¹‰çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°ã€‚æ ‡å‡†å¸ƒå±€ç±»å‹è¿˜å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š
- æ²¡æœ‰è™šæ‹Ÿå‡½æ•°æˆ–è™šæ‹ŸåŸºç±»
- æ‰€æœ‰éé™æ€æ•°æ®æˆå‘˜éƒ½å…·æœ‰ç›¸åŒçš„è®¿é—®æ§åˆ¶
- ç±»ç±»å‹çš„æ‰€æœ‰éé™æ€æˆå‘˜å‡ä¸ºæ ‡å‡†å¸ƒå±€
- æ‰€æœ‰åŸºç±»éƒ½ä¸ºæ ‡å‡†å¸ƒå±€
- æ²¡æœ‰ä¸ç¬¬ä¸€ä¸ªéé™æ€æ•°æ®æˆå‘˜ç±»å‹ç›¸åŒçš„åŸºç±»ã€‚
- æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ä¹‹ä¸€ï¼š
  - æœ€åº•å±‚æ´¾ç”Ÿç±»ä¸­æ²¡æœ‰éé™æ€æ•°æ®æˆå‘˜ï¼Œå¹¶ä¸”å…·æœ‰éé™æ€æ•°æ®æˆå‘˜çš„åŸºç±»ä¸è¶…è¿‡ä¸€ä¸ªï¼Œæˆ–è€…
  - ä¸å«éé™æ€æ•°æ®æˆå‘˜çš„åŸºç±»

```c++
struct SL
{
   // All members have same access:
   int i;
   int j;
   SL(int a, int b) : i(a), j(b) {} // User-defined constructor OK
};
```

`Base` æ˜¯æ ‡å‡†å¸ƒå±€ï¼Œ`Derived` ä¸æ˜¯æ ‡å‡†å¸ƒå±€ï¼Œå®ƒï¼ˆæœ€åº•å±‚æ´¾ç”Ÿç±»ï¼‰å’Œ `Base` éƒ½å…·æœ‰éé™æ€æ•°æ®æˆå‘˜ï¼š

```c++
struct Base
{
   int i;
   int j;
};

// std::is_standard_layout<Derived> == false!
struct Derived : public Base
{
   int x;
   int y;
};
```

`Derived` æ˜¯æ ‡å‡†å¸ƒå±€ï¼Œå› ä¸º `Base` æ²¡æœ‰éé™æ€æ•°æ®æˆå‘˜ï¼š

```c++
struct Base
{
   void Foo() {}
};

// std::is_standard_layout<Derived> == true
struct Derived : public Base
{
   int x;
   int y;
};
```

å¦‚æœ `Base` å…·æœ‰æ•°æ®æˆå‘˜ï¼Œå¹¶ä¸” `Derived` ä»…å…·æœ‰æˆå‘˜å‡½æ•°ï¼Œåˆ™ `Derived` ä¹Ÿæ˜¯æ ‡å‡†å¸ƒå±€ã€‚

> POD ç±»å‹

å½“æŸä¸€ç±»æˆ–ç»“æ„åŒæ—¶ä¸ºæ™®é€šå’Œæ ‡å‡†å¸ƒå±€æ—¶ï¼Œè¯¥ç±»æˆ–ç»“æ„ä¸º PODï¼ˆç®€å•æ—§æ•°æ®ï¼‰ç±»å‹ã€‚ å› æ­¤ï¼ŒPOD ç±»å‹çš„å†…å­˜å¸ƒå±€æ˜¯è¿ç»­çš„ï¼Œå¹¶ä¸”æ¯ä¸ªæˆå‘˜çš„åœ°å€éƒ½æ¯”åœ¨å…¶ä¹‹å‰å£°æ˜çš„æˆå‘˜è¦é«˜ï¼Œä»¥ä¾¿å¯ä»¥å¯¹è¿™äº›ç±»å‹æ‰§è¡Œé€å­—èŠ‚å¤åˆ¶å’ŒäºŒè¿›åˆ¶ I/Oã€‚æ ‡é‡ç±»å‹ï¼ˆä¾‹å¦‚ `int`ï¼‰ä¹Ÿæ˜¯ POD ç±»å‹ã€‚

ä½œä¸ºç±»çš„ POD ç±»å‹åªèƒ½å…·æœ‰ä½œä¸ºéé™æ€æ•°æ®æˆå‘˜çš„ POD ç±»å‹ã€‚

> æ™®é€šã€æ ‡å‡†å¸ƒå±€å’Œ POD ç±»å‹ä¹‹é—´çš„åŒºåˆ«

```c++
#include <type_traits>
#include <iostream>

using namespace std;

struct B
{
protected:
   virtual void Foo() {}
};

// Neither trivial nor standard-layout
struct A : B
{
   int a;
   int b;
   void Foo() override {} // Virtual function
};

// Trivial but not standard-layout
struct C
{
   int a;
private:
   int b;   // Different access control
};

// Standard-layout but not trivial
struct D
{
   int a;
   int b;
   D() {} //User-defined constructor
};

struct POD
{
   int a;
   int b;
};

int main()
{
   cout << boolalpha;
   cout << "A is trivial is " << is_trivial<A>() << endl; // false
   cout << "A is standard-layout is " << is_standard_layout<A>() << endl;  // false

   cout << "C is trivial is " << is_trivial<C>() << endl; // true
   cout << "C is standard-layout is " << is_standard_layout<C>() << endl;  // false

   cout << "D is trivial is " << is_trivial<D>() << endl;  // false
   cout << "D is standard-layout is " << is_standard_layout<D>() << endl; // true

   cout << "POD is trivial is " << is_trivial<POD>() << endl; // true
   cout << "POD is standard-layout is " << is_standard_layout<POD>() << endl; // true

   return 0;
}
```

>---
#### æ–‡æœ¬ç±»å‹

æ–‡æœ¬ç±»å‹æ˜¯å¯åœ¨ç¼–è¯‘æ—¶ç¡®å®šå…¶å¸ƒå±€çš„ç±»å‹ã€‚ä»¥ä¸‹å‡ä¸ºæ–‡æœ¬ç±»å‹ï¼š
- `void`ã€æ ‡é‡ç±»å‹ã€å¼•ç”¨ï¼›
- `void`ã€æ ‡é‡ç±»å‹æˆ–å¼•ç”¨çš„æ•°ç»„
- å…·æœ‰æ™®é€šææ„å‡½æ•°ä»¥åŠä¸€ä¸ªæˆ–å¤šä¸ª `constexpr` æ„é€ å‡½æ•°ä¸”æ²¡æœ‰ç§»åŠ¨æˆ–å¤åˆ¶æ„é€ å‡½æ•°çš„ç±»ã€‚æ­¤å¤–ï¼Œå…¶æ‰€æœ‰éé™æ€æ•°æ®æˆå‘˜å’ŒåŸºç±»å¿…é¡»æ˜¯æ–‡æœ¬ç±»å‹ä¸”ä¸å¯å˜ã€‚

>---
#### å€¼ç±»å‹

é»˜è®¤æƒ…å†µä¸‹ï¼ŒC++ ç±»æ˜¯å€¼ç±»å‹ã€‚å¯ä»¥æŒ‡å®šä¸ºå¼•ç”¨ç±»å‹ï¼Œä»¥å¤šæ€è¡Œä¸ºæ”¯æŒé¢å‘å¯¹è±¡çš„ç¼–ç¨‹ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå€¼ç±»å‹å¯ä»¥å¤åˆ¶ï¼Œè¿™æ„å‘³ç€æ€»æ˜¯æœ‰ä¸€ä¸ªå¤åˆ¶æ„é€ å‡½æ•°å’Œä¸€ä¸ªå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ã€‚ 

å¯¹äºå¼•ç”¨ç±»å‹ï¼Œå°†ç±»è®¾ä¸ºä¸å¯å¤åˆ¶ï¼ˆç¦ç”¨å¤åˆ¶æ„é€ å‡½æ•°å’Œå¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ï¼‰ï¼Œå¹¶ä½¿ç”¨æ”¯æŒå…¶é¢„æœŸå¤šæ€æ€§çš„è™šæ‹Ÿææ„å‡½æ•°ã€‚ 

```c++
class MyRefType {
private:
    MyRefType & operator=(const MyRefType &);
    MyRefType(const MyRefType &);
public:
    MyRefType () {}
};

int main()
{
    MyRefType Data1, Data2;
    // ...
    Data1 = Data2;
    // error: 'MyRefType::operator =' : cannot access private member declared in class 'MyRefType'
}
```

> *å€¼ç±»å‹å’Œç§»åŠ¨æ•ˆç‡*

ç±»å¿…é¡»é€šè¿‡åœ¨ç±»å®šä¹‰ä¸­å£°æ˜ç§»åŠ¨èµ‹å€¼å’Œç§»åŠ¨æ„é€ å‡½æ•°ï¼Œä»¥æ”¯æŒå¤åˆ¶æ—¶çš„ç§»åŠ¨ä¼˜åŒ–ï¼Œé¿å…å¤åˆ¶åˆ†é…å¼€é”€ã€‚*Move* ä½¿ç”¨ `&&` *rvalue* å¼•ç”¨ï¼Œå®šä¹‰ç§»åŠ¨æ„é€ å‡½æ•°å’Œç§»åŠ¨èµ‹å€¼å‡½æ•°ã€‚

 <!-- TODO -->

>---
#### ç±»å‹è½¬æ¢ TODO

å½“è¡¨è¾¾å¼åŒ…å«ä¸åŒå†…ç½®ç±»å‹çš„æ“ä½œæ•°ä¸”ä¸å­˜åœ¨æ˜¾å¼å¼ºåˆ¶è½¬æ¢æ—¶ï¼Œç¼–è¯‘å™¨å°†ä½¿ç”¨å†…ç½®çš„ â€œæ ‡å‡†è½¬æ¢â€ æ¥è½¬æ¢å…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°ï¼Œä»è€Œä½¿ç±»å‹ç›¸åŒ¹é…ã€‚

åœ¨æ‰©å¤§è½¬æ¢ä¸­ï¼Œè¾ƒå°çš„å˜é‡ä¸­çš„å€¼å°†èµ‹ç»™è¾ƒå¤§çš„å˜é‡ï¼ŒåŒæ—¶ä¸ä¼šä¸¢å¤±æ•°æ®ã€‚æ‰©å¤§è½¬æ¢å§‹ç»ˆæ˜¯å®‰å…¨çš„ã€‚

æ”¶ç¼©è½¬æ¢å¯èƒ½å­˜åœ¨æ•°æ®ä¸¢å¤±ï¼Œéšå¼æ‰§è¡Œæ”¶ç¼©è½¬æ¢ç¼–è¯‘å™¨å‘å‡ºè­¦å‘Šï¼Œå¯ä»¥æ·»åŠ æ˜¾å¼å¼ºåˆ¶è½¬æ¢ã€‚ä»»ä½•ä»æµ®ç‚¹ç±»å‹åˆ°æ•´å‹çš„è½¬æ¢éƒ½æ˜¯æ”¶ç¼©è½¬æ¢ï¼Œå°æ•°éƒ¨åˆ†å°†ä¼šä¸¢å¼ƒã€‚

```c++
int i = INT_MAX + 1;   // warning:'+':integral constant overflow
wchar_t wch = 'A';     // OK
char c = wch;          
// warning:'initializing':conversion from 'wchar_t' to 'char', possible loss of data

unsigned char c2 = 0xfffe; 
// warning:'initializing':truncation from 'int' to 'unsigned char'

int j = 1.9f; 
// warning:'initializing':conversion from 'float' to 'int', possible loss of data

int k = 7.7; 
// warning:'initializing':conversion from 'double' to 'int', possible loss of data
```

æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´å‹ä¹‹é—´çš„éšå¼è½¬æ¢ï¼Œå…·æœ‰ç›¸åŒçš„ä½æ¨¡å¼å’Œä¸åŒçš„å€¼è§£é‡Šæ–¹å¼ã€‚ç¼–è¯‘å™¨ä¸ä¼šå‘å‡ºæœ‰å…³æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´å‹ä¹‹é—´çš„éšå¼è½¬æ¢çš„è­¦å‘Šã€‚

åˆ©ç”¨å¼ºåˆ¶è½¬æ¢è¿ç®—ï¼Œå¯ä»¥æŒ‡ç¤ºç¼–è¯‘å™¨å°†ä¸€ç§ç±»å‹çš„å€¼è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚ä¾‹å¦‚ä»æŒ‡å‘æ´¾ç”Ÿç±»çš„æŒ‡é’ˆåˆ°æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆçš„å¼ºåˆ¶è½¬æ¢ã€‚è¿˜æœ‰ä¸€ç§ä½¿ç”¨æƒ…å†µæ˜¯å¼ºåˆ¶è½¬æ¢æ”¹å˜å˜é‡çš„å¸¸é‡æ€§ä»¥å°†å…¶ä¼ é€’ç»™éœ€è¦éå¸¸é‡å‚æ•°çš„å‡½æ•°ã€‚

```c++
(int) x;  // old-style cast, old-style syntax
int(x);   // old-style cast, functional syntax

static_cast<T>(v)
dynamic_cast<Derived>(base)
const_cast<constT>(noconstv)
reinterpret_cast<T>(v)
```

>---

---
### å†…ç½®ç±»å‹

å†…ç½®ç±»å‹ï¼ˆä¹Ÿç§°åŸºæœ¬ç±»å‹ï¼‰ç”± C++ è¯­è¨€æ ‡å‡†æŒ‡å®šï¼Œæœªåœ¨ä»»ä½•å¤´æ–‡ä»¶ä¸­å®šä¹‰ã€‚åˆ†ä¸ºä¸‰ä¸ªä¸»è¦ç±»åˆ«ï¼šæ•´å‹ã€æµ®ç‚¹å’Œ `void`ã€‚

>---
#### Void 

`void` æè¿°å€¼çš„ç©ºé›†ã€‚æ²¡æœ‰ `void` ç±»å‹çš„å˜é‡ï¼Œä¸»è¦ç”¨äºæ— è¿”å›å€¼å‡½æ•°ï¼Œæˆ–å£°æ˜éç±»å‹åŒ–çš„ä¸€èˆ¬æŒ‡é’ˆã€‚ä»»ä½•è¡¨è¾¾å¼éƒ½å¯ä»¥æ˜¾ç¤ºæˆ–å¼ºåˆ¶è½¬æ¢ä¸ºç±»å‹ `void`ï¼Œä»…é™äºï¼š
- è¡¨è¾¾å¼è¯­å¥ï¼›
- é¡ºåºè¿ç®—ç¬¦çš„å·¦æ“ä½œæ•°ï¼›
- æ¡ä»¶è¿ç®—ç¬¦çš„ç¬¬äºŒä¸ªæˆ–ç¬¬ä¸‰ä¸ªæ“ä½œæ•°ï¼›

`void*` æŒ‡é’ˆå¯ä»¥æŒ‡å‘ä»»ä½•æœª `const` æˆ– `volatile` å£°æ˜çš„å˜é‡ã€‚æ— æ³•å¯¹ `void*` å–æ¶ˆå¼•ç”¨ï¼Œåªèƒ½å¼ºåˆ¶è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚`void*` æŒ‡é’ˆå¯ä»¥æŒ‡å‘ *Free* å‡½æ•°ï¼ˆéç±»æˆå‘˜å‡½æ•°ï¼‰æˆ–é™æ€æˆå‘˜å‡½æ•°ï¼Œä¸èƒ½æŒ‡å‘éé™æ€æˆå‘˜å‡½æ•°ã€‚

```c++
void return_nothing()
{
   // A void function without value returned
}

// void vobject;   // ERROR
void *pv;       // okay
int *pint; int i;
int main()
{
   pv = &i;
   // Cast is optional in C, required in C++
   pint = (int *)pv;
}
```

>---
#### std::nullptr_t

`nullptr` è¡¨ç¤ºä¸º `std::nullptr_t` çš„ç©ºæŒ‡é’ˆå¸¸é‡ï¼Œå¯è½¬æ¢ä¸ºä»»ä½•åŸå§‹æŒ‡é’ˆç±»å‹ã€‚é¿å…å°† NULL æˆ–é›¶ (0) ç”¨ä½œç©ºæŒ‡é’ˆå¸¸é‡

ä¾‹å¦‚ï¼Œå¯¹äºç»™å®š `func(std::pair<const char *, double>)`ï¼Œè°ƒç”¨ `func(std::make_pair(NULL, 3.14))` ä¼šå¯¼è‡´ç¼–è¯‘å™¨é”™è¯¯ã€‚å® `NULL` å°†æ‰©å±•åˆ° 0ï¼Œè°ƒç”¨ `std::make_pair(0, 3.14)` å°†è¿”å› `std::pair<int, double>`ï¼Œæ­¤ä¸å¯è½¬æ¢ä¸º `std::pair<const char *, double>` å‚æ•°ç±»å‹ã€‚

```c++
using namespace std;
void func(std::pair<const char*, double>) {
	cout << "call pair<const char*, double>\n";
}
void func(std::pair<int, double>) {
	cout << "call pair<int, double>\n";
}

int main() {
	func(std::make_pair(NULL, 3.14));
	func(std::make_pair(nullptr, 3.14));
	// call pair<int, double>
	// call pair<const char*, double>
}
```

>---
#### Boolean

`bool` ç±»å‹å…·æœ‰å€¼ `true` å’Œ `false`ï¼›æ¡ä»¶è¡¨è¾¾å¼å…·æœ‰ç±»å‹ `bool`ï¼›`bool` ç±»å‹å‚ä¸äº†é»˜è®¤æ•´å‹æå‡ã€‚

```c++
bool a = 1;  // true
bool b = 0;  // false
int ia = a;  // 1
int ib = b;  // 0
auto c = a + b;  // int; 1
```

>---
#### Character

`char` ç±»å‹æ˜¯ä¸€ç§å­—ç¬¦è¡¨ç¤ºç±»å‹ï¼Œå¯æœ‰æ•ˆåœ°å¯¹åŸºæœ¬æ‰§è¡Œå­—ç¬¦é›†çš„æˆå‘˜è¿›è¡Œç¼–ç ã€‚C++ ç¼–è¯‘å™¨å°† `char`, `signed char` å’Œ `unsigned char` ç±»å‹çš„å˜é‡è§†ä¸ºä¸åŒç±»å‹ã€‚

`wchar_t` ç±»å‹çš„å˜é‡æ˜¯å®½å­—ç¬¦æˆ–å¤šå­—èŠ‚å­—ç¬¦ç±»å‹ã€‚åœ¨å­—ç¬¦æˆ–å­—ç¬¦ä¸²æ–‡æœ¬å‰ä½¿ç”¨ L å‰ç¼€å¯æŒ‡å®šå®½å­—ç¬¦ç±»å‹ã€‚

`char8_t` ç±»å‹ç”¨äº UTF-8 å­—ç¬¦è¡¨ç¤ºå½¢å¼ã€‚`char16_t` ç±»å‹ç”¨äº UTF-16 å­—ç¬¦è¡¨ç¤ºå½¢å¼ã€‚`char32_t` ç±»å‹ç”¨äº UTF-32 å­—ç¬¦è¡¨ç¤ºå½¢å¼ã€‚ 

```c++
char       c = 'A';
int       mc = 'abcd';
char8_t   c8 = u8"A";
char16_t c16 = u"A";
char32_t c32 = U"A";
wchar_t   wc = L'A';
```

>---
#### Floating-point

æµ®ç‚¹ç±»å‹ä½¿ç”¨ IEEE-754 è¡¨ç¤ºå½¢å¼ï¼Œåœ¨å„ç§æ•°é‡çº§ä¸Šæä¾›å°æ•°å€¼çš„è¿‘ä¼¼å€¼ã€‚C++ æ ‡å‡†ä¸­æœªæŒ‡å®šå†…ç½®æµ®ç‚¹ç±»å‹çš„ç»å¯¹å¤§å°ã€‚

```c
float   // åœ¨ C++ ä¸­æœ€å°çš„æµ®ç‚¹ç±»å‹ã€‚
double  // å¤§äºæˆ–ç­‰äº float ç±»å‹ä½†å°äºæˆ–ç­‰äº long double ç±»å‹
long double // å¤§äºæˆ–ç­‰äº doubleç±»å‹

float  f = 3.1415f;
double d = 3.1415;
long double ld = 3.1415L; 
```

>---
#### Integer

`int` ç±»å‹æ˜¯é»˜è®¤çš„åŸºæœ¬æ•´æ•°ç±»å‹ã€‚å®ƒå¯ä»¥è¡¨ç¤ºæŸä¸ªç‰¹å®šäºå®ç°çš„èŒƒå›´çš„æ‰€æœ‰æ•´æ•°ã€‚æœ‰ç¬¦å·æ•´æ•°å¯ä»¥åŒæ—¶ä¿å­˜æ­£å€¼å’Œè´Ÿå€¼ã€‚å¤§å°ä¿®é¥°ç¬¦æŒ‡å®šä½¿ç”¨çš„æ•´æ•°è¡¨ç¤ºå½¢å¼çš„å®½åº¦ï¼Œä¾‹å¦‚ `short`ï¼Œ`long`ï¼Œ`long long`ã€‚

```c++
1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)

int i = 1;
unsigned ui = 1u;
short s = 1;
long  l = 1L;
long long ll = 1LL;
unsigned long long ull = 1ull;
```

> å£°æ˜åŒä¹‰è¯

```c++
short == short int == signed short == signed short int
unsigned short == unsigned short int
int == signed == signed int
unsigned == unsigned int
long == long int == signed long == signed long int
unsigned long == unsigned long int
long long == long long int == signed long long == signed long long int
unsigned long long == unsigned long long int
```

>---
#### æ•°å€¼é™åˆ¶

`<limits.h>` å’Œ `<float.h>`å®šä¹‰äº†æ•°å­—é™åˆ¶æˆ–ç»™å®šç±»å‹çš„å˜é‡å¯åŒ…å«çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚å‚é˜… [C stdlib](https://github.com/JimryYchao/Learn-Programming-C#c-%E6%A0%87%E5%87%86%E5%BA%93c23)ã€‚



---
### å£°æ˜ä¸å®šä¹‰

ç¨‹åºçš„å®ä½“ï¼ˆ*Entity*ï¼‰åŒ…æ‹¬å€¼ã€å¯¹è±¡ã€å¼•ç”¨ã€ç»“æ„åŒ–ç»‘å®šã€å‡½æ•°ã€æšä¸¾å™¨ã€ç±»å‹ã€ç±»æˆå‘˜ã€ä½å­—æ®µã€æ¨¡æ¿ã€æ¨¡æ¿ä¸“ç”¨åŒ–ã€å‘½åç©ºé—´æˆ–åŒ…ã€‚

åç§°æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦ã€é‡è½½è¿ç®—ç¬¦æ ‡è¯†ç¬¦ã€ç”¨æˆ·å®šä¹‰æ–‡æœ¬è¿ç®—ç¬¦æ ‡è¯†ç¬¦ã€æˆ–è¿ç®—ç¬¦è½¬æ¢ç±»å‹æ ‡è¯†ç¬¦ã€‚å®ä½“çš„åç§°ç”±å£°æ˜å¼•å…¥ï¼Œå£°æ˜å¯ä»¥æ˜¯åç§°å£°æ˜ã€å—å£°æ˜æˆ–æˆå‘˜å£°æ˜ï¼›åˆå§‹åŒ–å£°æ˜ï¼›ç»“æ„åŒ–ç»‘å®šå£°æ˜ï¼›å‚æ•°ã€ç±»å‹å‚æ•°ã€ç±»å‹å®šä¹‰ç­‰ã€‚å®ä½“ `E` ç”±å£°æ˜ `E` å¼•å…¥çš„åç§°ï¼ˆå¦‚æœæœ‰ï¼‰æˆ–ç”±æŒ‡å®š `E` çš„å£°æ˜å¼•å…¥çš„ *typedef-name* è¡¨ç¤ºã€‚

å˜é‡æ˜¯é€šè¿‡å£°æ˜éé™æ€æ•°æ®æˆå‘˜æˆ–å¯¹è±¡ä»¥å¤–çš„å¼•ç”¨æ¥å¼•å…¥çš„ã€‚å˜é‡çš„åç§°ï¼ˆå¦‚æœæœ‰ï¼‰è¡¨ç¤ºå¼•ç”¨æˆ–å¯¹è±¡ã€‚å±€éƒ¨å®ä½“æ˜¯å…·æœ‰è‡ªåŠ¨å­˜å‚¨æœŸçš„å˜é‡ã€ç»“æ„åŒ–ç»‘å®šå¯¹åº”çš„å˜é‡ï¼Œæˆ– *this å¯¹è±¡ã€‚

å£°æ˜å¯ä»¥ï¼ˆé‡æ–°ï¼‰å°†ä¸€ä¸ªæˆ–å¤šä¸ªåç§°å’Œ / æˆ–å®ä½“å¼•å…¥ç¿»è¯‘å•å…ƒï¼Œå¹¶æŒ‡å®šè¿™äº›åç§°çš„è§£é‡Šå’Œè¯­ä¹‰å±æ€§ã€‚å¦‚æœå¯ä»¥ä»å®ä½“æˆ– *typedef-name* `X` ä¸­è·å–å¦ä¸€ä¸ª `X` å£°æ˜ï¼Œåˆ™è¯¥å®ä½“æˆ– *typedef-name* `X` çš„å£°æ˜æ˜¯ `X` çš„é‡æ–°å£°æ˜ã€‚

åœ¨å¯¹è±¡çš„å®šä¹‰ä¸­ï¼Œè¯¥å¯¹è±¡çš„ç±»å‹ä¸åº”è¯¥æ˜¯ä¸å®Œæ•´ç±»å‹ã€æŠ½è±¡ç±»ç±»å‹æˆ–å…¶æ•°ç»„ï¼ˆå¯èƒ½æ˜¯å¤šç»´çš„ï¼‰ã€‚

```c++
// å®šä¹‰å£°æ˜
int a;                         // defines a
extern const int c = 1;        // defines c
int f(int x) { return x + a; } // defines f and defines x
struct S
{
    int a;
    int b;
}; // defines S, S::a, and S::b
struct X
{                 // defines X
    int x;        // defines non-static data member x
    static int y; // declares static data member y
    X() : x(0) {} // defines a constructor of X
};
int X::y = 1; // defines X::y
enum
{
    up,
    down
}; // defines up and down
namespace N
{
    int d;
} // defines N and N::d
namespace N1 = N; // defines N1
X anX;            // defines anX

// ä»…å£°æ˜
extern int a;       // declares a
extern const int c; // declares c
int f(int);         // declares f
struct S;           // declares S
typedef int Int;    // declares Int
extern X anotherX;  // declares anotherX
using N::d;         // declares d
```

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šä¸ºä¸€äº›å®šä¹‰å£°æ˜éšå¼å®šä¹‰é»˜è®¤æ„é€ å‡½æ•°ã€èµ‹å€¼æ„é€ å‡½æ•°ã€ç§»åŠ¨æ„é€ å‡½æ•°ã€å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦ã€ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦æˆ–ç»ˆç»“å™¨ã€‚

```c++
struct C {
    std::string s; // std::string is the standard library class (23.4)
};
// å®ç°å°†éšå¼å®šä¹‰
struct C
{
    std::string s;
    C() : s() {}
    C(const C &x) : s(x.s) {}
    C(C &&x) : s(static_cast<std::string &&>(x.s)) {}
    // : s(std::move(x.s)) { }
    C &operator=(const C &x)
    {
        s = x.s;
        return *this;
    }
    C &operator=(C &&x)
    {
        s = static_cast<std::string &&>(x.s);
        return *this;
    }
    // { s = std::move(x.s); return *this; }
    ~C() {}
};
```

> One-definition rule 

å•ä¸€å®šä¹‰åŸåˆ™ï¼ŒODRï¼šä»»ä½•ç¿»è¯‘å•å…ƒä¸å¾—åŒ…å«ä»»ä½•å¯å®šä¹‰é¡¹çš„ä¸€ä¸ªä»¥ä¸Šå®šä¹‰ã€‚å¯å®šä¹‰é¡¹åŒ…æ‹¬ï¼šç±»ç±»å‹ã€æšä¸¾ç±»å‹ã€å‡½æ•°ã€å˜é‡ã€æ¨¡æ¿åŒ–å®ä½“ã€å‚æ•°çš„é»˜è®¤å®å‚ã€é»˜è®¤æ¨¡æ¿å®å‚ã€‚

>---
#### å­˜å‚¨ç±»è¯´æ˜ç¬¦

```c++
static
extern
register   // å¼ƒç”¨
thread_local
mutable
```

å˜é‡å£°æ˜ä¸Šä¸‹æ–‡ä¸­çš„å­˜å‚¨ç±»è¯´æ˜ç¬¦æ˜¯ç®¡ç†å¯¹è±¡çš„ç”Ÿå­˜æœŸã€é“¾æ¥å’Œå†…å­˜ä½ç½®çš„ç±»å‹è¯´æ˜ç¬¦ã€‚ç»™å®šå¯¹è±¡åªèƒ½æœ‰ä¸€ä¸ªå­˜å‚¨ç±»ã€‚å—ä¸­å®šä¹‰ä¸€èˆ¬å…·æœ‰è‡ªåŠ¨å­˜å‚¨æœŸï¼Œé™¤éä½¿ç”¨ `extern`ã€`static` æˆ– `thread_local`ã€‚è‡ªåŠ¨å­˜å‚¨æœŸå¯¹è±¡å’Œå˜é‡ä¸å…·æœ‰é“¾æ¥ï¼Œå—å¤–ä¸å¯è§ã€‚

`static` åœ¨å…¨å±€èŒƒå›´ã€å‘½åç©ºé—´èŒƒå›´å’Œç±»èŒƒå›´å£°æ˜å˜é‡å’Œå‡½æ•°ï¼Œä»¥ç»‘å®šå†…éƒ¨é“¾æ¥ï¼Œå˜é‡å…·æœ‰é™æ€å­˜å‚¨æœŸï¼Œç±»æ‰€æœ‰å®ä¾‹å…±äº«ç±» `static` å˜é‡å’Œå‡½æ•°ã€‚å±€éƒ¨èŒƒå›´çš„ `static` å±€éƒ¨å˜é‡å…·æœ‰é™æ€å­˜å‚¨æœŸï¼ˆç¨‹åºç»“æŸæ—¶é‡Šæ”¾ï¼‰ã€‚

```c++
// static1.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
void showstat( int curr ) {
   static int nStatic;    // Value of nStatic is retained
                          // between each function call
   nStatic += curr;
   cout << "nStatic is " << nStatic << endl;
}

int main() {
   for ( int i = 0; i < 5; i++ )
      showstat( i );  // 0,1,3,6,10
}
```

å£°æ˜ä¸º `extern` çš„å¯¹è±¡å’Œå˜é‡å°†åœ¨å¦ä¸€ä¸ªç¿»è¯‘å•å…ƒæˆ–åœ¨ä¸€ä¸ªå°é—­èŒƒå›´ä¸­å®šä¹‰çš„å¯¹è±¡å£°æ˜ä¸ºå…·æœ‰å¤–éƒ¨é“¾æ¥ã€‚`extern` å¯ä»¥åº”ç”¨äºå…¨å±€å˜é‡ã€å‡½æ•°ã€ç±»å‹æˆ–æ¨¡æ¿å£°æ˜ï¼Œæ ‡è¯†å¤–éƒ¨é“¾æ¥å±æ€§ã€‚
- åœ¨é `const` å…¨å±€å˜é‡å£°æ˜ä¸­ï¼Œ`extern` æŒ‡å®šå˜é‡æˆ–å‡½æ•°åœ¨å¦ä¸€ä¸ªç¿»è¯‘å•å…ƒä¸­å®šä¹‰ã€‚
- åœ¨ `const` å˜é‡ï¼ˆå†…éƒ¨é“¾æ¥ï¼‰å£°æ˜ä¸­ï¼Œå®ƒæŒ‡å®šå˜é‡å…·æœ‰å¤–éƒ¨é“¾æ¥ã€‚
- `extern "C"` æŒ‡å®šå‡½æ•°åœ¨åˆ«å¤„å®šä¹‰å¹¶ä½¿ç”¨ C è¯­è¨€è°ƒç”¨çº¦å®šã€‚`extern "C"` ä¿®é¥°ç¬¦ä¹Ÿå¯ä»¥åº”ç”¨äºå—ä¸­çš„å¤šä¸ªå‡½æ•°å£°æ˜ã€‚ä¸èƒ½é‡è½½å£°æ˜ä¸º `extern "C"` çš„å‡½æ•°ã€‚
- åœ¨æ¨¡æ¿å£°æ˜ä¸­ï¼Œ`extern` æŒ‡å®šæ¨¡æ¿å·²åœ¨å…¶ä»–ä½ç½®å®ä¾‹åŒ–ã€‚
- åœ¨å—èŒƒå›´å†…å£°æ˜çš„ `extern` å˜é‡å¼•ç”¨å¤–éƒ¨å˜é‡ï¼Œä¸”æ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼›ä»…å£°æ˜ã€‚

```c++
//fileA.cpp
int i = 42; // declaration and definition

//fileB.cpp
extern int i;  // declaration only. same as i in FileA
extern const int ci = 42;      // extern const definition
extern constexpr int cx = 10;  // extern constexpr definition

export extern "C" void F();
export extern "C++" void F(int);

int main() {
    extern int i /* = 10; ERR */;  // å¼•ç”¨å£°æ˜å¤–éƒ¨å˜é‡ i
}
```

`register` å…³é”®å­—ä¸å†æ˜¯å—æ”¯æŒçš„å­˜å‚¨ç±»ã€‚å·²ä½œä¸ºä¿ç•™ï¼ŒC++ 17 ä½œä¸ºè­¦å‘Šã€‚

```c++
void foo(){
    register int val; // warning: 'register' is no longer a supported storage class
}
```


å£°æ˜ä¸º `thread_local` çš„å˜é‡ä»…å¯åœ¨å®ƒåœ¨å…¶ä¸Šåˆ›å»ºçš„çº¿ç¨‹ä¸Šå¯è®¿é—®ï¼Œå˜é‡å…·æœ‰çº¿ç¨‹å­˜å‚¨æ—¶é—´ï¼ˆTLSï¼‰ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰å…¶è‡ªå·±çš„å˜é‡å‰¯æœ¬ã€‚
- åªèƒ½åœ¨å…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„æ•°æ®é¡¹ä¸ŠæŒ‡å®š `thread_local`
- `thread_local` è¯´æ˜ç¬¦å¯ä»¥ä¸ `static` æˆ– `extern` åˆå¹¶ã€‚
- `thread_local` ä¸èƒ½ç”¨äºå‡½æ•°å£°æ˜æˆ–å®šä¹‰ã€‚
- ä¸å»ºè®®å°† `thread_local` å˜é‡ä¸ `std::launch::async` ä¸€èµ·ä½¿ç”¨ã€‚


```c++
thread_local float f = 42.0; // Global namespace. Not implicitly static. extern TLS
struct S // cannot be applied to type definition
{
    thread_local int i; // Illegal. The member must be static.
    thread_local static char buf[10]; // OK; static TLS
};

void DoSomething()
{
    // Apply thread_local to a local variable.
    // Implicitly "thread_local static S my_struct".
    thread_local S my_struct;  // static TLS
}
```

`mutable` åªåº”ç”¨äºç±»çš„éé™æ€ã€éå¸¸é‡å’Œéå¼•ç”¨æ•°æ®æˆå‘˜ã€‚å¦‚æœæŸä¸ªæ•°æ®æˆå‘˜è¢«å£°æ˜ä¸º `mutable`ï¼Œåˆ™ä» `const` æˆå‘˜å‡½æ•°ä¸ºæ­¤æ•°æ®æˆå‘˜èµ‹å€¼æ˜¯åˆæ³•çš„ã€‚

```c++
// mutable.cpp
class X
{
public:
    bool GetFlag() const
    {
        m_accessCount++;  // allowed
        m_flag = true;    // illegal: assignment of member 'X::m_flag' in read-only object
        return m_flag;
    }
private:
    bool m_flag;
    mutable int m_accessCount;
};
```


>---
#### alignas å¯¹é½

å¯ä»¥å¯¹ `struct`ã€`class`ã€`union` æˆ–å˜é‡å£°æ˜ä½¿ç”¨ `alignas(N)` è¯´æ˜ç¬¦ï¼Œ`N = 0, 2^(1,2,4,8,16,...)`ã€‚ä¸èƒ½å°äºåº”ç”¨äºå®ƒçš„ç±»å‹çš„è‡ªç„¶å¯¹é½æ–¹å¼ã€‚ç”¨æˆ·å®šä¹‰çš„ç±»å‹çš„å£°æ˜å’Œå®šä¹‰å¿…é¡»å…·æœ‰ç›¸åŒçš„å¯¹é½å€¼ã€‚

```c++
struct alignas(8) S1     // 8
{
    int x;
};
class alignas(16) C{}    // 16
struct alignas(double) S2  // double
{
    int x;
};

template <typename... Ts> // max{ TS... }
class alignas(Ts...) C2
{
    char c;
};
alignof(C2<int, float, double>) == 8;
```

>---
#### auto ç±»å‹æ¨æ–­

`auto` æŒ‡ç¤ºç¼–è¯‘å™¨ä½¿ç”¨å·²å£°æ˜å˜é‡çš„åˆå§‹åŒ–è¡¨è¾¾å¼æˆ– lambda è¡¨è¾¾å¼å‚æ•°æ¥æ¨å¯¼å…¶ç±»å‹ã€‚`auto` è¢«è§†ä¸ºç±»å‹çš„å ä½ç¬¦ï¼Œä½†å®ƒæœ¬èº«ä¸æ˜¯ç±»å‹ã€‚å› æ­¤ä¸èƒ½ç”¨äºå¼ºåˆ¶è½¬æ¢æˆ–è¿ç®—ç¬¦ï¼Œå¦‚ `sizeof` å’Œï¼ˆç”¨äº C++/CLIï¼‰`typeid`ã€‚å˜é‡å¯ä»¥æŒ‡å®š `const`ã€`volatile` ç­‰è¯´æ˜ç¬¦å’Œå£°æ˜ç¬¦ã€æŒ‡é’ˆã€å³å€¼å¼•ç”¨ã€‚

ä½¿ç”¨ `auto` ä¼šåˆ é™¤å¼•ç”¨ã€`const` é™å®šç¬¦å’Œ `volatile` é™å®šç¬¦ã€‚

```c++
auto PI = 3.141592653;        // double
auto lambda = [](int a, int b){ 
	return a + b; 
};  // int lambda(int, int)

auto const V = 10010;	      // int
auto static SV(V);			  // static int; SV = V
auto extern const ECV = SV;   // extern const int
auto volatile* PSV(&SV);      // volatile int*
auto& reflv = V;			  // const int &
auto&& refrv(10086);		  // int &&
struct S {
	int x;
	int y;
};
auto A(S{ 1, 2 });

for (auto&& i = a; i >= 0; i--)
	cout << "Hello World\n";
```

>---
#### const ä¸å¯å˜

å½“å®ƒä¿®æ”¹æ•°æ®å£°æ˜æ—¶ï¼Œ`const` æŒ‡å®šå¯¹è±¡ã€å˜é‡ä¸å¯ä¿®æ”¹ã€‚`const T` å’Œ `T` æ˜¯ä¸åŒçš„æ•°æ®ç±»å‹ã€‚`const` å¸¸é‡å€¼å…·æœ‰å†…éƒ¨é“¾æ¥ã€‚å¯¹äºå£°æ˜ä¸º `const` çš„å¯¹è±¡ï¼Œåªèƒ½è°ƒç”¨å¸¸é‡æˆå‘˜å‡½æ•°ã€‚

```c++
const int i = 10;
i++;   // ERROR
const * pi = &i;
extern const double d;    // å¤–éƒ¨é“¾æ¥
```

> `const` ä¸æŒ‡é’ˆ

```c++
const int i = 10;
int mi = 10;

int const* pi = &mi;   // æŒ‡å‘å¸¸é‡æ•´æ•°çš„æŒ‡é’ˆ
const int* pi2 = pi;

int* const cpi = &mi;  // æŒ‡å‘æ•´æ•°çš„å¸¸é‡æŒ‡é’ˆ
const int* cpi2 = &mi;
*cpi = 100;   // æŒ‡é’ˆä¸å¯ä¿®æ”¹ï¼Œå€¼å¯ä¿®æ”¹

const int* const cpci = &i;   // æŒ‡å‘å¸¸é‡æ•´æ•°çš„å¸¸é‡æŒ‡é’ˆ
const int* const cpci2 = &mi; // æŒ‡å‘æ•´æ•°çš„å¸¸é‡æŒ‡é’ˆï¼Œä½†æ— æ³•ä»æŒ‡é’ˆä¿®æ”¹æ•°æ®
```

> `const` æˆå‘˜å‡½æ•°

```c++
rt-type funcName(params) const {}  
```

å£°æ˜ `const` æˆå‘˜å‡½æ•°å°†æŒ‡å®šä¸ºä¸€ä¸ª â€œåªè¯»â€ å‡½æ•°ï¼Œå®ƒä¸ä¼šä¿®æ”¹ä¸ºå…¶è°ƒç”¨è¯¥å‡½æ•°çš„å¯¹è±¡ã€‚å¸¸é‡æˆå‘˜å‡½æ•°ä¸èƒ½ä¿®æ”¹ä»»ä½•éé™æ€æ•°æ®æˆå‘˜ï¼ˆé™¤äº† `mutable`ï¼‰æˆ–è°ƒç”¨ä»»ä½•éå¸¸é‡æˆå‘˜å‡½æ•°ã€‚ 

```c++
class Date
{
public:
	Date(int mn, int dy, int yr);
	int getMonth() const;     // A read-only function
	void setMonth(int mn);   // A write function; can't be const
private:
	int month;
};

int Date::getMonth() const 
{
	return month;        // Doesn't modify anything
}
void Date::setMonth(int mn)
{
	month = mn;          // Modifies data member
}
int main()
{
	Date MyDate(7, 4, 1998);
	const Date BirthDate(1, 18, 1953);
	MyDate.setMonth(4);         // Okay
	auto _ = MyDate.getMonth(); // okay;
	BirthDate.getMonth();       // Okay
	BirthDate.setMonth(4);      // Error; const v call non-const-func
}
```

å¯ä»¥ä¸ºéå¸¸é‡å¯¹è±¡è°ƒç”¨å¸¸é‡æˆ–éå¸¸é‡æˆå‘˜å‡½æ•°ã€‚å¯ä»¥ä½¿ç”¨ `const` å…³é”®å­—é‡è½½æˆå‘˜å‡½æ•°ä½¿å¾—å¯ä»¥å¯¹å¸¸é‡å’Œéå¸¸é‡å¯¹è±¡è°ƒç”¨ä¸åŒç‰ˆæœ¬çš„å‡½æ•°ã€‚å¯¹äºå£°æ˜ä¸º `const` çš„å¯¹è±¡ï¼Œåªèƒ½è°ƒç”¨å¸¸é‡æˆå‘˜å‡½æ•°ã€‚

```c++
class Data {
public:
	void MulData(int data) const {
		this->data = data;
	}
	void MulData(int data) {
		this->data = data;
	}
private :
	mutable int data;  // can motify in const-func
};

int main() {
	const auto cd = Data();
	auto d = Data();
	cd.MulData(1);  // call Muldata() const
	d.MulData(1);   // call Muldata()
}
```

>---
#### constexpr å¸¸é‡è¡¨è¾¾å¼

ä¸ `const` ä¸€æ ·ï¼Œ`constexpr` å¯ä»¥åº”ç”¨äºå˜é‡ï¼›`constexpr` ä¹Ÿå¯ä»¥åº”ç”¨äºå‡½æ•°å’Œç±» constructorï¼ˆæ„é€ å‡½æ•°ï¼‰ã€‚`constexpr` æŒ‡ç¤ºå€¼æˆ–è¿”å›å€¼æ˜¯ constantï¼ˆå¸¸æ•°ï¼‰ã€‚å¦‚æœå¯èƒ½ï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶è¿›è¡Œè®¡ç®—ã€‚C++14 æ ‡å‡†è¦æ±‚å¸¸é‡è¡¨è¾¾å¼ä¸­æ¶‰åŠçš„ç±»å‹ä¸ºæ–‡æœ¬ç±»å‹ã€‚

`constexpr` å˜é‡å¿…é¡»åœ¨ç¼–è¯‘æ—¶è¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœåˆå§‹åŒ–ç”±æ„é€ å‡½æ•°æ‰§è¡Œï¼Œåˆ™å¿…é¡»å°†æ„é€ å‡½æ•°å£°æ˜ä¸º `constexpr`ã€‚å¼•ç”¨å¯ä»¥è¢«å£°æ˜ä¸º `constexpr`ï¼šå¼•ç”¨çš„å¯¹è±¡æ˜¯ç”±å¸¸é‡è¡¨è¾¾å¼åˆå§‹åŒ–ã€‚

`constexpr` å‡½æ•°æ˜¯åœ¨ä½¿ç”¨éœ€è¦å®ƒçš„ä»£ç æ—¶ï¼Œå¯åœ¨ç¼–è¯‘æ—¶è®¡ç®—å…¶è¿”å›å€¼çš„å‡½æ•°ã€‚å½“å…¶è‡ªå˜é‡ä¸º `constexpr` å€¼æ—¶ï¼Œå‡½æ•° `constexpr` å°†ç”Ÿæˆç¼–è¯‘æ—¶å¸¸é‡ã€‚ä»¥ä¸‹è§„åˆ™é€‚ç”¨äº `constexpr` å‡½æ•°ï¼š

- `constexpr` å‡½æ•°æˆ–æ„é€ å‡½æ•°é€šè¿‡éšå¼æ–¹å¼ `inline`ã€‚
- `constexpr` å˜é‡æˆ–å‡½æ•°å¿…é¡»è¿”å›æ–‡æœ¬ç±»å‹ã€‚
- `constexpr` å‡½æ•°å¯ä»¥é€’å½’ã€‚
- C++20 åå¯ä»¥å®šä¹‰ `virtual constexpr func`ï¼›å¸¦æœ‰è™šæ‹ŸåŸºç±»çš„ç±»ä¸èƒ½å£°æ˜ `constexpr ctor`ã€‚
- ä¸»ä½“å¯ä»¥å®šä¹‰ä¸º `= default` æˆ– `= delete`ã€‚
- å¯ä»¥å°†é `constexpr` æ¨¡æ¿çš„æ˜¾å¼ä¸“ç”¨åŒ–å£°æ˜ä¸º `constexpr`ã€‚`constexpr` æ¨¡æ¿çš„æ˜¾å¼ä¸“ç”¨åŒ–ä¸éœ€è¦åŒæ—¶æ˜¯ `constexpr`ã€‚
- å®ƒå¯èƒ½åŒ…å«å±€éƒ¨å˜é‡å£°æ˜ï¼Œä½†å¿…é¡»åˆå§‹åŒ–è¯¥å˜é‡ã€‚å®ƒå¿…é¡»æ˜¯æ–‡æœ¬ç±»å‹ï¼Œä¸èƒ½æ˜¯ `static` æˆ– `thread_local` çš„ã€‚å±€éƒ¨å˜é‡ä¸éœ€è¦æ˜¯ `const`ï¼Œå¹¶ä¸”å¯ä»¥å˜åŒ–ã€‚

```c++
template <typename T, int N>
void Iter(T arr[N]) {
	for (int i = 0; i < N; i++)
		cout << arr[i] << endl;
}

constexpr int arr[5] = { 1,3,4,5,6 };
Iter<const int, 5>(arr);

class B {
	constexpr B() = default;
	int constexpr foo() = delete;
};
```

>---
#### åˆå§‹å€¼è®¾å®šé¡¹

åˆå§‹å€¼è®¾å®šé¡¹å¯æŒ‡å®šå˜é‡çš„åˆå§‹å€¼ã€‚

```c++
struct Point {
    int x;
    int y;
};
class PointConsumer {
public:
    void set_point(Point p) {};
    void set_points(initializer_list<Point> my_list) {};
    // å‡½æ•°è¿”å›å€¼
    Point get_new_point(int x, int y) { return { x, y }; }
};

int main() {
    PointConsumer pc{};
    // å˜é‡
    int i = 3;
    Point p1{ 1, 2 };
    // å‡½æ•°å‚æ•°
    pc.set_point({});
    pc.set_point(Point{ 3,5 });
    pc.set_point({ 3, 4 });
    pc.set_points({ { 3, 4 }, { 5, 6 } });
}
```

é›¶åˆå§‹åŒ–æ˜¯æŒ‡å°†å˜é‡è®¾ç½®ä¸ºéšå¼è½¬æ¢ä¸ºè¯¥ç±»å‹çš„é›¶å€¼ã€‚

```c++
struct my_struct{
    int i;
    char c;
};

int i0;              // zero-initialized to 0
int main() {
    static float f1;  // zero-initialized to 0.000000000
    double d{};       // zero-initialized to 0.00000000000000000
    int* ptr{};       // initialized to nullptr
    char s_array[3]{'a', 'b'};  // the third char is initialized to '\0'
    int int_array[5] = { 8, 9, 10 };  // the fourth and fifth ints are initialized to 0
    my_struct a_struct{};   // i = 0, c = '\0'
}
```

ç±»ã€ç»“æ„å’Œè”åˆçš„é»˜è®¤åˆå§‹åŒ–æ˜¯å…·æœ‰é»˜è®¤æ„é€ å‡½æ•°çš„åˆå§‹åŒ–ã€‚ 

```c++
MyClass mc1;
MyClass* mc3 = new MyClass;
```

å¦‚æœå®šä¹‰æ ‡é‡å˜é‡æˆ–æ•°ç»„æ—¶ä¸ä½¿ç”¨åˆå§‹åŒ–è¡¨è¾¾å¼ï¼Œåˆ™è¿›è¡Œé»˜è®¤åˆå§‹åŒ–ã€‚å®ƒä»¬çš„å€¼æ˜¯ä¸ç¡®å®šçš„ã€‚é™æ€å˜é‡çš„å£°æ˜ä¸­æ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼Œåˆ™é›¶åˆå§‹åŒ–ã€‚

```c++
int i1;
float f;
char c;
int int_arr[3];
static int int1;       // 0
static char char1;     // '\0'
static bool bool1;     // false
static MyClass mc1;    // {0, '\0'}
```

å€¼åˆå§‹åŒ–ä½¿ç”¨ `{}` åˆå§‹åŒ–å·²å‘½åå€¼ã€`(), {}` åˆå§‹åŒ–åŒ¿åä¸´æ—¶å¯¹è±¡ã€`new T(), {}` åˆå§‹åŒ–å¯¹è±¡ã€‚ç›´æ¥åˆå§‹åŒ–ä½¿ç”¨ `{}, {values...}, (values...)`  æ˜¾å¼è°ƒç”¨æ„é€ å‡½æ•°åˆå§‹åŒ–ã€‚

```c++
class BaseClass {
private:
    int m_int;
};

int main() {
    BaseClass bc{};    // class is initialized
    BaseClass*  bc2 = new BaseClass();  // class is initialized, m_int value is 0
    int int_arr[3]{};  // value of all members is 0
    int a{};           // value of a is 0
    double b{};        // value of b is 0.00000000000000000
    
    double d(10);
    double d2{};
}
```

å¤åˆ¶åˆå§‹åŒ–æ˜¯æŒ‡ä½¿ç”¨ä¸€ä¸ªä¸åŒçš„å¯¹è±¡æ¥åˆå§‹åŒ–å¦ä¸€ä¸ªå¯¹è±¡ã€‚å¦‚æœç±»çš„å¤åˆ¶æ„é€ å‡½æ•°è¢«åˆ é™¤æˆ–ä¸å¯è®¿é—®ï¼Œå¤åˆ¶åˆå§‹åŒ–å°†å¯¼è‡´ç¼–è¯‘å™¨é”™è¯¯ã€‚

```c++
class MyClass {
public:
	MyClass() {}
private:
	MyClass(MyClass& c) = delete;
};
int main() {
	MyClass mc1;
	MyClass mc2 = mc1;  // ERROR: åˆ é™¤
}
```

åˆ—è¡¨åˆå§‹åŒ–ä½¿ç”¨ `{v1,v2,..}` åˆå§‹åŒ–å˜é‡æˆ–å‚æ•°ã€`new` ç±»å¯¹è±¡ã€éé™æ€æ•°æ®æˆå‘˜çš„åˆå§‹å€¼è®¾å®šé¡¹ã€æ„é€ å‡½æ•°åˆå§‹å€¼è®¾å®šé¡¹åˆ—è¡¨ä¸­ã€‚

```c++
class MyClass {
public:
    MyClass(int myInt, char myChar) {}
private:
    int m_int[5]{ 3 };
    char m_char;
};
class MyClassConsumer{
public:
    void set_class(MyClass c) {}
    MyClass get_class() { return MyClass{ 0, '\0' }; }
};
struct MyStruct{
    int my_int;
    char my_char;
    MyClass my_class;
};
int main() {
    MyClass mc1{ 1, 'a' };
    MyClass* mc2 = new MyClass{ 2, 'b' };
    MyClass mc3 = { 3, 'c' };

    MyClassConsumer mcc;
    mcc.set_class(MyClass{ 3, 'c' });
    mcc.set_class({ 4, 'd' });

    MyStruct ms1{ 1, 'a', { 2, 'b' } };
}
```

èšåˆåˆå§‹åŒ–æ˜¯é’ˆå¯¹æ•°ç»„æˆ–ç±»ç±»å‹ï¼ˆé€šå¸¸ä¸ºç»“æ„æˆ–è”åˆï¼‰çš„ä¸€ç§åˆ—è¡¨åˆå§‹åŒ–å½¢å¼ã€‚

```c++
struct Point3D {
	struct Point2D {
		int x, y;
	} xy;
	int z;
};
int main() {
    int arr[10](1, 2, 3, 4 /*,0 ...*/);
    int arr2[]{ 1,2,3,4,5,6 };  // arr2[6]

	using Point2D = Point3D::Point2D;
	Point2D p2{ 1,1 };
	Point3D p3{ 1,2,3 };
	Point3D p3_2{ {1,2},3 };
};
```

å¼•ç”¨ç±»å‹çš„å˜é‡å¿…é¡»ä½¿ç”¨å¼•ç”¨ç±»å‹æ´¾ç”Ÿè‡ªçš„ç±»å‹çš„å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–ï¼Œæˆ–ä½¿ç”¨å¯è½¬æ¢ä¸ºå¼•ç”¨ç±»å‹æ´¾ç”Ÿè‡ªçš„ç±»å‹çš„ç±»å‹çš„å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–ã€‚
- å¼•ç”¨è‡ªå˜é‡çš„å£°æ˜éœ€è¦åˆå§‹åŒ–è®¾å®šé¡¹ï¼›é™¤äº†ï¼š
  ```c++
  int func( int& );  // å‡½æ•°åŸå‹
  int& func( int& ); // å¼•ç”¨è¿”å›
  class c {public:   int& i;};  // æˆå‘˜å£°æ˜
  extern int& iVal;  // å¤–éƒ¨å¼•ç”¨å£°æ˜
  ```

```c++
int iVar;
long lVar;
int main()
{
    long& LongRef1 = lVar;        // No conversion required.
    long& LongRef2 = iVar;        // Error; wrong type
    const long& LongRef3 = iVar;  // OK
    LongRef1 = 23L;               // Change lVar through a reference.
    LongRef2 = 11L;               // Change iVar through a reference.
    LongRef3 = 11L;               // Error ; const

	volatile int& viVarRef = iVar;
	const int& ciVarRef = iVar;
}
```

>---
#### using åˆ«åå’Œ typedef

â€œåˆ«åå£°æ˜â€ å£°æ˜ä¸€ä¸ªç±»å‹çš„åŒä¹‰è¯åˆ«åï¼›

```c++
using identifier = type;
typedef type identifier;

using fmtfl = std::ios_base::fmtflags;
typedef std::ios_base::fmtflags fmtfl;

using func = void(*)(int);
typedef void (*func)(int);
```

`using` åˆ«åå’Œ `typedef` çš„åŒºåˆ«åœ¨äº `using` å¯ä»¥åˆ›å»ºåˆ«åæ¨¡æ¿ï¼š

```c++
template<typename T> using ptr = T*;
ptr<int> ptr_int;
```

`typedef` å£°æ˜åœ¨å…¶èŒƒå›´å†…å¼•å…¥ä¸€ä¸ªåç§°ï¼Œè¯¥åç§°æˆä¸ºå£°æ˜çš„ â€œç±»å‹å£°æ˜â€ éƒ¨åˆ†ç»™å®šçš„ç±»å‹çš„åŒä¹‰è¯ã€‚ä¸å¼•å…¥æ–°ç±»å‹ã€‚å¼•å…¥çš„åç§°ä¸èƒ½ç”¨ä½œç±»å£°æ˜ä¸­çš„æ„é€ å‡½æ•°åç§°æˆ–ææ„å‡½æ•°åç§°ã€‚

```c++
typedef unsigned long UL;   // Declare a typedef name, UL.
int UL;                     // Error: redefined.
int Foo()
{
   unsigned int UL;   // Redeclaration hides typedef name
}

typedef char CHAR, *PSTR;
typedef void DRAWF( int, int );  // func

typedef struct {
	int x, y;
} Point2D, * PPoint2D, & RPoint2D, && RRPoint2D;
int main(){
	RRPoint2D rra = Point2D{ 1,1 };
	RPoint2D ra = rra;
	PPoint2D pa = &rra;
}
```

>---
#### using å£°æ˜

`using` å£°æ˜å°†åç§°å¼•å…¥å£°æ˜æ€§åŒºåŸŸï¼›

```c++
using [typename] nested-name-specifier unqualified-id;
using declarator-list;
```

- *nested-name-specifier* è¡¨ç¤ºå‘½åç©ºé—´ã€ç±»æˆ–æšä¸¾åç§°å’ŒèŒƒå›´è§£æè¿ç®—ç¬¦ (`::`) çš„åºåˆ—ï¼Œç”±èŒƒå›´è§£æè¿ç®—ç¬¦ç»ˆæ­¢ã€‚å•ä¸ªèŒƒå›´è§£æè¿ç®—ç¬¦ç”¨äºä»å…¨å±€å‘½åç©ºé—´å¼•å…¥åç§°ã€‚å…³é”®å­— `typename` æ˜¯å¯é€‰çš„ï¼Œåœ¨ä»åŸºç±»å¼•å…¥åˆ°ç±»æ¨¡æ¿æ—¶ï¼Œå¯ç”¨äºè§£æä¾èµ–åç§°ã€‚

- *unqualified-id* å¯ä»¥æ˜¯æ ‡è¯†ç¬¦ã€é‡è½½è¿ç®—ç¬¦åç§°ã€ç”¨æˆ·å®šä¹‰çš„æ–‡æœ¬è¿ç®—ç¬¦æˆ–è½¬æ¢å‡½æ•°åç§°ã€ç±»ææ„å‡½æ•°åç§°æˆ–æ¨¡æ¿åç§°å’Œå‚æ•°åˆ—è¡¨ã€‚
  
`using` å£°æ˜å¼•å…¥éé™å®šåç§°ä½œä¸ºåœ¨å…¶ä»–åœ°æ–¹å£°æ˜çš„å®ä½“çš„åŒä¹‰è¯ã€‚å®ƒå…è®¸ä½¿ç”¨ç‰¹å®šå‘½åç©ºé—´ä¸­çš„å•ä¸ªåç§°ã€‚è¿™ä¸ `using` æŒ‡ä»¤ç›¸åï¼Œ`using` æŒ‡ä»¤å…è®¸å‘½åç©ºé—´ä¸­çš„æ‰€æœ‰åç§°åœ¨æ²¡æœ‰é™å®šçš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚å±€éƒ¨å‡½æ•°å£°æ˜ä¸èƒ½ä¸ `using` å£°æ˜å¼•å…¥çš„å‡½æ•°å…·æœ‰ç›¸åŒçš„åç§°å’Œç±»å‹ã€‚

```c++
#include <iostream>
namespace mySpace {
	void Foo() {};
	struct S {};
};
int main() {
	using std::ostream;

	std::cout << "using std::ostream" << std::endl;

	mySpace::Foo(); // é™å®šä½¿ç”¨

	using mySpace::S;
	S s{};  // using å£°æ˜å¼•å…¥

	using namespace std;
	// å¼•å…¥å‘½åç©ºé—´
	cout << "using namespace std" << endl;
}
```

ç”¨äºå£°æ˜æˆå‘˜æ—¶ï¼Œ`using` å£°æ˜å¿…é¡»å¼•ç”¨åŸºç±»çš„æˆå‘˜ã€‚

```c++
#include <stdio.h>
class B {
public:
   void f(char) {
      printf_s("In B::f()\n");
   }

   void g(char) {
      printf_s("In B::g()\n");
   }
};

class C {
public:
   int g();
};

class D2 : public B {
public:
   using B::f;   // ok: B is a base of D2
   // using C::g;   // error: C isn't a base of D2
};

int main() {
   D2 MyD2;
   MyD2.f('a');
}
```

`using` å£°æ˜ä¸­æåŠçš„åç§°çš„æ‰€æœ‰å®ä¾‹éƒ½å¿…é¡»å¯è®¿é—®ã€‚

```c++
class A {
private:
   void f(char);
public:
   void f(int);
protected:
   void g();
};

class B : public A {
   using A::f;   // C2876: A::f(char) is inaccessible
public:
   using A::g;   // B::g is a public synonym for A::g
};
```

è¿›è¡Œ `using` å£°æ˜æ—¶ï¼Œç”±è¯¥å£°æ˜åˆ›å»ºçš„åŒä¹‰è¯ä»…å¼•ç”¨åœ¨è¿›è¡Œ `using` å£°æ˜æ—¶æœ‰æ•ˆçš„å®šä¹‰ã€‚ä¹‹åæ·»åŠ åˆ°å‘½åç©ºé—´çš„å®šä¹‰ä¸æ˜¯æœ‰æ•ˆåŒä¹‰è¯ã€‚

```c++
namespace A {
   void f(int) {}
}
using A::f;   // f is a synonym for A::f(int) only
namespace A {
   void f(char) {}  // after using A::f
}

void f() {
   f('a');   // refers to A::f(int), even though A::f(char) exists
}

void b() {
   using A::f;   // refers to A::f(int) AND A::f(char)
   f('a');   // calls A::f(char);
}
```

>---
#### volatile æ˜“å˜

`volatile` æ˜¯ç”¨äºå£°æ˜å¯åœ¨ç¨‹åºä¸­ç”±ç¡¬ä»¶ä¿®æ”¹çš„å¯¹è±¡çš„ç±»å‹é™å®šç¬¦ã€‚å¯ä»¥ä½¿ç”¨ `volatile` é™å®šç¬¦æä¾›å¯¹å¼‚æ­¥è¿‡ç¨‹ï¼ˆå¦‚ä¸­æ–­å¤„ç†ç¨‹åºï¼‰ä½¿ç”¨çš„å†…å­˜ä½ç½®çš„è®¿é—®æƒã€‚

å¦‚æœå°† `struct` æˆå‘˜æ ‡è®°ä¸º `volatile`ï¼Œåˆ™ `volatile` å°†ä¼ æ’­åˆ°æ•´ä¸ªç»“æ„ã€‚å¦‚æœæ»¡è¶³ä¸‹åˆ—æ¡ä»¶ä¹‹ä¸€ï¼Œåˆ™ `volatile` å¯èƒ½å¯¹å­—æ®µä¸èµ·ä½œç”¨ï¼š
- å¯å˜å­—æ®µçš„é•¿åº¦è¶…è¿‡å¯ä½¿ç”¨ä¸€æ¡æŒ‡ä»¤åœ¨å½“å‰ä½“ç³»ç»“æ„ä¸Šå¤åˆ¶çš„æœ€å¤§å¤§å°ã€‚
- æœ€å¤–å±‚åŒ…å« `struct` çš„é•¿åº¦ï¼ˆæˆ–å¦‚æœå®ƒæ˜¯å¯èƒ½åµŒå¥—çš„ `struct` çš„æˆå‘˜ï¼‰è¶…è¿‡å¯ä½¿ç”¨ä¸€æ¡æŒ‡ä»¤åœ¨å½“å‰ä½“ç³»ç»“æ„ä¸Šå¤åˆ¶çš„æœ€å¤§å¤§å°ã€‚

å°½ç®¡å¤„ç†å™¨ä¸ä¼šå¯¹ä¸å¯ç¼“å­˜çš„å†…å­˜è®¿é—®é‡æ–°æ’åºï¼Œä½†å¿…é¡»å°†ä¸å¯ç¼“å­˜çš„å˜é‡æ ‡è®°ä¸º `volatile`ï¼Œä»è€Œä¿è¯æ­¤ç¼–è¯‘å™¨ä¸ä¼šå¯¹å†…å­˜è®¿é—®é‡æ–°æ’åºã€‚

ä¸ `const` ç›¸ä¼¼ï¼Œå¯ä»¥å£°æ˜ `volatile` æˆå‘˜å‡½æ•°ï¼Œ`volatile struct` çš„æ˜“å˜å®ä¾‹åªèƒ½è°ƒç”¨æ˜“å˜æˆå‘˜å‡½æ•°ï¼›æ™®é€šç»“æ„å®ä¾‹å¯ä»¥è°ƒç”¨æ‰€æœ‰æˆå‘˜å‡½æ•°ã€‚

```c++
volatile struct  S {
	int V;
public:
	volatile void Foo(volatile int& V) volatile;
	void Foo(int& V); // é‡è½½
	//void Foo(volatile int V);  // äºŒä¹‰æ€§
	//void Foo(int V);  
};
volatile void S::Foo(volatile int& V) volatile {
	cout << "V Foo&" << endl;
}
void S::Foo(int& V) {
	cout << "Foo&" << endl;
}
int main() {
	volatile auto s = S{ 10 }; 
	volatile auto& vrv = s.V;
	int& rv = ( int&)vrv;
	S s2{};
	s.Foo(vrv);   // call s.Foo volatile
	s2.Foo(vrv);  // V Foo&
	s2.Foo(rv);   // Foo&
}
```


>---
#### decltype å’Œè½¬å‘å‡½æ•°

`decltype` ç±»å‹è¯´æ˜ç¬¦ç”ŸæˆæŒ‡å®šè¡¨è¾¾å¼çš„ç±»å‹ã€‚ä½¿ç”¨ `auto` å’Œ `decltype` å£°æ˜å…¶è¿”å›ç±»å‹å–å†³äºå…¶æ¨¡æ¿è‡ªå˜é‡ç±»å‹çš„å‡½æ•°æ¨¡æ¿ã€‚æˆ–è€…ä½¿ç”¨ `auto` å’Œ `decltype` å£°æ˜ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œç”¨æ¥åŒ…è£…å¯¹å…¶ä»–å‡½æ•°çš„è°ƒç”¨ï¼Œç„¶åè¿”å›åŒ…è£…å‡½æ•°çš„è¿”å›ç±»å‹ã€‚

```c++
//C++11
template<typename T, typename U>
auto myFunc(T&& t, U&& u) -> decltype (forward<T>(t) + forward<U>(u))
        { return forward<T>(t) + forward<U>(u); };

//C++14
template<typename T, typename U>
decltype(auto) myFunc(T&& t, U&& u)
        { return forward<T>(t) + forward<U>(u); };
```

> *è½¬å‘å‡½æ•°* C++11

è½¬å‘å‡½æ•°åŒ…è£…å¯¹å…¶ä»–å‡½æ•°çš„è°ƒç”¨ã€‚è½¬å‘å‡½æ•°çš„è¿”å›ç±»å‹ä¸åŒ…è£…å‡½æ•°çš„è¿”å›ç±»å‹ç›¸åŒã€‚

```c++
#include <iostream>
#include <string>
#include <utility>
#include <iomanip>

using namespace std;

template<typename T1, typename T2>
auto Plus(T1&& t1, T2&& t2) ->
decltype(forward<T1>(t1) + forward<T2>(t2))
{
    return forward<T1>(t1) + forward<T2>(t2);
}
class X
{
    friend X operator+(const X& x1, const X& x2)
    {
        return X(x1.m_data + x2.m_data);
    }

public:
    X(int data) : m_data(data) {}
    int Dump() const { return m_data; }
private:
    int m_data;
};

int main()
{
    // Integer
    int i = 4;
    cout <<
        "Plus(i, 9) = " <<
        Plus(i, 9) << endl;   // Plus(i, 9) = 13

    // Floating point
    float dx = 4.0;
    float dy = 9.5;
    cout <<
        setprecision(3) <<
        "Plus(dx, dy) = " <<
        Plus(dx, dy) << endl;  // Plus(dx, dy) = 13.5

    // String
    string hello = "Hello, ";
    string world = "world!";
    cout << Plus(hello, world) << endl;  // Hello, world!

    // Custom type
    X x1(20);
    X x2(22);
    X x3 = Plus(x1, x2);
    cout <<
        "x3.Dump() = " <<
        x3.Dump() << endl;  // x3.Dump() = 42
}
```

>---
#### ç‰¹æ€§å£°æ˜

C++ æ ‡å‡†å®šä¹‰äº†ä¸€ç»„é€šç”¨å±æ€§ã€‚å±æ€§ä»£è¡¨ `#pragma` æŒ‡ä»¤ã€`__declspec()` (Visual C++) æˆ– `__attribute__` (GNU) ç­‰ä¾›åº”å•†ç‰¹å®šæ‰©å±•çš„æ ‡å‡†åŒ–æ›¿ä»£é¡¹ã€‚æ ‡å‡†å±æ€§åŒ…å«ï¼š
- `[[carries_dependency]]` æŒ‡å®šå‡½æ•°ä¼ æ’­çº¿ç¨‹åŒæ­¥çš„æ•°æ®ä¾èµ–é¡¹é¡ºåºã€‚åº”ç”¨äºä¸€ä¸ªæˆ–å¤šä¸ªå‚æ•°ï¼Œä»¥æŒ‡å®šä¼ å…¥çš„å‚æ•°è¦å°†ä¾èµ–é¡¹å¸¦å…¥å‡½æ•°ä¸»ä½“ä¸­ã€‚ç”¨äºå‡½æ•°æœ¬èº«ä»¥æŒ‡å®šè¿”å›å€¼è¦å°†ä¾èµ–é¡¹å¸¦å‡ºå‡½æ•°ã€‚
- `[[deprecated]]` æŒ‡å®šå‡½æ•°ä¸é€‚åˆä½¿ç”¨ï¼Œè¡¨æ˜å·²å¼ƒç”¨ï¼›åº”ç”¨äºç±»ã€typedef åç§°ã€å˜é‡ã€éé™æ€æ•°æ®æˆå‘˜ã€å‡½æ•°ã€å‘½åç©ºé—´ã€æšä¸¾ã€æšä¸¾å™¨æˆ–æ¨¡æ¿ä¸“ç”¨åŒ–çš„å£°æ˜ã€‚
- [[fallthrough]] å¯åœ¨ `switch` è¯­å¥çš„ä¸Šä¸‹æ–‡ä¸­ç”¨ä½œå‘ç¼–è¯‘å™¨ï¼ˆæˆ–é˜…è¯»ä»£ç çš„ä»»ä½•äººï¼‰æ˜¾ç¤ºçš„æç¤ºï¼ŒæŒ‡å‡ºå¤±è´¥è¡Œä¸ºæ˜¯æœ‰æ„çš„ã€‚
- [[likely]] å‘ç¼–è¯‘å™¨æŒ‡å®šæç¤ºï¼ŒæŒ‡å‡ºå±æ€§åŒ–æ ‡ç­¾æˆ–è¯­å¥çš„ä»£ç è·¯å¾„çš„æ‰§è¡Œå¯èƒ½æ€§é«˜äºæ›¿ä»£é¡¹ã€‚
- [[unlikely]] å‘ç¼–è¯‘å™¨æŒ‡å®šæç¤ºï¼ŒæŒ‡å‡ºå±æ€§åŒ–æ ‡ç­¾æˆ–è¯­å¥çš„ä»£ç è·¯å¾„çš„æ‰§è¡Œå¯èƒ½æ€§ä½äºæ›¿ä»£é¡¹ã€‚
- [[maybe_unused]] æŒ‡å®šå˜é‡ã€å‡½æ•°ã€ç±»ã€*typedef*ã€éé™æ€æ•°æ®æˆå‘˜ã€æšä¸¾æˆ–æ¨¡æ¿ä¸“ç”¨åŒ–å¯èƒ½æ˜¯æœ‰æ„ä¸ä½¿ç”¨çš„ã€‚
- [[nodiscard]] æŒ‡å®šä¸åº”è¯¥ä¸¢å¼ƒå‡½æ•°çš„è¿”å›å€¼ã€‚
- [[noreturn]] æŒ‡å®šå‡½æ•°æ°¸ä¸è¿”å›ï¼›å®ƒå§‹ç»ˆå¼•å‘å¼‚å¸¸æˆ–é€€å‡ºã€‚

```c++
#include <iostream>
#include <utility>
using namespace std;
template<typename T1, typename T2>
[[nodiscard]] auto Plus(T1&& t1, T2&& t2) ->
decltype(forward<T1>(t1) + forward<T2>(t2))
{
	return forward<T1>(t1) + forward<T2>(t2);
}
int main() {
	std::cout << Plus(1, 2) << std::endl;
}

[[noreturn]] void Foo(int exitcode) {
	_Exit(exitcode);
}
```

---
### è¿ç®—ç¬¦ä¸è¡¨è¾¾å¼

C++ è¯­è¨€åŒ…æ‹¬æ‰€æœ‰ C è¿ç®—ç¬¦å¹¶æ·»åŠ å¤šä¸ªæ–°çš„è¿ç®—ç¬¦ã€‚C++ è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å’Œå…³è”æ€§ï¼š

| precedence | operator                     | description        | associativity | alternative |
| :--------- | :--------------------------- | :----------------- | :------------ | :---------- |
| 1          | `::`                         | èŒƒå›´è§£æ           |               |             |
| 2          | `.`,`->`                     | æˆå‘˜é€‰æ‹©           | ä»å·¦åˆ°å³      |             |
| 2          | `[]`                         | æ•°ç»„ç´¢å¼•           | ä»å·¦åˆ°å³      |             |
| 2          | `()`                         | å‡½æ•°è°ƒç”¨           | ä»å·¦åˆ°å³      |             |
| 2          | `++`                         | åç¼€é€’å¢           | ä»å·¦åˆ°å³      |             |
| 2          | `--`                         | åç¼€é€’å‡           | ä»å·¦åˆ°å³      |             |
| 2          | `typeid`                     | ç±»å‹åç§°           | ä»å·¦åˆ°å³      |             |
| 2          | `const_cast`                 | å¸¸é‡ç±»å‹è½¬æ¢       | ä»å·¦åˆ°å³      |             |
| 2          | `dynamic_cast`               | åŠ¨æ€ç±»å‹è½¬æ¢       | ä»å·¦åˆ°å³      |             |
| 2          | `reinterpret_cast`           | é‡æ–°è§£é‡Šçš„ç±»å‹è½¬æ¢ | ä»å·¦åˆ°å³      |             |
| 2          | `static_cast`                | é™æ€ç±»å‹è½¬æ¢       | ä»å·¦åˆ°å³      |             |
| 3          | `sizeof`                     | å¯¹è±¡æˆ–ç±»å‹çš„å¤§å°   | ä»å³åˆ°å·¦      |             |
| 3          | `++`                         | å‰ç¼€é€’å¢           | ä»å³åˆ°å·¦      |             |
| 3          | `--`                         | å‰ç¼€é€’å‡           | ä»å³åˆ°å·¦      |             |
| 3          | `~`                          | äºŒè¿›åˆ¶åç          | ä»å³åˆ°å·¦      | `compl`     |
| 3          | `!`                          | é€»è¾‘ â€œéâ€          | ä»å³åˆ°å·¦      | `not`       |
| 3          | `-`                          | ä¸€å…ƒæ±‚å           | ä»å³åˆ°å·¦      |             |
| 3          | `+`                          | ä¸€å…ƒåŠ              | ä»å³åˆ°å·¦      |             |
| 3          | `&`                          | Address-of         | ä»å³åˆ°å·¦      |             |
| 3          | `*`                          | é—´æ¥å¯»å€           | ä»å³åˆ°å·¦      |             |
| 3          | `new`                        | åˆ›å»ºå¯¹è±¡           | ä»å³åˆ°å·¦      |             |
| 3          | `delete`                     | é”€æ¯å¯¹è±¡           | ä»å³åˆ°å·¦      |             |
| 3          | `typename(V)`, `(typename)V` | å¼ºåˆ¶è½¬æ¢           | ä»å³åˆ°å·¦      |             |
| 4          | `.*`, `->*`                  | æŒ‡å‘æˆå‘˜çš„æŒ‡é’ˆ     | ä»å·¦åˆ°å³      |             |
| 5          | `*`                          | ä¹˜æ³•               | ä»å·¦åˆ°å³      |             |
| 5          | `/`                          | é™¤æ³•               | ä»å·¦åˆ°å³      |             |
| 5          | `%`                          | å–æ¨¡               | ä»å·¦åˆ°å³      |             |
| 6          | `+`                          | åŠ æ³•               | ä»å·¦åˆ°å³      |             |
| 6          | `-`                          | å‡æ³•               | ä»å·¦åˆ°å³      |             |
| 7          | `<<`                         | å·¦ç§»               | ä»å·¦åˆ°å³      |             |
| 7          | `>>`                         | å³ç§»               | ä»å·¦åˆ°å³      |             |
| 8          | `<`                          | å°äº               | ä»å·¦åˆ°å³      |             |
| 8          | `>`                          | å¤§äº               | ä»å·¦åˆ°å³      |             |
| 8          | `<=`                         | å°äºæˆ–ç­‰äº         | ä»å·¦åˆ°å³      |             |
| 8          | `>=`                         | å¤§äºæˆ–ç­‰äº         | ä»å·¦åˆ°å³      |             |
| 9          | `==`                         | ç­‰å¼               | ä»å·¦åˆ°å³      |             |
| 9          | `!=`                         | ä¸ç›¸ç­‰             | ä»å·¦åˆ°å³      | `not_eq`    |
| 10         | `&`                          | æŒ‰ä½ â€œä¸â€          | ä»å·¦åˆ°å³      | `bitand`    |
| 11         | `^`                          | æŒ‰ä½ â€œå¼‚æˆ–â€        | ä»å·¦åˆ°å³      | `xor`       |
| 12         | `` \| ``                     | æŒ‰ä½ â€œä¸æˆ–â€        | ä»å·¦åˆ°å³      | `bitor`     |
| 13         | `&&`                         | é€»è¾‘ä¸             | ä»å·¦åˆ°å³      | `and`       |
| 14         | `\|\|`                       | é€»è¾‘æˆ–             | ä»å·¦åˆ°å³      | `or`        |
| 15         | `? :`                        | æ¡ä»¶               | ä»å³åˆ°å·¦      |             |
| 15         | `=`                          | èµ‹å€¼               | ä»å³åˆ°å·¦      |             |
| 15         | `*=`                         | ä¹˜æ³•èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `/=`                         | é™¤æ³•èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `%=`                         | å–æ¨¡èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `+=`                         | åŠ æ³•èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `-=`                         | å‡æ³•èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `<<=`                        | å·¦ç§»èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `>>=`                        | å³ç§»èµ‹å€¼           | ä»å³åˆ°å·¦      |             |
| 15         | `&=`                         | æŒ‰ä½ â€œä¸â€ èµ‹å€¼     | ä»å³åˆ°å·¦      | `and_eq`    |
| 15         | `\|=`                        | æŒ‰ä½ â€œä¸æˆ–â€ èµ‹å€¼   | ä»å³åˆ°å·¦      | `or_eq`     |
| 15         | `^=`                         | æŒ‰ä½ â€œå¼‚æˆ–â€ èµ‹å€¼   | ä»å³åˆ°å·¦      | `xor_eq`    |
| 15         | `throw`                      | å¼•å‘è¡¨è¾¾å¼         | ä»å³åˆ°å·¦      |             |
| 16         | `,`                          | é¡ºåºè¿ç®—           | ä»å·¦åˆ°å³      |             |
	         	
>---
#### alignof å¯¹é½

`alignof` æŒ‡å®šç±»å‹çš„å¯¹é½æ–¹å¼ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ä½œä¸ºç±»å‹ `size_t` çš„å€¼è¿”å›ï¼›å¸¸ä½œä¸ºæŸä¸ªå†…å­˜åˆ†é…ä¾‹ç¨‹çš„å‚æ•°å‡ºç°ã€‚

```c++
typedef alignas(32) struct { int a; double b; } S;
int n = 50; // array size
S* p = (S*)aligned_malloc(n * sizeof(S), alignof(S));
```

å¯ä»¥ä½¿ç”¨ `#pragma pack`ã€`alignas` ä¿®æ”¹ç±»å‹å¯¹è±¡çš„å¯¹é½æ–¹å¼ï¼›

```c++
#include <stddef.h>
#include <stdio.h>

struct S {
	int i;      // size 4
	short j;    // size 2
	double k;   // size 8
};

#pragma pack(2)
struct T {
	int i;
	short j;
	double k;
};
#pragma pack(0)  // æ¢å¤é»˜è®¤
int main() {
	printf("alignof(S) %zu ", alignof(S));  // 8
	printf("sizeof(S) %zu ", sizeof(S));  // 16
	printf("%zu ", offsetof(S, i));  // 0
	printf("%zu ", offsetof(S, j));  // 4 
	printf("%zu\n", offsetof(S, k)); // 8

	printf("alignof(T) %zu ", alignof(T));  // 2
	printf("sizeof(T) %zu ", sizeof(T));  // 14
	printf("%zu ", offsetof(T, i));  // 0
	printf("%zu ", offsetof(T, j));  // 4
	printf("%zu\n", offsetof(T, k)); // 6
}
```

>---
#### ç®—æ•°è¿ç®—

```c++
auto sum = a + b;
auto sub = a - b;
auto mul = a * b;
auto  
```

>---
#### Address-of

*Address-of* è¿ç®—ç¬¦ (`&`) è¿”å›å…¶æ“ä½œæ•°çš„åœ°å€ï¼›æ“ä½œæ•°æ˜¯å‡½æ•°æŒ‡ç¤ºç¬¦ï¼Œæˆ–å¼•ç”¨éä½å­—æ®µå¯¹è±¡çš„ *lvalue*ï¼ˆåŸºæœ¬ç±»å‹ã€ç»“æ„ã€ç±»æˆ–è”åˆçš„å˜é‡ï¼Œæˆ–ä¸‹æ ‡æ•°ç»„å¼•ç”¨ï¼‰ã€‚ä»…å½“æ˜ç¡®è¦å¼•ç”¨çš„å‡½æ•°çš„ç‰ˆæœ¬æ—¶ï¼Œæ‰èƒ½é‡‡ç”¨é‡è½½å‡½æ•°çš„åœ°å€ã€‚

åº”ç”¨äºé™å®šåæ—¶ï¼Œç»“æœå°†å–å†³äºé™å®šåç§°æ˜¯å¦æŒ‡å®šé™æ€æˆå‘˜ï¼Œåˆ™ç»“æœä¸ºæŒ‡å‘æˆå‘˜ç±»å‹çš„æŒ‡é’ˆã€‚å¯¹äºéé™æ€æˆå‘˜ï¼Œåˆ™ç»“æœä¸ºæŒ‡å‘ç”±é™å®šåç§°æŒ‡ç¤ºçš„ç±»çš„æˆå‘˜åç§°çš„æŒ‡é’ˆã€‚

```c++
class PTM {
public:
    int iValue;
    static float fValue;
};

int main() {
   int   PTM::*piValue = &PTM::iValue;  // OK: non-static
   float PTM::*pfValue = &PTM::fValue;  // error: static
   float *spfValue     = &PTM::fValue;  // OK
// ç”±äº `fValue` æ˜¯é™æ€æˆå‘˜ï¼Œå› æ­¤è¡¨è¾¾å¼ `&PTM::fValue` äº§ç”Ÿ
// ç±»å‹ `float *` è€Œä¸æ˜¯ç±»å‹ `float PTM::*`ã€‚
}
```

>---
#### èµ‹å€¼è¿ç®—

```c
int a = b;  
int a += b; // a = a + b
int a -= b;
int a *= b;
int a /= b;
int a %= b;
int a <<= b;
int a >>= b;
int a &= b;  // a = a and_eq b
int a ^= b;  // a = a or_eq  b
int a |= b;  // a = a xor_eq b
```

`const` å’Œ `volatile` ç±»å‹çš„å¯¹è±¡å¯ä»¥èµ‹ç»™ä»…ä¸º `volatile` æˆ–ä¸ä¸º `const` æˆ– `volatile` çš„ç±»å‹çš„å·¦å€¼ã€‚

å¯¹ç±»ç±»å‹ï¼ˆ`struct`ã€`union` å’Œ `class` ç±»å‹ï¼‰çš„å¯¹è±¡çš„èµ‹å€¼ç”± `operator=` å‡½æ•°æ‰§è¡Œã€‚é»˜è®¤è¡Œä¸ºæ˜¯å°†æ‰§è¡Œå¯¹è±¡çš„éé™æ€æ•°æ®æˆå‘˜å’Œç›´æ¥åŸºç±»çš„é€ä¸ªæˆå‘˜å¤åˆ¶èµ‹å€¼ï¼›ä»»ä½•ä»ç»™å®šåŸºç±»æ˜ç¡®æ´¾ç”Ÿçš„ç±»çš„å¯¹è±¡å‡å¯èµ‹ç»™åŸºç±»çš„å¯¹è±¡ã€‚

åœ¨ ANSI C ä¸­ï¼Œèµ‹å€¼è¡¨è¾¾å¼çš„ç»“æœä¸æ˜¯å·¦å€¼ã€‚ è¿™æ„å‘³ç€ C ä¸­ä¸å…è®¸ä½¿ç”¨åˆæ³•çš„ C++ è¡¨è¾¾å¼ `(a += b) += c`ã€‚

>---
#### ä½è¿ç®—

```c++
unsigned char a = 0b10100101;
unsigned char b = 0b11000011;
auto print = [=](unsigned char expr) {
	char s[64];
	_itoa_s(expr, s, 64, 2);
	printf("%08.8s\n", s);
	};
print(a & b);  // 10000001; æŒ‰ä½ä¸
print(a | b);  // 11100111; æŒ‰ä½æˆ–
print(a ^ b);  // 01100110; æŒ‰ä½å¼‚æˆ–
```

>---
#### å¼ºåˆ¶è½¬æ¢

`()` ç±»å‹å¼ºåˆ¶è½¬æ¢æä¾›äº†ç”¨äºæ˜¾å¼è½¬æ¢å¯¹è±¡ç±»å‹çš„æ–¹æ³•ã€‚

```c++
typeA a = (typeA)vb;
typeA a = typeA(vb);
```

ç”¨æˆ·å®šä¹‰çš„å¼ºåˆ¶è½¬æ¢ `operator type ()`ï¼š

```c++
struct KM {
	long double distance;
public:
	KM() { distance = 0; };
	KM(long double dis) { distance = dis; };
	operator long double() { return distance; }   // user-defned cast
	KM operator=(int dis) { return KM{ (long double)dis }; }
	KM operator=(long double dis) { return KM{ dis }; }
	KM operator=(unsigned long long dis) { return KM{ (long double)dis }; }
};
KM operator ""km(long double dis) {
	return KM{ dis };
};
KM operator ""km(unsigned long long dis) {
	return KM{ (long double)dis };
};

int main() {
	KM d1 = 10km;    // int to KM
	KM d2 = 3.14km;  // double to KM
	KM d3 = 10;
	KM d4 = 3.14L;
	long double d = d1;  // or (long double)d1;
}
```

æœ‰å‡ ç§ç‰¹å®šäº C++ è¯­è¨€çš„è½¬æ¢è¿ç®—ç¬¦ã€‚

```c++
// æ“ä½œæ•° expression è½¬æ¢ä¸º type-id ç±»å‹çš„å¯¹è±¡;
dynamic_cast < type-id > ( expression )   

// ä»…æ ¹æ®è¡¨è¾¾å¼ä¸­å­˜åœ¨çš„ç±»å‹ï¼Œå°† expression è½¬æ¢ä¸º type-id ç±»å‹
static_cast <type-id> ( expression )    

// ä»æŸä¸ªç±»åˆ é™¤ constã€volatile å’Œ __unaligned å±æ€§ã€‚
const_cast <type-id> (expression)          

// å…è®¸å°†ä»»ä½•æŒ‡é’ˆè½¬æ¢ä¸ºä»»ä½•å…¶ä»–æŒ‡é’ˆç±»å‹ã€‚ä¹Ÿå…è®¸å°†ä»»ä½•æ•´æ•°ç±»å‹è½¬æ¢ä¸ºä»»ä½•æŒ‡é’ˆç±»å‹ä»¥åŠåå‘è½¬æ¢ã€‚
reinterpret_cast < type-id > ( expression )  
```

> *dynamic_cast*

`dynamic_cast` ç”¨äºå¤šæ€ç±»å‹çš„è½¬æ¢ã€‚`type-id` æ˜¯ç±»ç±»å‹çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œæˆ–è€…æ˜¯ `void*`ï¼›

æ‰˜ç®¡ä»£ç ä¸­çš„ `dynamic_cast` è¡Œä¸ºæœ‰ä¸¤é¡¹ä¸­æ–­æ€§å˜æ›´ï¼š
  - å¯¹æŒ‡å‘è£…ç®±æšä¸¾çš„åŸºç¡€ç±»å‹çš„æŒ‡é’ˆçš„ dynamic_cast å°†åœ¨è¿è¡Œæ—¶å¤±è´¥ï¼Œè¿”å› 0 è€Œä¸æ˜¯è½¬æ¢åçš„æŒ‡é’ˆã€‚
  - å½“ `type-id` æ˜¯æŒ‡å‘å€¼ç±»å‹çš„å†…éƒ¨æŒ‡é’ˆæ—¶ï¼Œ`dynamic_cast` å°†ä¸å†å¼•å‘å¼‚å¸¸ï¼Œå¤±è´¥è¿”å›ç©ºæŒ‡é’ˆå€¼ï¼›å¼ºåˆ¶è½¬æ¢åœ¨è¿è¡Œæ—¶å¤±è´¥ã€‚

å¦‚æœ `type-id` æ˜¯æŒ‡å‘ `expression` çš„æ˜ç¡®å¯è®¿é—®çš„ç›´æ¥æˆ–é—´æ¥åŸºç±»çš„æŒ‡é’ˆï¼Œåˆ™ç»“æœæ˜¯æŒ‡å‘ `type-id` ç±»å‹çš„å”¯ä¸€å­å¯¹è±¡çš„æŒ‡é’ˆã€‚

```c++
class B { };
class C : public B { };
class D : public C { };

D* pd = new D;
C* pc = dynamic_cast<C*>(pd);   
// ok: C is a direct base class, pc points to C subobject of pd
B* pb = dynamic_cast<B*>(pd);  
// ok: B is an indirect base class, pb points to B subobject of pd
```

å¦‚æœ `type-id` æ˜¯ `void*`ï¼Œåˆ™è¿›è¡Œè¿è¡Œæ—¶æ£€æŸ¥ä»¥ç¡®å®š `expression` çš„å®é™…ç±»å‹ã€‚ç»“æœæ˜¯æŒ‡å‘ç”± `expression` æŒ‡å‘çš„å®Œæ•´å¯¹è±¡çš„æŒ‡é’ˆã€‚

```c++
class A {virtual void f();};
class B {virtual void f();};

A* pa = new A;
B* pb = new B;
void* pv = dynamic_cast<void*>(pa);  // pv now points to an object of type A
pv = dynamic_cast<void*>(pb);        // pv now points to an object of type B
```
  
å¦‚æœ `type-id` ä¸æ˜¯ `void*`ï¼Œåˆ™è¿›è¡Œè¿è¡Œæ—¶æ£€æŸ¥ï¼Œçœ‹çœ‹æ˜¯å¦å¯ä»¥å°† `expression` æŒ‡å‘çš„å¯¹è±¡è½¬æ¢ä¸º `type-id` æŒ‡å‘çš„ç±»å‹ã€‚
  
å¦‚æœ `expression` çš„ç±»å‹æ˜¯ `type-id` ç±»å‹çš„åŸºç±»ï¼Œåˆ™è¿›è¡Œè¿è¡Œæ—¶æ£€æŸ¥ï¼Œçœ‹çœ‹ `expression` æ˜¯å¦å®é™…æŒ‡å‘ `type-id` ç±»å‹çš„å®Œæ•´å¯¹è±¡ã€‚å¦‚æœæ˜¯ï¼Œåˆ™ç»“æœæ˜¯æŒ‡å‘ `type-id` ç±»å‹çš„å®Œæ•´å¯¹è±¡çš„æŒ‡é’ˆã€‚

```c++
class B {virtual void f();};
class D : public B {virtual void f();};

B* pb = new D;   // unclear but ok
B* pb2 = new B;
D* pd = dynamic_cast<D*>(pb);     // ok: pb actually points to a D
D* pd2 = dynamic_cast<D*>(pb2);   // not ok: pb2 points to a B not a D
```

å¦‚æœæœ‰å¤šé‡ç»§æ‰¿ï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸æ˜ç¡®ã€‚ä½¿ç”¨è™šæ‹ŸåŸºç±»æ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ›´å¤šä¸æ˜ç¡®çš„æƒ…å†µã€‚

```c++
class A { virtual void f(); };
class B : public A { virtual void f(); };
class C : public A { virtual void f(); };
class D : public B, public C { virtual void f(); };

D* pd = new D;
A* pa = dynamic_cast<A*>(pd);   // C4540, ambiguous cast fails at runtime

// æŒ‡å‘ `D` ç±»å‹å¯¹è±¡çš„æŒ‡é’ˆå¯ä»¥å®‰å…¨åœ°å¼ºåˆ¶è½¬æ¢ä¸º `B` æˆ– `C`ã€‚ä½†æ˜¯ï¼Œå¦‚æœ `D` å¼ºåˆ¶
// è½¬æ¢ä¸ºæŒ‡å‘ `A` å¯¹è±¡çš„æŒ‡é’ˆï¼Œä¼šäº§ç”Ÿ `A` çš„å“ªä¸ªå®ä¾‹ï¼Ÿ è¿™å°†å¯¼è‡´ä¸æ˜ç¡®çš„å¼ºåˆ¶è½¬æ¢é”™è¯¯ã€‚
// è‹¥è¦è§£å†³æ­¤é—®é¢˜ï¼Œå¯ä»¥æ‰§è¡Œä¸¤ä¸ªæ˜ç¡®çš„å¼ºåˆ¶è½¬æ¢ã€‚
B* pb = dynamic_cast<B*>(pd);   // first cast to B
A* pa2 = dynamic_cast<A*>(pb);  // ok: unambiguous
```

æœªèƒ½å¼ºåˆ¶è½¬æ¢ä¸ºæŒ‡é’ˆç±»å‹çš„å€¼æ˜¯ç©ºæŒ‡é’ˆã€‚å¦‚æœå¯¹å¼•ç”¨ç±»å‹çš„å¼ºåˆ¶è½¬æ¢å¤±è´¥ï¼Œä¼šå¼•å‘ `bad_cast` å¼‚å¸¸ã€‚ å¦‚æœ `expression` æ²¡æœ‰æŒ‡å‘æˆ–å¼•ç”¨æœ‰æ•ˆå¯¹è±¡ï¼Œåˆ™ä¼šå¼•å‘ `__non_rtti_object` å¼‚å¸¸ã€‚

```c++
class A { virtual void g() {} };
class B { virtual void f() {} };

int main() {
	A* pa = new A;
	try {
		B* pb = dynamic_cast<B*>(pa);   // fails at runtime, not safe;  
		// B not derived from A; pb is null
		B& rb = dynamic_cast<B&>(*pa);  // Bad dynamic_cast!
	}
	catch (bad_cast e) {
		cout <<  e.what() << endl;  
	}
}
```

> *static_cast*

`static_cast` ç”¨äºéå¤šæ€ç±»å‹çš„è½¬æ¢ã€‚å¯ç”¨äºå°†æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆè½¬æ¢ä¸ºæŒ‡å‘æ´¾ç”Ÿç±»çš„æŒ‡é’ˆç­‰æ“ä½œï¼Œä½†éå§‹ç»ˆå®‰å…¨ã€‚é€šå¸¸ä½¿ç”¨ `static_cast` è½¬æ¢æ•°å€¼æ•°æ®ç±»å‹ï¼Œä¾‹å¦‚å°†æšä¸¾å‹è½¬æ¢ä¸ºæ•´å‹æˆ–å°†æ•´å‹è½¬æ¢ä¸ºæµ®ç‚¹å‹ã€‚

`static_cast` è½¬æ¢å®‰å…¨æ€§ä¸å¦‚ `dynamic_cast` è½¬æ¢ï¼Œå› ä¸º `static_cast` ä¸æ‰§è¡Œè¿è¡Œæ—¶ç±»å‹æ£€æŸ¥ã€‚

```c++
class B {};
class D : public B { int V; };

B b{};
B* pb = &b; 
D* pd = static_cast<D*>(pb);   // Not safe, D can have fields
```

ä¸ `dynamic_cast` ä¸åŒï¼Œ`pb` çš„ `static_cast` è½¬æ¢ä¸æ‰§è¡Œè¿è¡Œæ—¶æ£€æŸ¥ã€‚ç”± `pb` æŒ‡å‘çš„å¯¹è±¡å¯èƒ½ä¸æ˜¯ `D` ç±»å‹çš„å¯¹è±¡ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ä½¿ç”¨ `*pd` ä¼šæ˜¯ç¾éš¾æ€§çš„ã€‚

```c++
class B {
public:
	virtual void Test() {}  // å¤šæ€ç±»å‹
};
class D : public B {};

int main() {
	B b{};
	B* pb = &b;

	// D* pd1 = pb; // not allowed  
	D* pd1 = dynamic_cast<D*>(pb);
	D* pd2 = static_cast<D*>(pb);
}
```

å¦‚æœ `pb` ç¡®å®æŒ‡å‘ `D` ç±»å‹çš„å¯¹è±¡ï¼Œåˆ™ `pd1` å’Œ `pd2` å°†è·å–ç›¸åŒçš„å€¼ã€‚å¦‚æœ `pb == 0`ï¼Œå®ƒä»¬ä¹Ÿå°†è·å–ç›¸åŒçš„å€¼ã€‚

å¦‚æœ `pb` æŒ‡å‘ `B` ç±»å‹çš„å¯¹è±¡ï¼Œè€ŒéæŒ‡å‘å®Œæ•´çš„ `D` ç±»å‹ï¼Œåˆ™ `dynamic_cast` è¶³ä»¥åˆ¤æ–­è¿”å›é›¶ã€‚ä½†æ˜¯ï¼Œ`static_cast` ä¾èµ–äºæ–­è¨€ï¼Œå‡å®š `pb` æŒ‡å‘ `D` ç±»å‹çš„å¯¹è±¡ï¼›`static_cast` å¯ä»¥åå‘æ‰§è¡Œéšå¼è½¬æ¢ï¼Œè€Œåœ¨è¿™ç§æƒ…å†µä¸‹ç»“æœæ˜¯ä¸ç¡®å®šçš„ã€‚è¿™éœ€è¦ç¨‹åºå‘˜æ¥éªŒè¯ `static_cast` è½¬æ¢çš„ç»“æœæ˜¯å¦å®‰å…¨ã€‚

```c++
	assert(pd1 == nullptr);  // ok
	assert(pd2 == pd1);  // assert failed
```

è¯¥è¡Œä¸ºä¹Ÿé€‚ç”¨äºç±»ä»¥å¤–çš„ç±»å‹ã€‚ ä¾‹å¦‚ï¼Œ`static_cast` å¯ç”¨äºå°† `int` è½¬æ¢ä¸º `char`ã€‚ä½†æ˜¯ï¼Œå¾—åˆ°çš„ `char` å¯èƒ½æ²¡æœ‰è¶³å¤Ÿçš„ä½æ¥ä¿å­˜æ•´ä¸ª `int` å€¼ã€‚åŒæ ·ï¼Œè¿™éœ€è¦ç¨‹åºå‘˜æ¥éªŒè¯ `static_cast` è½¬æ¢çš„ç»“æœæ˜¯å¦å®‰å…¨ã€‚

`static_cast` è¿ç®—ç¬¦è¿˜å¯ç”¨äºæ‰§è¡Œä»»ä½•éšå¼è½¬æ¢ï¼ŒåŒ…æ‹¬æ ‡å‡†è½¬æ¢å’Œç”¨æˆ·å®šä¹‰çš„è½¬æ¢ã€‚

```c++
typedef unsigned char BYTE;

void f() {
   char ch;
   int i = 65;
   float f = 2.5;
   double dbl;

   ch = static_cast<char>(i);      // int to char
   dbl = static_cast<double>(f);   // float to double
   i = static_cast<BYTE>(ch);
}
```

`static_cast` è¿ç®—ç¬¦å¯ä»¥å°†æ•´æ•°å€¼æ˜¾å¼è½¬æ¢ä¸ºæšä¸¾ç±»å‹ã€‚å¦‚æœæ•´å‹å€¼ä¸åœ¨æšä¸¾å€¼çš„èŒƒå›´å†…ï¼Œç”Ÿæˆçš„æšä¸¾å€¼æ˜¯ä¸ç¡®å®šçš„ã€‚è¿ç®—ç¬¦å¯ä»¥å°†ç©ºæŒ‡é’ˆå€¼è½¬æ¢ä¸ºç›®æ ‡ç±»å‹çš„ç©ºæŒ‡é’ˆå€¼ã€‚

ä»»ä½•è¡¨è¾¾å¼éƒ½å¯ä»¥é€šè¿‡ `static_cast` è¿ç®—ç¬¦æ˜¾å¼è½¬æ¢ä¸º `void` ç±»å‹ã€‚ç›®æ ‡ `void` ç±»å‹å¯ä»¥é€‰æ‹©æ€§åœ°åŒ…å« `const`ã€`volatile` æˆ– `__unaligned` ç‰¹æ€§ã€‚`static_cast` è¿ç®—ç¬¦æ— æ³•å¼ºåˆ¶è½¬æ¢æ‰ `const`ã€`volatile` æˆ– `__unaligned` ç‰¹æ€§ã€‚

```c++
enum E {
	a,b,c,d,
};
void main() {
	//E a = 0;  // not assigned to
	const E a = static_cast<E>(0);  // ok; == E::a
	assert(a == E::a);  // assert success
}
```

> *const_cast*

`const_cast` ç”¨äºåˆ é™¤ `const`ã€`volatile` å’Œ `__unaligned` ç‰¹æ€§ã€‚æŒ‡å‘ä»»ä½•å¯¹è±¡ç±»å‹æˆ–æ•°æ®æˆå‘˜çš„ `const`ã€`volatile`ã€`__unaligned` æŒ‡é’ˆå¯æ˜¾å¼è½¬æ¢ä¸ºå®Œå…¨ç›¸åŒçš„åŸå§‹ç±»å‹ï¼›ç»“æœå°†å¼•ç”¨åŸå§‹å¯¹è±¡æˆ–æ•°æ®æˆå‘˜çš„åŸå§‹å¯¹è±¡ã€‚æ ¹æ®å¼•ç”¨å¯¹è±¡çš„ç±»å‹ï¼Œé€šè¿‡ç”Ÿæˆçš„æŒ‡é’ˆã€å¼•ç”¨æˆ–æŒ‡å‘æ•°æ®æˆå‘˜çš„æŒ‡é’ˆçš„å†™å…¥æ“ä½œå¯èƒ½äº§ç”Ÿæœªå®šä¹‰çš„è¡Œä¸ºã€‚

`const_cast` ä¹Ÿå¯ä»¥å°†ä¸€ä¸ªç©ºæŒ‡é’ˆå€¼è½¬æ¢ä¸ºå…¶ä»–ç›®æ ‡ç±»å‹çš„ç©ºæŒ‡é’ˆå€¼ã€‚ä¸èƒ½ä½¿ç”¨ `const_cast` è¿ç®—ç¬¦ç›´æ¥é‡å†™ `constexpr` å˜é‡çš„å¸¸é‡çŠ¶æ€ã€‚

```c++
int number = 10010;
const int& ref_number = number;
int& v = const_cast<int&>(ref_number);
v = 110; 
assert(v == number);  // assert success; both are 110

constexpr int c_number = 10086;
const int& ref_c_number = c_number;
v = const_cast<int&>(ref_c_number);
v = 911;
assert(v == c_number); // failed; c_number = 10086
```

> *reinterpret_cast* 

`reinterpret_cast` ç”¨äºå¯¹ä½è¿›è¡Œç®€å•çš„é‡æ–°è§£é‡Šã€‚å…è®¸å°†ä»»ä½•æŒ‡é’ˆè½¬æ¢ä¸ºä»»ä½•å…¶ä»–æŒ‡é’ˆç±»å‹ï¼Œä¹Ÿå…è®¸å°†ä»»ä½•æ•´æ•°ç±»å‹è½¬æ¢ä¸ºä»»ä½•æŒ‡é’ˆç±»å‹ä»¥åŠåå‘è½¬æ¢ã€‚

æ»¥ç”¨ `reinterpret_cast` è¿ç®—ç¬¦å¯èƒ½å¾ˆå®¹æ˜“å¸¦æ¥é£é™©ã€‚`reinterpret_cast` è¿ç®—ç¬¦å¯ç”¨äº `char*` åˆ° `int*` æˆ– `One_class*` åˆ° `Unrelated_class*` ä¹‹ç±»çš„è½¬æ¢ï¼Œè¿™æœ¬èº«å¹¶ä¸å®‰å…¨ã€‚`reinterpret_cast` è¿ç®—ç¬¦æ— æ³•å¼ºåˆ¶è½¬æ¢æ‰ `const`ã€`volatile` æˆ– `__unaligned` ç‰¹æ€§ã€‚

ä¸€èˆ¬ä½¿ç”¨ `reinterpret_cast` å°†ç©ºæŒ‡é’ˆå€¼è½¬æ¢ä¸ºç›®æ ‡ç±»å‹çš„ç©ºæŒ‡é’ˆå€¼ã€‚ä¹Ÿå…è®¸å°†æŒ‡é’ˆè§†ä¸ºæ•´æ•°ç±»å‹ï¼Œå¹¶åœ¨æŒ‡é’ˆå’Œæ•´æ•°ä¹‹é—´ç›¸äº’è½¬æ¢ã€‚

```c++
struct IntVector2 { int x, y; };
struct IntVector3 { int x, y, z; };

int main() {
	IntVector2* v2 = new IntVector2{ 2, 2 };
	IntVector3* v3 = new IntVector3{ 3, 3, 3 };

	IntVector2* pv2 = reinterpret_cast<IntVector2*>(v3);  // v3 cast to v2; not safy
	pv2->x = 1; pv2->y = 99;
	printf("v3 = {%d,%d,%d}", v3->x, v3->y, v3->z); // {1,99,3}

	IntVector3* pv3 = reinterpret_cast<IntVector3*>(v2);  // v2 cast to v3; not safy
	pv3->x = 9; pv3->y = 9;
	printf("v2 = {%d,%d}", v2->x, v2->y); // {9,9}
	pv3->z = 10;  // maybe stackOverflow ; danger!
    
	// æœªå®šä¹‰è¡Œä¸º
	IntVector3 v = static_cast<IntVector3>(*pv3);  
	printf("v = {%d,%d,%d}", v.x, v.y, v.z); // {9,9,10}
}
```



>---
#### æŒ‡é’ˆè¿ç®—

```c++
// address-of
int * pi = &i;
const type cp = &const_type;
volatile type vp = &vola_type;
// ç®—æ•°
int * p = p + integer;
int * p = p - integer;
ptrdiff_t diff = p1 - p2;
p++;
p--;
p += i;
p -= i;
```




		
		
		
		
		
		
		
		
		



	

		
	


---
### ç±»å‹ä¸å˜é‡


---
### è¡¨è¾¾å¼


---
### è¯­å¥



---
### é¢„å¤„ç†æŒ‡ä»¤

```c++
// æ¡ä»¶åŒ…å«
defined                       // æ¡ä»¶ç¼–è¯‘ç¬¦å·æµ‹è¯•
__has_include (C++17)         // æºæ–‡ä»¶åŒ…å«æµ‹è¯•
__has_cpp_attribute (C++20)   // å±æ€§æµ‹è¯•
// æ¡ä»¶æ§åˆ¶
#if
#elif
#else
#endif
#ifdef
#ifndef
#elifdef (C++23)
#elifndef (C++23)
// å®å®šä¹‰ä¸å–æ¶ˆå®å®šä¹‰
#define
#undef
// æºæ–‡ä»¶åŒ…å«
#include
import (C++20)
// æ–‡ä»¶åå’Œè¡Œä¿¡æ¯
#line
// è¯Šæ–­æŒ‡ä»¤
#error
#warning (C++23)
// å®ç°å®šä¹‰è¡Œä¸ºæ§åˆ¶
#pragma
_Pragma

export (C++20)
module (C++20)
```

>---
#### æ¡ä»¶åŒ…å«

```c++
defined ( identifier )               // æ¡ä»¶ç¼–è¯‘ç¬¦å·æµ‹è¯•
__has_include ( heeder-name )        // æºæ–‡ä»¶åŒ…å«æµ‹è¯•
__has_cpp_attribute ( pre-tokens )   // å±æ€§æµ‹è¯•
```

æ§åˆ¶æ¡ä»¶åŒ…å«çš„è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªæ•´æ•°å¸¸é‡è¡¨è¾¾å¼ï¼Œå®ƒå¯èƒ½åŒ…å«é›¶ä¸ªæˆ–å¤šä¸ª `defined()`, `__has_include()`, `__has_cpp_attribute()` ä¸€å…ƒè¿ç®—ç¬¦è¡¨è¾¾å¼ã€‚

å·²å­˜åœ¨å®šä¹‰çš„å®åç§°ï¼Œ`defined(id)` è¿”å› 1ï¼Œè¿™æ ·çš„å®åç§°ç”± `#define` å®šä¹‰ä¸”åœ¨æ¡ä»¶åŒ…å«çš„è°ƒç”¨ç‚¹ä¹‹å‰æ²¡æœ‰ `#undef` å–æ¶ˆã€‚

`__has_include( header )` æ£€ç´¢ `header` æ˜¯å¦ç”± `#include` å¯¼å…¥ï¼›åœ¨ `__has_cpp_attribute( attr-pp-token )` ä¸­ï¼Œå¦‚æœå®ç°æ”¯æŒé€šè¿‡å±•å¼€å¹¶è§£é‡Š `pp-token` æŒ‡å®šåç§°çš„å±æ€§ï¼Œåˆ™æ¯ä¸ªåŒ…å«è¡¨è¾¾ç¤ºéƒ½å°†æ›¿æ¢ä¸ºç›¸åº”çš„ `pp-token` çš„æ•´æ•°å½¢å¼ã€‚

```c++
#define assume              202207L
#define carries_dependency  200809L
#define deprecated          201309L
#define fallthrough         201603L
#define likely              201803L
#define maybe_unused        201603L
#define no_unique_address   201803L
#define nodiscard           201907L
#define noreturn            200809L
#define unlikely            201803L
```

>---
#### æ¡ä»¶æ§åˆ¶æŒ‡ä»¤

```c++
#if constant-expr
#elif constant-expr
#ifdef identifier      // #if defined identifier
#ifndef identifier     // #if !defined identifier 
#elifdef identifier    // #elif defined identifier 
#elifndef identifier   // #elif !defined identifier 
#else
#endif
```

`#ifdef`ã€`#ifndef`ã€`#elifdef` å’Œ `#elifndef` æŒ‡ä»¤ä»¥åŠ `defined` æ¡ä»¶åŒ…å«è¿ç®—ç¬¦åº”å°† `__has_include` å’Œ `__has_cpp_attribute` è§†ä¸ºå®šä¹‰å®çš„åç§°ã€‚

è¿™äº›é¢„å¤„ç†æŒ‡ä»¤æ£€æŸ¥æ§åˆ¶è¡¨è¾¾å¼çš„è®¡ç®—ç»“æœæ˜¯å¦ä¸ºéé›¶ï¼›æ ¹æ®ç»“æœæ¥é€‰æ‹©æ€§çš„è·³è¿‡ç»“æœä¸º `false`ï¼ˆé›¶ï¼‰çš„ç»„ï¼›ç»„ä¸­çš„ä»£ç å’ŒåµŒå¥—é¢„å¤„ç†æŒ‡ä»¤è¢«å¿½ç•¥ã€‚

```c++
#if __has_include(<optional>)
# include <optional>
# if __cpp_lib_optional >= 201603
# define have_optional 1
# endif
#elif __has_include(<experimental/optional>)
# include <experimental/optional>
# if __cpp_lib_experimental_optional >= 201411
# define have_optional 1
# define experimental_optional 1
# endif
#endif
#ifndef have_optional
# define have_optional 0
#endif

#if __has_cpp_attribute(acme::deprecated)
# define ATTR_DEPRECATED(msg) [[acme::deprecated(msg)]]
#else
# define ATTR_DEPRECATED(msg) [[deprecated(msg)]]
#endif
ATTR_DEPRECATED("This function is deprecated") void anvil();
```

>---
#### æºæ–‡ä»¶åŒ…å«

```c++
#include <header-name> 
#include "header-name" 
#include "source-name" 
```

`#include` æŒ‡ä»¤ä»¥å®ç°å®šä¹‰çš„æ–¹å¼æœç´¢å‘½åæºæ–‡ä»¶ï¼Œå¹¶å°†è¯¥ä½ç½®æ›¿æ¢ä¸ºæºæ–‡ä»¶çš„å…¨éƒ¨å†…å®¹ã€‚å¦‚æœ *header-name* æ ‡è¯†ä¸€ä¸ªå¯å¯¼å…¥çš„å¤´æ–‡ä»¶ï¼Œåˆ™ç”±å®ç°å®šä¹‰æ˜¯å¦å°† `#include` é¢„å¤„ç†æŒ‡ä»¤æ›¿æ¢ä¸º `import header-name;`ã€‚

```c++
#if VERSION == 1
#define INCFILE "vers1.h"
#elif VERSION == 2
#define INCFILE "vers2.h" // and so on
#else
#define INCFILE "versN.h"
#endif
#include INCFILE
```

>---
#### æ¨¡å—æŒ‡ä»¤

```c++

```

æ¨¡å—æŒ‡ä»¤ä¸­æ¨¡å—é¢„å¤„ç†ä»¤ç‰Œä¹‹åçš„ä»»ä½•é¢„å¤„ç†ä»¤ç‰Œçš„å¤„ç†æ–¹å¼ä¸æ™®é€šæ–‡æœ¬ç›¸åŒã€‚

