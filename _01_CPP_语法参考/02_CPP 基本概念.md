# CPP：基本概念

本节介绍 C++ 语言的基本概念。C++ 的一个实体 (*Entity*) 可以是一个值、对象、引用、结构化绑定、函数、枚举数、类型、类成员、位字段、模板、模板专门化、命名空间、或包等。

## 1. 声明与定义

一个名称可以是 *identifier*, *operator-function-id*, *literal-operator-id* 或 *conversion-function-id*。

每个名称都由声明引入，它可以是
- 名称声明、块声明或成员声明：
- 初始化声明符
- 结构化绑定声明中的标识符
- 初始化捕获
- 条件与声明符
- 成员声明器
- 使用声明器
- 参数声明
- 类型参数
- 引入名称的详细类型说明符
- 类说明符
- 枚举说明符或枚举定义
- 异常声明
- 注入类的隐式声明

实体 *E* 由声明 *E* 引入的名称（如果有）表示，或者由指定 *E* 的声明引入的 *typedef-name* 表示。变量是通过声明非静态数据成员或对象的引用引入的，变量名（如果有）表示引用或对象。局部实体是一个具有自动存储时间的变量，一个结构化绑定对应的变量就是这样的一个实体，或者是 *this* 对象。有些名称表示类型或模板。通常，每当遇到一个名称时，在继续解析包含该名称的程序之前，有必要确定该名称是否表示这些实体之一。确定这一点的过程称为名称查找。

若两个名称相同，则需满足：
- 它们是由相同字符序列组成的标识符，或者
- 它们是由相同的操作符组成的 *operator-function-id*，或
- 它们是由等价类型组成的 *conversion-function-ids*，或
- 它们是由相同的字面值后缀标识符组成的 *literal-operator-ids*。

在多个翻译单元中使用的名称可能潜在地引用这些翻译单元中的同一实体，这取决于每个翻译单元中指定的名称的链接。

声明可以 (重新) 在翻译单元中引入一个或多个名称和 / 或实体。如果是，则声明指定这些名称的解释和语义属性。如果一个实体或 *typedef-name* *X* 的声明可以从它到达另一个 *X* 的声明，那么它就是 *X* 的重新声明。声明的效力还包括：
- 静态断言
- 控制模板实例化
- 指示构造函数的模板实参推导
- 使用特性
- 在空声明的情况下什么都不做

由声明声明的每个实体也由该声明定义，除非：
- 它声明一个函数而不指定函数体
- 它包含 `extern` 说明符或 *linkage-specification*，且既没有初始化式也没有函数体
- 它在类定义中声明非内联静态数据成员
- 它在类定义之外声明一个静态数据成员，变量在类中使用 `constexpr` 说明符定义（已弃用）
- 它是一个详细的类型说明符
- 它是一个 `opaque-enum-declaration`
- 它是一个模板形参
- 它是函数声明器中的形参声明，而不是函数定义的声明器
- 它是一个类型定义声明
- 它是一个别名声明
- 它是一个 *using* 声明
- 它是一个 *deduction-guide*
- 它是一个 *static_assert* 声明
- 它是一个特性声明
- 它是一个空声明
- 它是一个 *using* 指令
- 它是一个 *using*-*enum* 声明
- 它是模板声明，其 *template-head* 后面没有概念定义或定义函数、类、变量或静态数据成员的声明
- 它是显式实例化声明，或
- 它是一个显式专门化，其声明不是定义

声明被称为它所定义的每个实体的定义。

```c++
int a;                          // defines a
extern const int c = 1;         // defines c
int f(int x) { return x+a; }    // defines f and defines x
struct S { int a; int b; };     // defines S, S::a, and S::b
struct X {                      // defines X
    int x;                      // defines non-static data member x
    static int y;               // declares static data member y
    X(): x(0) { }               // defines a constructor of X
};
int X::y = 1;                   // defines X::y
enum { up, down };              // defines up and down
namespace N { int d; }          // defines N and N::d
namespace N1 = N;               // defines N1
X anX;                          // defines anX
```

然而以下这些只是声明：

```c++
extern int a;               // declares a
extern const int c;         // declares c
int f(int);                 // declares f
struct S;                   // declares S
typedef int Int;            // declares Int
extern X anotherX;          // declares anotherX
using N::d;                 // declares d
```

在某些情况下，C++ 实现隐式地定义了默认构造函数、复制构造函数、移动构造函数、复制赋值操作符、移动赋值操作符或 *destructor* 成员函数。

```c++
#include <string>
struct C {
    std::string s;  // std::string is the standard library class (23.4)
};
int main() {
    C a;
    C b = a;
    b = a;
}
// 实现将隐式定义函数，使 C 的定义等同于
struct C {
    std::string s;
    C() : s() { }
    C(const C& x): s(x.s) { }
    C(C&& x): s(static_cast<std::string&&>(x.s)) { }
    //      : s(std::move(x.s)) { }
    C& operator=(const C& x) { s = x.s; return *this; }
    C& operator=(C&& x) { s = static_cast<std::string&&>(x.s); return *this; }
    //                  { s = std::move(x.s); return *this; }
    ~C() { }
};
```

类名也可以通过详细的类型说明符隐式声明。

在对象的定义中，该对象的类型不能是不完整类型、抽象类类型或其数组 (可能是多维的)。

---
## 2. One-Definition Rule (odr)

以下每一项都被称为可定义项：
- 类类型
- 枚举类型
- 函数
- 变量
- 模板实体
- 形参的默认实参 (用于给定范围内的函数)，或
- 默认模板参数

任何翻译单位不得对任何可定义的项目包含一个以上的定义。除非是未求值的操作数、其子表达式或此类上下文中初始化或转换序列中的转换，否则表达式或转换可能被求值。表达式 *E* 的可能结果集定义如下：
- 如果 *E* 是 *id-expression*，则该集合只包含 *E*。
- 如果 *E* 是一个带有数组操作数的下标操作，则该集合包含该操作数的可能结果。
- 如果 *E* 是形式为 *E*<sub>1</sub> . `template`<sub>opt</sub> *E*<sub>2</sub> 命名的一个非静态数据成员的类成员访问表达式，则该集合包含 *E*<sub>1</sub> 的潜在结果。
- 如果 *E* 是命名静态数据成员的类成员访问表达式，则该集合包含指定数据成员的 *id-expression*。
- 如果 *E* 是 *E*<sub>1</sub> .* *E*<sub>2</sub> 形式的成员指针表达式，则该集合包含 *E*<sub>1</sub>的可能结果。
- 如果 *E* 的形式为 (*E*<sub>1</sub>)，则该集合包含 *E*<sub>1</sub> 的潜在结果。
- 如果 *E* 是左值条件表达式，则该集合是第二个和第三个操作数的可能结果集合的并集。
- 如果 *E* 是逗号表达式，则该集合包含右操作数的可能结果。
- 否则，该集合为空。

此集合是 *id-expression* 的集合 (可能为空)，每个 *id-expression* 要么是 *E*，要么是 *E* 的子表达式。

在下面的示例中，`n` 的初始化式的潜在结果集包含第一个 `S::x` 子表达式，但不包含第二个 `S::x` 子表达式。

```c++
struct S { static const int x = 0; };
const int &f(const int &r);
int n = b ? (1, S::x)           // S::x is not odr-used here
        : f(S::x);              // S::x is odr-used here, so a definition is required
```

函数通过表达式或转换进行命名，具体如下：
- 如果函数是作为形成该表达式或转换的一部分执行的重载解析中的重载集的选定成员，则通过表达式或转换对函数进行命名，除非它是纯虚函数，并且表达式不是以显式限定的名称命名函数的 *id-expression*，或者表达式形成了成员指针。这包括获取函数的地址，对命名函数的调用，运算符重载，用户定义的转换，*new-expressions* 的分配函数，以及非默认初始化。即使实际上由实现省略了调用，也认为选择复制或移动类类型对象的构造函数是由表达式或转换命名的。
- 如果它是由重载解析选定的分配函数的单一匹配的 *deallocation* 函数，那么类的 *deallocation* 函数由 *new-expression* 命名。
- 如果它是选定的常规 *deallocation* 函数，那么类的 *deallocation* 函数由 *delete-expression* 命名。

如果表达式是表示它的 *id-expression*，那么变量由表达式命名。由潜在求值表达式 *E* 命名的变量 `x` 被 *E* *odr-used* 使用，除非
- `x` 是可在常量表达式中使用的引用，或
- `x` 是可在常量表达式中使用并且没有可变子对象的非引用类型变量，且 *E* 是应用 *lvalue-to-rvalue* 转换的非易失性限定非类类型表达式的潜在结果集的元素，或
- `x` 是非引用类型的变量，且 *E* 是应用 *lvalue-to-rvalue* 转换的丢弃值表达式的潜在结果集的元素。

如果结构化绑定出现为潜在求值表达式，则其被 *odr-used*。

如果 `this` 作为潜在求值表达式出现（包括作为非静态成员函数的主体中的隐式转换的结果），则 `*this` 被 *odr-used*。

如果虚成员函数不是纯的，则它被 *odr-used*。如果函数由潜在求值表达式或转换命名，则函数被 *odr-used*。类的非放置分配或 *deallocation* 函数由该类的构造函数的定义 *odr-used*。类的非放置 *deallocation* 函数由该类的析构函数的定义 *odr-used*，或者由在虚析构函数的定义点的查找选定。

类中的赋值运算符函数由另一个类的隐式定义的复制赋值或移动赋值函数 *odr-used*。构造函数对类进行 *odr-used*。如果可能调用类的析构函数，则析构函数被 *odr-used*。

局部实体在一个范围内是 *odr-usable*，如果：
- 局部实体不是 `*this`，或者存在封闭的类或非 lambda 函数参数范围，如果最内层的这样的范围是函数参数范围，它对应于非静态成员函数，和
- 对于在实体引入的点和范围之间的每个干预范围（其中 `*this` 被认为是在最内层的封闭类或非 lambda 函数定义范围内引入的），要么：
  - 干预范围是块范围，或
  - 干预范围是 lambda 表达式的函数参数范围，该表达式具有命名实体的简单捕获或具有捕获默认值，且 lambda 表达式的块范围也是干预范围。

如果一个局部实体在其不可用的范围中被异常使用，则该程序是格式错误的。

```c++
void f(int n) {
    [] { n = 1; };              // error: n is not odr-usable due to intervening lambda-expression
    struct A {
        void f() { n = 2; }     // error: n is not odr-usable due to intervening function definition scope
    };
    void g(int = n);            // error: n is not odr-usable due to intervening function parameter scope
    [=](int k = n) {};          // error: n is not odr-usable due to being
                                // outside the block scope of the lambda-expression
    [&] { [n]{ return n; }; };  // OK
}
```

每个程序应包含至少一个在该程序中被丢弃语句之外的不常用的函数或变量的定义；不需要诊断。定义可以显式地出现在程序中，也可以在标准库或用户定义的库中找到，或者 (适当时) 隐式地定义。

```c++
auto f(){
    struct A {}
    return A{};
}
decltype(f()) g();
auto x = g();
```

包含此翻译单元的程序是格式错误的，因为 `g` 是 *odr-used* 但未定义的，并且不能在任何其他翻译单元中定义，因为局部类 `A` 不能在此翻译单元之外命名。

定义域是私有模块片段或翻译单元中不包括其私有模块片段 (如果有的话) 的部分。内联函数或变量的定义应该可以从每个定义域的末尾到达，该定义域在丢弃的语句之外被 *odr-used*。一个类的定义应该在每一个使用类的上下文中都是可访问的，而这种使用方式要求类类型是完整的。下面的完整翻译单元是格式良好的，即使它没有定义 `X`：

```c++
struct X;       // declare X as a struct type
struct X* x1;   // use X in pointer formation
X* x2;          // use X in pointer formation
```

声明和表达式的规则描述了在哪些上下文中需要完整的类类型。在下列情况下，类类型 `T` 必须是完整的：
- 定义了类型 `T` 的对象，或者
- 声明类型为 `T` 的非静态类数据成员，或者
- 在 *new-expression* 中使用 `T` 作为分配类型或数组元素类型，或者
- 对引用类型 `T` 的左值应用 *lvalue-to-rvalue* 转换，或者
- 表达式被 (隐式或显式) 转换为类型 `T`，或者
- 使用标准转换、`dynamic_cast` 或 `static_cast` 将非空指针常量且类型不是 *cv* `void*` 的表达式转换为指向 `T` 的指针类型或对 `T` 的引用类型
- 类成员访问操作符应用于类型为 `T` 的表达式，或者
- `typeid` 操作符或 `sizeof` 操作符应用于 `T` 类型的操作数，或
- 返回类型或参数类型为 `T` 的函数定义或调用，或者
- 定义具有 `T` 类型基类的类，或者
- 将类型为 `T` 的左值赋值给，或者、
- 类型 `T` 是 `alignof` 表达式的主体，或者
- 异常声明具有类型 `T`、对 `T` 的引用或指向 `T` 的指针。

对于任何具有多个翻译单位定义的可定义项 `D`。
- 如果 `D` 是一个非内联的非模板化函数或变量，或者
- 如果不同翻译单位的定义不满足以下要求，程序是格式错误的。只有当可定义项附加到命名模块，并且在出现后一个定义的地方可以访问先前的定义时，才需要诊断。给定这样一个项目，对于所有 `D` 的定义，或者，如果 `D` 是一个未命名的枚举，对于在任何给定程序点可到达的所有 `D` 的定义，应满足下列要求。
- 每个这样的定义不得附加到指定模块。
- 每个这样的定义应由相同的令牌序列组成，其中闭包类型的定义被认为由相应的 lambda 表达式的令牌序列组成。
- 在每个这样的定义中，根据查找的对应名称应指同一实体。在重载解析和部分模板专门化匹配之后，除了名称可以引用
  - 内部链接或没有链接的非易失性 `const` 对象，如果
    - 在 `D` 的所有定义中具有相同的字面值类型
    - 用常量表达式初始化
    - 在 `D` 的任何定义中都不 *odr-used*
    - 并且在 `D` 的所有定义中都有相同的值，
  - 或，用常量表达式初始化带有内部链接或没有链接的引用，使得该引用在 `D` 的所有定义中指向相同的实体。
- 在每个这样的定义中，除了 `D` 的默认实参和默认模板实参之外，对应的 lambda 表达式应该具有相同的闭包类型
- 在每个这样的定义中，相应的实体应具有相同的语言链接。
- 在每个这样的定义中，如果 `const` 对象在任何这样的定义中是常量初始化的，则具有静态或线程存储时间的 `const` 对象应被常量初始化。
- 在每个这样的定义中，对应的不依赖于值的明显常求值表达式应具有相同的值。
- 在每个这样的定义中，所引用的重载操作符、对转换函数、构造函数、操作符 *new* 函数和操作符 *delete* 函数的隐式调用都应指向同一个函数。
- 在每个此类定义中，（隐式或显式）函数调用使用的默认参数或（隐式或显式）*template-id* 或 *simple-template-id* 使用的默认模板参数被视为其令牌序列存在于 D 的定义中；也就是说，默认参数或默认模板参数受本段中描述的要求的约束（递归）。

就上述要求所言：
- 如果 D 是具有隐式声明构造函数的类，则就好像构造函数在使用它的每个翻译单元中隐式定义一样，并且每个翻译单元中的隐式定义都应为 D 的子对象调用相同的构造函数。

    ```c++
    // translation unit 1:
    struct X {
        X(int, int);
        X(int, int, int);
    };
    X::X(int, int = 0) { }
    class D {
        X x = 0;
    };
    D d1;                       //X(int, int) 由 D() 调用
    // translation unit 2:
    struct X {
        X(int, int);
        X(int, int, int);
    };
    X::X(int, int = 0, int = 0) { }
    class D {
        X x = 0;
    };
    D d2;                       // X(int, int, int) 由 D() 调用;
                                // D() 的隐含定义违反了 ODR
    ```

- 如果 D 是具有默认 *三向比较运算符* 函数的类，则就好像运算符在使用它的每个翻译单元中隐式定义，并且每个翻译单元中的隐式定义应为 D 的每个子对象调用相同的比较运算符。
- 如果 D 是模板，并且在多个转换单元中定义，则要求既适用于模板定义中使用的模板封闭范围中的名称，也适用于实例化时的依赖名称。

这些要求也适用于在 D 的每个定义中定义的相应实体（包括 lambda 表达式的闭包类型，但不包括在 D 的默认参数或默认模板参数中定义的实体或未在 D 中定义的实体）。对于每个这样的实体和 D 本身，行为就好像存在一个具有单一定义的单个实体，包括将这些要求应用于其他实体。该实体仍以多个翻译单元进行声明。特别是，出现在 D 类型中的 lambda 表达式可能会导致不同的声明具有不同的类型，并且出现在 D 的默认参数中的 lambda 表达式可能仍表示不同翻译单元中的不同类型。

```c++
inline void f(bool cond, void (*p)()){
    if(cond) f(false, []{});
}
inline void g(bool cond,void (*p)() = []{}){
    if(cond) g(false);
}
struct X{
    void h(bool cond void (*p)() = []{}){
        if(cond) h(false);
    }
};
```

如果 `f` 的定义出现在多个翻译单元中，则程序的行为就好像只有一个 `f` 定义一样。如果 `g` 的定义出现在多个翻译单元中，则程序格式不正确（不需要诊断），因为每个此类定义都使用一个默认参数，该参数引用不同的 lambda 表达式闭包类型。`X` 的定义可以出现在有效程序的多个翻译单元中；在 `X` 定义中 `X::h` 的默认参数中定义的 lambda 表达式表示每个转换单元中的相同闭包类型。

如果在程序中的任何时候，同一作用域中有多个可访问的未命名枚举定义，这些定义具有相同的第一个枚举器名称，并且没有用于链接目的的 *typedef* 名称，则这些未命名的枚举类型应相同；无需诊断。

---
## 3. 作用域（范围）

程序中的声明出现在许多作用域中，这些作用域通常是不连续的。全局范围包含整个程序；所有其他作用域 *S* 由一个声明、参数声明子句、语句或处理程序引入，这些子句出现在另一个包含 *S* 的作用域中。程序点的封闭范围是包含它的任何范围；最小的此类范围被称为该点的直接范围。如果作用域是或包含 *S* 但不包含 *P*，则作用域介入程序点 *P* 和作用域 *S*（不包含 *P*）之间。

除非另有说明：
- 包含作用域 *S* 的最小作用域是 *S* 的父作用域。
- 没有两个声明（重新）引入同一个实体。
- 声明位于其位置的直接作用域。
- 声明的目标范围是它所在的范围。
- 声明（重新）引入的任何名称都在其目标范围内绑定到该声明。

如果 *S* 是实体声明的目标范围，则该实体属于作用域 *S*。特殊情况包括：
- 模板参数范围仅是其他模板参数范围的父级
- 具有适当链接的相应声明声明相同的实体
- 模板声明中的声明与模板声明位于同一作用域中
- 友元声明以及限定名称和模板专用化的声明不绑定名称；具有限定名称的那些以指定范围为目标，而其他友元声明和某些精心设计的类型说明符 *S* 以更大的封闭范围为目标
- 块范围外部声明以较大的封闭范围为目标，但在其直接作用域中绑定名称。
- 无作用域枚举器的名称绑定在两个最内层的封闭作用域中。
- 类的名称也绑定在其自己的作用域中。
- 匿名联合的成员的名称绑定在联合的父作用域中。

如果满足以下条件，则两个非静态成员函数具有相应的对象参数：
- 恰好一个是没有 *ref-qualifier* 的隐式对象成员函数，并且在删除顶级引用后，它们的对象参数的类型是相同的，或者
- 它们的对象参数具有相同的类型。

如果满足以下条件，则两个非静态成员函数模板具有相应的对象参数：
- 恰好一个是没有 *ref-qualifier* 的隐式对象成员函数，在删除任何引用后，它们的对象参数类型是等效的，或者
- 其对象参数的类型是等价的。

如果两个函数模板的模板形参列表具有相同的长度，它们对应的模板形参相同，它们具有等效的非对象形参类型列表和返回类型 (如果有的话)，并且如果它们都是非静态成员，它们具有相应的对象形参，则它们具有相应的签名。

## 